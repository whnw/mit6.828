
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 df ed 00 00       	call   80ee10 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800034 <put_buffer>:

	return va;
}

static void
put_buffer(void *va) {
  800034:	55                   	push   %ebp
  800035:	89 e5                	mov    %esp,%ebp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800037:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  80003c:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80003f:	c6 80 28 60 81 00 00 	movb   $0x0,0x816028(%eax)
}
  800046:	5d                   	pop    %ebp
  800047:	c3                   	ret    

00800048 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  800048:	55                   	push   %ebp
  800049:	89 e5                	mov    %esp,%ebp
  80004b:	57                   	push   %edi
  80004c:	56                   	push   %esi
  80004d:	53                   	push   %ebx
  80004e:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  800057:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  80005a:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80005d:	0f 87 3a 01 00 00    	ja     80019d <serve_thread+0x155>
  800063:	8b 03                	mov    (%ebx),%eax
  800065:	ff 24 85 e0 1a 81 00 	jmp    *0x811ae0(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  80006c:	8b 46 04             	mov    0x4(%esi),%eax
  80006f:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  800072:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800075:	89 44 24 08          	mov    %eax,0x8(%esp)
  800079:	8d 45 84             	lea    -0x7c(%ebp),%eax
  80007c:	89 44 24 04          	mov    %eax,0x4(%esp)
  800080:	8b 06                	mov    (%esi),%eax
  800082:	89 04 24             	mov    %eax,(%esp)
  800085:	e8 c0 0f 00 00       	call   80104a <lwip_accept>
  80008a:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  80008c:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  800093:	00 
  800094:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800097:	89 44 24 04          	mov    %eax,0x4(%esp)
  80009b:	89 34 24             	mov    %esi,(%esp)
  80009e:	e8 f9 f5 00 00       	call   80f69c <memmove>
		break;
  8000a3:	e9 13 01 00 00       	jmp    8001bb <serve_thread+0x173>
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  8000a8:	8b 46 14             	mov    0x14(%esi),%eax
  8000ab:	89 44 24 08          	mov    %eax,0x8(%esp)
  8000af:	8d 46 04             	lea    0x4(%esi),%eax
  8000b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8000b6:	8b 06                	mov    (%esi),%eax
  8000b8:	89 04 24             	mov    %eax,(%esp)
  8000bb:	e8 45 11 00 00       	call   801205 <lwip_bind>
  8000c0:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  8000c2:	e9 f4 00 00 00       	jmp    8001bb <serve_thread+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8000c7:	8b 46 04             	mov    0x4(%esi),%eax
  8000ca:	89 44 24 04          	mov    %eax,0x4(%esp)
  8000ce:	8b 06                	mov    (%esi),%eax
  8000d0:	89 04 24             	mov    %eax,(%esp)
  8000d3:	e8 5f 1d 00 00       	call   801e37 <lwip_shutdown>
  8000d8:	89 c7                	mov    %eax,%edi
		break;
  8000da:	e9 dc 00 00 00       	jmp    8001bb <serve_thread+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  8000df:	8b 06                	mov    (%esi),%eax
  8000e1:	89 04 24             	mov    %eax,(%esp)
  8000e4:	e8 da 11 00 00       	call   8012c3 <lwip_close>
  8000e9:	89 c7                	mov    %eax,%edi
		break;
  8000eb:	e9 cb 00 00 00       	jmp    8001bb <serve_thread+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  8000f0:	8b 46 14             	mov    0x14(%esi),%eax
  8000f3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8000f7:	8d 46 04             	lea    0x4(%esi),%eax
  8000fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  8000fe:	8b 06                	mov    (%esi),%eax
  800100:	89 04 24             	mov    %eax,(%esp)
  800103:	e8 39 12 00 00       	call   801341 <lwip_connect>
  800108:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  80010a:	e9 ac 00 00 00       	jmp    8001bb <serve_thread+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  80010f:	8b 46 04             	mov    0x4(%esi),%eax
  800112:	89 44 24 04          	mov    %eax,0x4(%esp)
  800116:	8b 06                	mov    (%esi),%eax
  800118:	89 04 24             	mov    %eax,(%esp)
  80011b:	e8 df 12 00 00       	call   8013ff <lwip_listen>
  800120:	89 c7                	mov    %eax,%edi
		break;
  800122:	e9 94 00 00 00       	jmp    8001bb <serve_thread+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  800127:	8b 46 08             	mov    0x8(%esi),%eax
  80012a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80012e:	8b 46 04             	mov    0x4(%esi),%eax
  800131:	89 44 24 08          	mov    %eax,0x8(%esp)
  800135:	89 74 24 04          	mov    %esi,0x4(%esp)
  800139:	8b 06                	mov    (%esi),%eax
  80013b:	89 04 24             	mov    %eax,(%esp)
  80013e:	e8 e8 15 00 00       	call   80172b <lwip_recv>
  800143:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  800145:	eb 74                	jmp    8001bb <serve_thread+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  800147:	8b 46 08             	mov    0x8(%esi),%eax
  80014a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80014e:	8b 46 04             	mov    0x4(%esi),%eax
  800151:	89 44 24 08          	mov    %eax,0x8(%esp)
  800155:	8d 46 0c             	lea    0xc(%esi),%eax
  800158:	89 44 24 04          	mov    %eax,0x4(%esp)
  80015c:	8b 06                	mov    (%esi),%eax
  80015e:	89 04 24             	mov    %eax,(%esp)
  800161:	e8 76 17 00 00       	call   8018dc <lwip_send>
  800166:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800168:	eb 51                	jmp    8001bb <serve_thread+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  80016a:	8b 46 08             	mov    0x8(%esi),%eax
  80016d:	89 44 24 08          	mov    %eax,0x8(%esp)
  800171:	8b 46 04             	mov    0x4(%esi),%eax
  800174:	89 44 24 04          	mov    %eax,0x4(%esp)
  800178:	8b 06                	mov    (%esi),%eax
  80017a:	89 04 24             	mov    %eax,(%esp)
  80017d:	e8 10 18 00 00       	call   801992 <lwip_socket>
  800182:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  800184:	eb 35                	jmp    8001bb <serve_thread+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800186:	89 74 24 04          	mov    %esi,0x4(%esp)
  80018a:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  800191:	e8 e9 b0 00 00       	call   80b27f <jif_input>
		r = 0;
  800196:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  80019b:	eb 4c                	jmp    8001e9 <serve_thread+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80019d:	89 74 24 08          	mov    %esi,0x8(%esp)
  8001a1:	8b 43 04             	mov    0x4(%ebx),%eax
  8001a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8001a8:	c7 04 24 00 19 81 00 	movl   $0x811900,(%esp)
  8001af:	e8 c4 ed 00 00       	call   80ef78 <cprintf>
		r = -E_INVAL;
  8001b4:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		break;
  8001b9:	eb 2e                	jmp    8001e9 <serve_thread+0x1a1>
	}

	if (r == -1) {
  8001bb:	83 ff ff             	cmp    $0xffffffff,%edi
  8001be:	75 29                	jne    8001e9 <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  8001c0:	8b 03                	mov    (%ebx),%eax
  8001c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8001c6:	c7 44 24 08 35 1a 81 	movl   $0x811a35,0x8(%esp)
  8001cd:	00 
  8001ce:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  8001d5:	00 
  8001d6:	8d 75 84             	lea    -0x7c(%ebp),%esi
  8001d9:	89 34 24             	mov    %esi,(%esp)
  8001dc:	e8 e4 f2 00 00       	call   80f4c5 <snprintf>
		perror(buf);
  8001e1:	89 34 24             	mov    %esi,(%esp)
  8001e4:	e8 4e af 00 00       	call   80b137 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  8001e9:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8001ec:	74 1f                	je     80020d <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  8001ee:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8001f5:	00 
  8001f6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8001fd:	00 
  8001fe:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800202:	8b 43 04             	mov    0x4(%ebx),%eax
  800205:	89 04 24             	mov    %eax,(%esp)
  800208:	e8 ff fd 00 00       	call   81000c <ipc_send>

	put_buffer(args->req);
  80020d:	8b 43 08             	mov    0x8(%ebx),%eax
  800210:	e8 1f fe ff ff       	call   800034 <put_buffer>
	sys_page_unmap(0, (void*) args->req);
  800215:	8b 43 08             	mov    0x8(%ebx),%eax
  800218:	89 44 24 04          	mov    %eax,0x4(%esp)
  80021c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800223:	e8 94 f7 00 00       	call   80f9bc <sys_page_unmap>
	free(args);
  800228:	89 1c 24             	mov    %ebx,(%esp)
  80022b:	e8 30 0c 01 00       	call   810e60 <free>
}
  800230:	81 c4 8c 00 00 00    	add    $0x8c,%esp
  800236:	5b                   	pop    %ebx
  800237:	5e                   	pop    %esi
  800238:	5f                   	pop    %edi
  800239:	5d                   	pop    %ebp
  80023a:	c3                   	ret    

0080023b <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  80023b:	55                   	push   %ebp
  80023c:	89 e5                	mov    %esp,%ebp
  80023e:	56                   	push   %esi
  80023f:	53                   	push   %ebx
  800240:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  800243:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  800246:	e8 32 f9 00 00       	call   80fb7d <sys_time_msec>
  80024b:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  80024d:	e8 fa aa 00 00       	call   80ad4c <lwip_core_lock>
		t->func();
  800252:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  800255:	e8 f7 aa 00 00       	call   80ad51 <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  80025a:	03 33                	add    (%ebx),%esi
  80025c:	89 74 24 08          	mov    %esi,0x8(%esp)
  800260:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800267:	00 
  800268:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80026f:	e8 f8 ad 00 00       	call   80b06c <thread_wait>
  800274:	eb d0                	jmp    800246 <net_timer+0xb>

00800276 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800276:	55                   	push   %ebp
  800277:	89 e5                	mov    %esp,%ebp
  800279:	53                   	push   %ebx
  80027a:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  80027d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800280:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800282:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800285:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800288:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80028c:	c7 44 24 08 3b 02 80 	movl   $0x80023b,0x8(%esp)
  800293:	00 
  800294:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800298:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80029f:	e8 4d ab 00 00       	call   80adf1 <thread_create>
	if (r < 0)
  8002a4:	85 c0                	test   %eax,%eax
  8002a6:	79 28                	jns    8002d0 <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  8002a8:	89 04 24             	mov    %eax,(%esp)
  8002ab:	e8 78 ae 00 00       	call   80b128 <e2s>
  8002b0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8002b4:	c7 44 24 08 24 19 81 	movl   $0x811924,0x8(%esp)
  8002bb:	00 
  8002bc:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  8002c3:	00 
  8002c4:	c7 04 24 44 1a 81 00 	movl   $0x811a44,(%esp)
  8002cb:	e8 b0 eb 00 00       	call   80ee80 <_panic>
}
  8002d0:	83 c4 14             	add    $0x14,%esp
  8002d3:	5b                   	pop    %ebx
  8002d4:	5d                   	pop    %ebp
  8002d5:	c3                   	ret    

008002d6 <tcpip_init_done>:

static void
tcpip_init_done(void *arg)
{
  8002d6:	55                   	push   %ebp
  8002d7:	89 e5                	mov    %esp,%ebp
  8002d9:	83 ec 18             	sub    $0x18,%esp
  8002dc:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  8002df:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  8002e5:	89 04 24             	mov    %eax,(%esp)
  8002e8:	e8 9a aa 00 00       	call   80ad87 <thread_wakeup>
}
  8002ed:	c9                   	leave  
  8002ee:	c3                   	ret    

008002ef <serve_init>:

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  8002ef:	55                   	push   %ebp
  8002f0:	89 e5                	mov    %esp,%ebp
  8002f2:	56                   	push   %esi
  8002f3:	53                   	push   %ebx
  8002f4:	83 ec 30             	sub    $0x30,%esp
  8002f7:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  8002fa:	e8 4d aa 00 00       	call   80ad4c <lwip_core_lock>

	uint32_t done = 0;
  8002ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800306:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800309:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80030d:	c7 04 24 d6 02 80 00 	movl   $0x8002d6,(%esp)
  800314:	e8 fc 23 00 00       	call   802715 <tcpip_init>
	lwip_core_unlock();
  800319:	e8 33 aa 00 00       	call   80ad51 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  80031e:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  800325:	ff 
  800326:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80032d:	00 
  80032e:	89 1c 24             	mov    %ebx,(%esp)
  800331:	e8 36 ad 00 00       	call   80b06c <thread_wait>
	lwip_core_lock();
  800336:	e8 11 aa 00 00       	call   80ad4c <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  80033b:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  80033e:	8b 45 0c             	mov    0xc(%ebp),%eax
  800341:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  800344:	8b 45 10             	mov    0x10(%ebp),%eax
  800347:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  80034a:	c7 44 24 18 33 6a 80 	movl   $0x806a33,0x18(%esp)
  800351:	00 
  800352:	c7 44 24 14 87 b3 80 	movl   $0x80b387,0x14(%esp)
  800359:	00 
  80035a:	c7 44 24 10 00 60 81 	movl   $0x816000,0x10(%esp)
  800361:	00 
  800362:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800365:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800369:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80036c:	89 44 24 08          	mov    %eax,0x8(%esp)
  800370:	8d 45 e8             	lea    -0x18(%ebp),%eax
  800373:	89 44 24 04          	mov    %eax,0x4(%esp)
  800377:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  80037e:	e8 b2 47 00 00       	call   804b35 <netif_add>
  800383:	85 c0                	test   %eax,%eax
  800385:	75 1c                	jne    8003a3 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  800387:	c7 44 24 08 44 19 81 	movl   $0x811944,0x8(%esp)
  80038e:	00 
  80038f:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  800396:	00 
  800397:	c7 04 24 44 1a 81 00 	movl   $0x811a44,(%esp)
  80039e:	e8 dd ea 00 00       	call   80ee80 <_panic>

	netif_set_default(nif);
  8003a3:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  8003aa:	e8 0d 48 00 00       	call   804bbc <netif_set_default>
	netif_set_up(nif);
  8003af:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  8003b6:	e8 57 48 00 00       	call   804c12 <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  8003bb:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8003c2:	b9 4f 1a 81 00       	mov    $0x811a4f,%ecx
  8003c7:	ba 91 9b 80 00       	mov    $0x809b91,%edx
  8003cc:	b8 04 60 81 00       	mov    $0x816004,%eax
  8003d1:	e8 a0 fe ff ff       	call   800276 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  8003d6:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  8003dd:	b9 59 1a 81 00       	mov    $0x811a59,%ecx
  8003e2:	ba 4c 5c 80 00       	mov    $0x805c4c,%edx
  8003e7:	b8 10 60 81 00       	mov    $0x816010,%eax
  8003ec:	e8 85 fe ff ff       	call   800276 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  8003f1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8003f8:	b9 65 1a 81 00       	mov    $0x811a65,%ecx
  8003fd:	ba 77 60 80 00       	mov    $0x806077,%edx
  800402:	b8 1c 60 81 00       	mov    $0x81601c,%eax
  800407:	e8 6a fe ff ff       	call   800276 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80040c:	89 34 24             	mov    %esi,(%esp)
  80040f:	e8 a0 77 00 00       	call   807bb4 <inet_ntoa>
  800414:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  800418:	0f b6 05 6a c2 b3 00 	movzbl 0xb3c26a,%eax
  80041f:	89 44 24 18          	mov    %eax,0x18(%esp)
  800423:	0f b6 05 69 c2 b3 00 	movzbl 0xb3c269,%eax
  80042a:	89 44 24 14          	mov    %eax,0x14(%esp)
  80042e:	0f b6 05 68 c2 b3 00 	movzbl 0xb3c268,%eax
  800435:	89 44 24 10          	mov    %eax,0x10(%esp)
  800439:	0f b6 05 67 c2 b3 00 	movzbl 0xb3c267,%eax
  800440:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800444:	0f b6 05 66 c2 b3 00 	movzbl 0xb3c266,%eax
  80044b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80044f:	0f b6 05 65 c2 b3 00 	movzbl 0xb3c265,%eax
  800456:	89 44 24 04          	mov    %eax,0x4(%esp)
  80045a:	c7 04 24 64 19 81 00 	movl   $0x811964,(%esp)
  800461:	e8 12 eb 00 00       	call   80ef78 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  800466:	e8 e6 a8 00 00       	call   80ad51 <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  80046b:	c7 04 24 71 1a 81 00 	movl   $0x811a71,(%esp)
  800472:	e8 01 eb 00 00       	call   80ef78 <cprintf>
}
  800477:	83 c4 30             	add    $0x30,%esp
  80047a:	5b                   	pop    %ebx
  80047b:	5e                   	pop    %esi
  80047c:	5d                   	pop    %ebp
  80047d:	c3                   	ret    

0080047e <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80047e:	55                   	push   %ebp
  80047f:	89 e5                	mov    %esp,%ebp
  800481:	57                   	push   %edi
  800482:	56                   	push   %esi
  800483:	53                   	push   %ebx
  800484:	83 ec 3c             	sub    $0x3c,%esp

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800487:	bb 00 00 00 00       	mov    $0x0,%ebx
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80048c:	8d 7d e0             	lea    -0x20(%ebp),%edi
  80048f:	eb 06                	jmp    800497 <serve+0x19>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  800491:	e8 a7 aa 00 00       	call   80af3d <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800496:	43                   	inc    %ebx
  800497:	e8 0a a9 00 00       	call   80ada6 <thread_wakeups_pending>
  80049c:	85 c0                	test   %eax,%eax
  80049e:	74 05                	je     8004a5 <serve+0x27>
  8004a0:	83 fb 1f             	cmp    $0x1f,%ebx
  8004a3:	7e ec                	jle    800491 <serve+0x13>
			thread_yield();

		perm = 0;
  8004a5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004ac:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8004b1:	80 b8 28 60 81 00 00 	cmpb   $0x0,0x816028(%eax)
  8004b8:	74 08                	je     8004c2 <serve+0x44>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004ba:	40                   	inc    %eax
  8004bb:	83 f8 14             	cmp    $0x14,%eax
  8004be:	75 f1                	jne    8004b1 <serve+0x33>
  8004c0:	eb 05                	jmp    8004c7 <serve+0x49>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8004c2:	83 f8 14             	cmp    $0x14,%eax
  8004c5:	75 1c                	jne    8004e3 <serve+0x65>
		panic("NS: buffer overflow");
  8004c7:	c7 44 24 08 8a 1a 81 	movl   $0x811a8a,0x8(%esp)
  8004ce:	00 
  8004cf:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8004d6:	00 
  8004d7:	c7 04 24 44 1a 81 00 	movl   $0x811a44,(%esp)
  8004de:	e8 9d e9 00 00       	call   80ee80 <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8004e3:	8d b0 eb ff 00 00    	lea    0xffeb(%eax),%esi
  8004e9:	c1 e6 0c             	shl    $0xc,%esi
	buse[i] = 1;
  8004ec:	c6 80 28 60 81 00 01 	movb   $0x1,0x816028(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8004f3:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8004f7:	89 74 24 04          	mov    %esi,0x4(%esp)
  8004fb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8004fe:	89 04 24             	mov    %eax,(%esp)
  800501:	e8 96 fa 00 00       	call   80ff9c <ipc_recv>
  800506:	89 c3                	mov    %eax,%ebx
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800508:	83 f8 0c             	cmp    $0xc,%eax
  80050b:	75 67                	jne    800574 <serve+0xf6>
			process_timer(whom);
  80050d:	8b 5d e4             	mov    -0x1c(%ebp),%ebx

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800510:	3b 1d 3c 60 81 00    	cmp    0x81603c,%ebx
  800516:	74 12                	je     80052a <serve+0xac>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800518:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80051c:	c7 04 24 a0 19 81 00 	movl   $0x8119a0,(%esp)
  800523:	e8 50 ea 00 00       	call   80ef78 <cprintf>
  800528:	eb 39                	jmp    800563 <serve+0xe5>
		return;
	}

	start = sys_time_msec();
  80052a:	e8 4e f6 00 00       	call   80fb7d <sys_time_msec>
  80052f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800532:	e8 06 aa 00 00       	call   80af3d <thread_yield>
	now = sys_time_msec();
  800537:	e8 41 f6 00 00       	call   80fb7d <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  80053c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800543:	00 
  800544:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80054b:	00 

	start = sys_time_msec();
	thread_yield();
	now = sys_time_msec();

	to = TIMER_INTERVAL - (now - start);
  80054c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80054f:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800555:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  800557:	89 54 24 04          	mov    %edx,0x4(%esp)
  80055b:	89 1c 24             	mov    %ebx,(%esp)
  80055e:	e8 a9 fa 00 00       	call   81000c <ipc_send>
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
  800563:	89 f0                	mov    %esi,%eax
  800565:	e8 ca fa ff ff       	call   800034 <put_buffer>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80056a:	bb 00 00 00 00       	mov    $0x0,%ebx

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  80056f:	e9 23 ff ff ff       	jmp    800497 <serve+0x19>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800574:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800578:	75 1d                	jne    800597 <serve+0x119>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  80057a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80057d:	89 44 24 04          	mov    %eax,0x4(%esp)
  800581:	c7 04 24 dc 19 81 00 	movl   $0x8119dc,(%esp)
  800588:	e8 eb e9 00 00       	call   80ef78 <cprintf>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80058d:	bb 00 00 00 00       	mov    $0x0,%ebx
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
			cprintf("Invalid request from %08x: no argument page\n", whom);
			continue; // just leave it hanging...
  800592:	e9 00 ff ff ff       	jmp    800497 <serve+0x19>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  800597:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  80059e:	e8 8d 09 01 00       	call   810f30 <malloc>
		if (!args)
  8005a3:	85 c0                	test   %eax,%eax
  8005a5:	75 1c                	jne    8005c3 <serve+0x145>
			panic("could not allocate thread args structure");
  8005a7:	c7 44 24 08 0c 1a 81 	movl   $0x811a0c,0x8(%esp)
  8005ae:	00 
  8005af:	c7 44 24 04 27 01 00 	movl   $0x127,0x4(%esp)
  8005b6:	00 
  8005b7:	c7 04 24 44 1a 81 00 	movl   $0x811a44,(%esp)
  8005be:	e8 bd e8 00 00       	call   80ee80 <_panic>

		args->reqno = reqno;
  8005c3:	89 18                	mov    %ebx,(%eax)
		args->whom = whom;
  8005c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8005c8:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8005cb:	89 70 08             	mov    %esi,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8005ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005d2:	c7 44 24 08 48 00 80 	movl   $0x800048,0x8(%esp)
  8005d9:	00 
  8005da:	c7 44 24 04 9e 1a 81 	movl   $0x811a9e,0x4(%esp)
  8005e1:	00 
  8005e2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8005e9:	e8 03 a8 00 00       	call   80adf1 <thread_create>
		thread_yield(); // let the thread created run
  8005ee:	e8 4a a9 00 00       	call   80af3d <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8005f3:	bb 00 00 00 00       	mov    $0x0,%ebx
  8005f8:	e9 9a fe ff ff       	jmp    800497 <serve+0x19>

008005fd <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  8005fd:	55                   	push   %ebp
  8005fe:	89 e5                	mov    %esp,%ebp
  800600:	56                   	push   %esi
  800601:	53                   	push   %ebx
  800602:	83 ec 10             	sub    $0x10,%esp
	serve_init(inet_addr(IP),
  800605:	c7 04 24 ab 1a 81 00 	movl   $0x811aab,(%esp)
  80060c:	e8 96 78 00 00       	call   807ea7 <inet_addr>
  800611:	89 c3                	mov    %eax,%ebx
  800613:	c7 04 24 b4 1a 81 00 	movl   $0x811ab4,(%esp)
  80061a:	e8 88 78 00 00       	call   807ea7 <inet_addr>
  80061f:	89 c6                	mov    %eax,%esi
  800621:	c7 04 24 c2 1a 81 00 	movl   $0x811ac2,(%esp)
  800628:	e8 7a 78 00 00       	call   807ea7 <inet_addr>
  80062d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800631:	89 74 24 04          	mov    %esi,0x4(%esp)
  800635:	89 04 24             	mov    %eax,(%esp)
  800638:	e8 b2 fc ff ff       	call   8002ef <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  80063d:	e8 3c fe ff ff       	call   80047e <serve>

00800642 <umain>:
}

void
umain(int argc, char **argv)
{
  800642:	55                   	push   %ebp
  800643:	89 e5                	mov    %esp,%ebp
  800645:	53                   	push   %ebx
  800646:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  800649:	e8 89 f2 00 00       	call   80f8d7 <sys_getenvid>
  80064e:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800650:	c7 05 e8 52 81 00 91 	movl   $0x814491,0x8152e8
  800657:	44 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  80065a:	e8 58 f6 00 00       	call   80fcb7 <fork>
  80065f:	a3 3c 60 81 00       	mov    %eax,0x81603c
	if (timer_envid < 0)
  800664:	85 c0                	test   %eax,%eax
  800666:	79 1c                	jns    800684 <umain+0x42>
		panic("error forking");
  800668:	c7 44 24 08 cc 1a 81 	movl   $0x811acc,0x8(%esp)
  80066f:	00 
  800670:	c7 44 24 04 44 01 00 	movl   $0x144,0x4(%esp)
  800677:	00 
  800678:	c7 04 24 44 1a 81 00 	movl   $0x811a44,(%esp)
  80067f:	e8 fc e7 00 00       	call   80ee80 <_panic>
	else if (timer_envid == 0) {
  800684:	85 c0                	test   %eax,%eax
  800686:	75 15                	jne    80069d <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  800688:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80068f:	00 
  800690:	89 1c 24             	mov    %ebx,(%esp)
  800693:	e8 ac 00 00 00       	call   800744 <timer>
		return;
  800698:	e9 9e 00 00 00       	jmp    80073b <umain+0xf9>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  80069d:	e8 15 f6 00 00       	call   80fcb7 <fork>
  8006a2:	a3 40 60 81 00       	mov    %eax,0x816040
	if (input_envid < 0)
  8006a7:	85 c0                	test   %eax,%eax
  8006a9:	79 1c                	jns    8006c7 <umain+0x85>
		panic("error forking");
  8006ab:	c7 44 24 08 cc 1a 81 	movl   $0x811acc,0x8(%esp)
  8006b2:	00 
  8006b3:	c7 44 24 04 4e 01 00 	movl   $0x14e,0x4(%esp)
  8006ba:	00 
  8006bb:	c7 04 24 44 1a 81 00 	movl   $0x811a44,(%esp)
  8006c2:	e8 b9 e7 00 00       	call   80ee80 <_panic>
	else if (input_envid == 0) {
  8006c7:	85 c0                	test   %eax,%eax
  8006c9:	75 0a                	jne    8006d5 <umain+0x93>
		input(ns_envid);
  8006cb:	89 1c 24             	mov    %ebx,(%esp)
  8006ce:	e8 2d 01 00 00       	call   800800 <input>
		return;
  8006d3:	eb 66                	jmp    80073b <umain+0xf9>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8006d5:	e8 dd f5 00 00       	call   80fcb7 <fork>
  8006da:	a3 00 60 81 00       	mov    %eax,0x816000
	if (output_envid < 0)
  8006df:	85 c0                	test   %eax,%eax
  8006e1:	79 1c                	jns    8006ff <umain+0xbd>
		panic("error forking");
  8006e3:	c7 44 24 08 cc 1a 81 	movl   $0x811acc,0x8(%esp)
  8006ea:	00 
  8006eb:	c7 44 24 04 58 01 00 	movl   $0x158,0x4(%esp)
  8006f2:	00 
  8006f3:	c7 04 24 44 1a 81 00 	movl   $0x811a44,(%esp)
  8006fa:	e8 81 e7 00 00       	call   80ee80 <_panic>
	else if (output_envid == 0) {
  8006ff:	85 c0                	test   %eax,%eax
  800701:	75 0a                	jne    80070d <umain+0xcb>
		output(ns_envid);
  800703:	89 1c 24             	mov    %ebx,(%esp)
  800706:	e8 b9 01 00 00       	call   8008c4 <output>
		return;
  80070b:	eb 2e                	jmp    80073b <umain+0xf9>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  80070d:	e8 46 a6 00 00       	call   80ad58 <thread_init>
	thread_create(0, "main", tmain, 0);
  800712:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800719:	00 
  80071a:	c7 44 24 08 fd 05 80 	movl   $0x8005fd,0x8(%esp)
  800721:	00 
  800722:	c7 44 24 04 da 1a 81 	movl   $0x811ada,0x4(%esp)
  800729:	00 
  80072a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800731:	e8 bb a6 00 00       	call   80adf1 <thread_create>
	thread_yield();
  800736:	e8 02 a8 00 00       	call   80af3d <thread_yield>
	// never coming here!
}
  80073b:	83 c4 14             	add    $0x14,%esp
  80073e:	5b                   	pop    %ebx
  80073f:	5d                   	pop    %ebp
  800740:	c3                   	ret    
  800741:	00 00                	add    %al,(%eax)
	...

00800744 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800744:	55                   	push   %ebp
  800745:	89 e5                	mov    %esp,%ebp
  800747:	57                   	push   %edi
  800748:	56                   	push   %esi
  800749:	53                   	push   %ebx
  80074a:	83 ec 2c             	sub    $0x2c,%esp
  80074d:	8b 7d 08             	mov    0x8(%ebp),%edi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800750:	e8 28 f4 00 00       	call   80fb7d <sys_time_msec>
  800755:	89 c3                	mov    %eax,%ebx
  800757:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  80075a:	c7 05 e8 52 81 00 0c 	movl   $0x811b0c,0x8152e8
  800761:	1b 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800764:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  800767:	eb 05                	jmp    80076e <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  800769:	e8 88 f1 00 00       	call   80f8f6 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  80076e:	e8 0a f4 00 00       	call   80fb7d <sys_time_msec>
  800773:	39 c3                	cmp    %eax,%ebx
  800775:	76 06                	jbe    80077d <timer+0x39>
  800777:	85 c0                	test   %eax,%eax
  800779:	79 ee                	jns    800769 <timer+0x25>
  80077b:	eb 04                	jmp    800781 <timer+0x3d>
			sys_yield();
		}
		if (r < 0)
  80077d:	85 c0                	test   %eax,%eax
  80077f:	79 20                	jns    8007a1 <timer+0x5d>
			panic("sys_time_msec: %e", r);
  800781:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800785:	c7 44 24 08 15 1b 81 	movl   $0x811b15,0x8(%esp)
  80078c:	00 
  80078d:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  800794:	00 
  800795:	c7 04 24 27 1b 81 00 	movl   $0x811b27,(%esp)
  80079c:	e8 df e6 00 00       	call   80ee80 <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007a1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007a8:	00 
  8007a9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007b0:	00 
  8007b1:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007b8:	00 
  8007b9:	89 3c 24             	mov    %edi,(%esp)
  8007bc:	e8 4b f8 00 00       	call   81000c <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007c1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007c8:	00 
  8007c9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8007d0:	00 
  8007d1:	89 34 24             	mov    %esi,(%esp)
  8007d4:	e8 c3 f7 00 00       	call   80ff9c <ipc_recv>
  8007d9:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8007db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8007de:	39 c7                	cmp    %eax,%edi
  8007e0:	74 12                	je     8007f4 <timer+0xb0>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8007e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8007e6:	c7 04 24 34 1b 81 00 	movl   $0x811b34,(%esp)
  8007ed:	e8 86 e7 00 00       	call   80ef78 <cprintf>
				continue;
			}

			stop = sys_time_msec() + to;
			break;
		}
  8007f2:	eb cd                	jmp    8007c1 <timer+0x7d>
			if (whom != ns_envid) {
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8007f4:	e8 84 f3 00 00       	call   80fb7d <sys_time_msec>
  8007f9:	01 c3                	add    %eax,%ebx
			break;
		}
	}
  8007fb:	e9 6e ff ff ff       	jmp    80076e <timer+0x2a>

00800800 <input>:

#define INPUT_COUNT 10

void
input(envid_t ns_envid)
{
  800800:	55                   	push   %ebp
  800801:	89 e5                	mov    %esp,%ebp
  800803:	56                   	push   %esi
  800804:	53                   	push   %ebx
  800805:	83 ec 10             	sub    $0x10,%esp
  800808:	8b 75 08             	mov    0x8(%ebp),%esi
	binaryname = "ns_input";
  80080b:	c7 05 e8 52 81 00 6f 	movl   $0x811b6f,0x8152e8
  800812:	1b 81 00 
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
	struct jif_pkt *pkt = (struct jif_pkt *)REQVA;
	int r;
	if ((r = sys_page_alloc(0, pkt, PTE_P | PTE_U | PTE_W)) < 0)
  800815:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80081c:	00 
  80081d:	c7 44 24 04 00 b0 fe 	movl   $0xffeb000,0x4(%esp)
  800824:	0f 
  800825:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80082c:	e8 e4 f0 00 00       	call   80f915 <sys_page_alloc>
  800831:	85 c0                	test   %eax,%eax
  800833:	79 20                	jns    800855 <input+0x55>
			panic("sys_page_alloc: %e", r);
  800835:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800839:	c7 44 24 08 78 1b 81 	movl   $0x811b78,0x8(%esp)
  800840:	00 
  800841:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  800848:	00 
  800849:	c7 04 24 8b 1b 81 00 	movl   $0x811b8b,(%esp)
  800850:	e8 2b e6 00 00       	call   80ee80 <_panic>
	uint32_t len;
		
	while (1)
	{
		// cprintf("input hello world\n");
		if ((r = sys_e1000_receive(pkt->jp_data, (uint32_t *)&pkt->jp_len)) < 0)
  800855:	c7 44 24 04 00 b0 fe 	movl   $0xffeb000,0x4(%esp)
  80085c:	0f 
  80085d:	c7 04 24 04 b0 fe 0f 	movl   $0xffeb004,(%esp)
  800864:	e8 54 f3 00 00       	call   80fbbd <sys_e1000_receive>
  800869:	85 c0                	test   %eax,%eax
  80086b:	78 e8                	js     800855 <input+0x55>
		{
			continue;
		}
		memcpy(nsipcbuf.pkt.jp_data,pkt->jp_data,pkt->jp_len);
  80086d:	a1 00 b0 fe 0f       	mov    0xffeb000,%eax
  800872:	89 44 24 08          	mov    %eax,0x8(%esp)
  800876:	c7 44 24 04 04 b0 fe 	movl   $0xffeb004,0x4(%esp)
  80087d:	0f 
  80087e:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  800885:	e8 7c ee 00 00       	call   80f706 <memcpy>
		nsipcbuf.pkt.jp_len = pkt->jp_len;
  80088a:	a1 00 b0 fe 0f       	mov    0xffeb000,%eax
  80088f:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
		ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P | PTE_W | PTE_U);
  800894:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80089b:	00 
  80089c:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  8008a3:	00 
  8008a4:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  8008ab:	00 
  8008ac:	89 34 24             	mov    %esi,(%esp)
  8008af:	e8 58 f7 00 00       	call   81000c <ipc_send>
  8008b4:	bb 14 00 00 00       	mov    $0x14,%ebx
		
		for (int i = 0; i < INPUT_COUNT*2; i++)
			sys_yield();
  8008b9:	e8 38 f0 00 00       	call   80f8f6 <sys_yield>
		}
		memcpy(nsipcbuf.pkt.jp_data,pkt->jp_data,pkt->jp_len);
		nsipcbuf.pkt.jp_len = pkt->jp_len;
		ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P | PTE_W | PTE_U);
		
		for (int i = 0; i < INPUT_COUNT*2; i++)
  8008be:	4b                   	dec    %ebx
  8008bf:	75 f8                	jne    8008b9 <input+0xb9>
  8008c1:	eb 92                	jmp    800855 <input+0x55>
	...

008008c4 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8008c4:	55                   	push   %ebp
  8008c5:	89 e5                	mov    %esp,%ebp
  8008c7:	83 ec 18             	sub    $0x18,%esp
	binaryname = "ns_output";
  8008ca:	c7 05 e8 52 81 00 97 	movl   $0x811b97,0x8152e8
  8008d1:	1b 81 00 
	struct jif_pkt *pkt = &(nsipcbuf.pkt); //= (struct jif_pkt *)(REQVA + PGSIZE);
	int r;

	while (1)
	{
		if ((r = ipc_recv(&ns_envid, pkt, 0)) < 0)
  8008d4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8008db:	00 
  8008dc:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  8008e3:	00 
  8008e4:	8d 45 08             	lea    0x8(%ebp),%eax
  8008e7:	89 04 24             	mov    %eax,(%esp)
  8008ea:	e8 ad f6 00 00       	call   80ff9c <ipc_recv>
  8008ef:	85 c0                	test   %eax,%eax
  8008f1:	79 0e                	jns    800901 <output+0x3d>
		{
			cprintf("output ipc_recv error\n");
  8008f3:	c7 04 24 a1 1b 81 00 	movl   $0x811ba1,(%esp)
  8008fa:	e8 79 e6 00 00       	call   80ef78 <cprintf>
			continue;
  8008ff:	eb d3                	jmp    8008d4 <output+0x10>
		}
		while(1){		
			if ((r = sys_e1000_transmit(pkt->jp_data, pkt->jp_len)) < 0)
  800901:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
  800906:	89 44 24 04          	mov    %eax,0x4(%esp)
  80090a:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  800911:	e8 86 f2 00 00       	call   80fb9c <sys_e1000_transmit>
  800916:	85 c0                	test   %eax,%eax
  800918:	79 ba                	jns    8008d4 <output+0x10>
			{
				if (r != -E_NET_NO_DES)
  80091a:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80091d:	74 0e                	je     80092d <output+0x69>
				{
					cprintf("output sys_e1000_transmit error\n");
  80091f:	c7 04 24 d8 1b 81 00 	movl   $0x811bd8,(%esp)
  800926:	e8 4d e6 00 00       	call   80ef78 <cprintf>
  80092b:	eb d4                	jmp    800901 <output+0x3d>
				}
				else
				{
					cprintf("output packet overflow yield\n");
  80092d:	c7 04 24 b8 1b 81 00 	movl   $0x811bb8,(%esp)
  800934:	e8 3f e6 00 00       	call   80ef78 <cprintf>
					sys_yield();
  800939:	e8 b8 ef 00 00       	call   80f8f6 <sys_yield>
  80093e:	eb c1                	jmp    800901 <output+0x3d>

00800940 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800940:	55                   	push   %ebp
  800941:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800943:	83 f8 1f             	cmp    $0x1f,%eax
  800946:	76 11                	jbe    800959 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  800948:	c7 05 20 c2 b3 00 09 	movl   $0x9,0xb3c220
  80094f:	00 00 00 
    return NULL;
  800952:	b8 00 00 00 00       	mov    $0x0,%eax
  800957:	eb 24                	jmp    80097d <get_socket+0x3d>
  }

  sock = &sockets[s];
  800959:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80095c:	c1 e2 02             	shl    $0x2,%edx
  80095f:	8d 82 80 60 81 00    	lea    0x816080(%edx),%eax

  if (!sock->conn) {
  800965:	83 ba 80 60 81 00 00 	cmpl   $0x0,0x816080(%edx)
  80096c:	75 0f                	jne    80097d <get_socket+0x3d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  80096e:	c7 05 20 c2 b3 00 09 	movl   $0x9,0xb3c220
  800975:	00 00 00 
    return NULL;
  800978:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  return sock;
}
  80097d:	5d                   	pop    %ebp
  80097e:	c3                   	ret    

0080097f <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  80097f:	55                   	push   %ebp
  800980:	89 e5                	mov    %esp,%ebp
  800982:	53                   	push   %ebx
  800983:	83 ec 14             	sub    $0x14,%esp
  800986:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800989:	85 c0                	test   %eax,%eax
  80098b:	75 1c                	jne    8009a9 <lwip_setsockopt_internal+0x2a>
  80098d:	c7 44 24 08 f9 1b 81 	movl   $0x811bf9,0x8(%esp)
  800994:	00 
  800995:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  80099c:	00 
  80099d:	c7 04 24 05 1c 81 00 	movl   $0x811c05,(%esp)
  8009a4:	e8 d7 e4 00 00       	call   80ee80 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  8009a9:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  8009ab:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  8009ae:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  8009b1:	8b 40 08             	mov    0x8(%eax),%eax
  8009b4:	83 f8 06             	cmp    $0x6,%eax
  8009b7:	0f 84 80 00 00 00    	je     800a3d <lwip_setsockopt_internal+0xbe>
  8009bd:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  8009c2:	74 09                	je     8009cd <lwip_setsockopt_internal+0x4e>
  8009c4:	85 c0                	test   %eax,%eax
  8009c6:	74 53                	je     800a1b <lwip_setsockopt_internal+0x9c>
  8009c8:	e9 a4 00 00 00       	jmp    800a71 <lwip_setsockopt_internal+0xf2>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8009cd:	83 f9 20             	cmp    $0x20,%ecx
  8009d0:	74 11                	je     8009e3 <lwip_setsockopt_internal+0x64>
  8009d2:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  8009d8:	74 26                	je     800a00 <lwip_setsockopt_internal+0x81>
  8009da:	83 f9 08             	cmp    $0x8,%ecx
  8009dd:	0f 85 8e 00 00 00    	jne    800a71 <lwip_setsockopt_internal+0xf2>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  8009e3:	83 3b 00             	cmpl   $0x0,(%ebx)
  8009e6:	74 0b                	je     8009f3 <lwip_setsockopt_internal+0x74>
        sock->conn->pcb.ip->so_options |= optname;
  8009e8:	8b 02                	mov    (%edx),%eax
  8009ea:	8b 40 08             	mov    0x8(%eax),%eax
  8009ed:	66 09 48 08          	or     %cx,0x8(%eax)
  8009f1:	eb 7e                	jmp    800a71 <lwip_setsockopt_internal+0xf2>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  8009f3:	8b 02                	mov    (%edx),%eax
  8009f5:	8b 40 08             	mov    0x8(%eax),%eax
  8009f8:	f7 d1                	not    %ecx
  8009fa:	66 21 48 08          	and    %cx,0x8(%eax)
  8009fe:	eb 71                	jmp    800a71 <lwip_setsockopt_internal+0xf2>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800a00:	83 3b 00             	cmpl   $0x0,(%ebx)
  800a03:	74 0b                	je     800a10 <lwip_setsockopt_internal+0x91>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800a05:	8b 02                	mov    (%edx),%eax
  800a07:	8b 40 08             	mov    0x8(%eax),%eax
  800a0a:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800a0e:	eb 61                	jmp    800a71 <lwip_setsockopt_internal+0xf2>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800a10:	8b 02                	mov    (%edx),%eax
  800a12:	8b 40 08             	mov    0x8(%eax),%eax
  800a15:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800a19:	eb 56                	jmp    800a71 <lwip_setsockopt_internal+0xf2>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800a1b:	83 f9 01             	cmp    $0x1,%ecx
  800a1e:	74 11                	je     800a31 <lwip_setsockopt_internal+0xb2>
  800a20:	83 f9 02             	cmp    $0x2,%ecx
  800a23:	75 4c                	jne    800a71 <lwip_setsockopt_internal+0xf2>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800a25:	8b 02                	mov    (%edx),%eax
  800a27:	8b 40 08             	mov    0x8(%eax),%eax
  800a2a:	8b 0b                	mov    (%ebx),%ecx
  800a2c:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  800a2f:	eb 40                	jmp    800a71 <lwip_setsockopt_internal+0xf2>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800a31:	8b 02                	mov    (%edx),%eax
  800a33:	8b 40 08             	mov    0x8(%eax),%eax
  800a36:	8b 0b                	mov    (%ebx),%ecx
  800a38:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  800a3b:	eb 34                	jmp    800a71 <lwip_setsockopt_internal+0xf2>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800a3d:	83 f9 01             	cmp    $0x1,%ecx
  800a40:	74 07                	je     800a49 <lwip_setsockopt_internal+0xca>
  800a42:	83 f9 02             	cmp    $0x2,%ecx
  800a45:	75 2a                	jne    800a71 <lwip_setsockopt_internal+0xf2>
  800a47:	eb 1b                	jmp    800a64 <lwip_setsockopt_internal+0xe5>
    case TCP_NODELAY:
      if (*(int*)optval) {
  800a49:	83 3b 00             	cmpl   $0x0,(%ebx)
  800a4c:	74 0b                	je     800a59 <lwip_setsockopt_internal+0xda>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800a4e:	8b 02                	mov    (%edx),%eax
  800a50:	8b 40 08             	mov    0x8(%eax),%eax
  800a53:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800a57:	eb 18                	jmp    800a71 <lwip_setsockopt_internal+0xf2>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800a59:	8b 02                	mov    (%edx),%eax
  800a5b:	8b 40 08             	mov    0x8(%eax),%eax
  800a5e:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800a62:	eb 0d                	jmp    800a71 <lwip_setsockopt_internal+0xf2>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800a64:	8b 02                	mov    (%edx),%eax
  800a66:	8b 40 08             	mov    0x8(%eax),%eax
  800a69:	8b 0b                	mov    (%ebx),%ecx
  800a6b:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800a71:	8b 02                	mov    (%edx),%eax
  800a73:	8b 40 10             	mov    0x10(%eax),%eax
  800a76:	89 04 24             	mov    %eax,(%esp)
  800a79:	e8 43 9d 00 00       	call   80a7c1 <sys_sem_signal>
}
  800a7e:	83 c4 14             	add    $0x14,%esp
  800a81:	5b                   	pop    %ebx
  800a82:	5d                   	pop    %ebp
  800a83:	c3                   	ret    

00800a84 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800a84:	55                   	push   %ebp
  800a85:	89 e5                	mov    %esp,%ebp
  800a87:	53                   	push   %ebx
  800a88:	83 ec 14             	sub    $0x14,%esp
  800a8b:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800a8e:	85 c0                	test   %eax,%eax
  800a90:	75 1c                	jne    800aae <lwip_getsockopt_internal+0x2a>
  800a92:	c7 44 24 08 f9 1b 81 	movl   $0x811bf9,0x8(%esp)
  800a99:	00 
  800a9a:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  800aa1:	00 
  800aa2:	c7 04 24 05 1c 81 00 	movl   $0x811c05,(%esp)
  800aa9:	e8 d2 e3 00 00       	call   80ee80 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800aae:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800ab0:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800ab3:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800ab6:	8b 40 08             	mov    0x8(%eax),%eax
  800ab9:	83 f8 06             	cmp    $0x6,%eax
  800abc:	0f 84 11 01 00 00    	je     800bd3 <lwip_getsockopt_internal+0x14f>
  800ac2:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800ac7:	74 0d                	je     800ad6 <lwip_getsockopt_internal+0x52>
  800ac9:	85 c0                	test   %eax,%eax
  800acb:	0f 84 de 00 00 00    	je     800baf <lwip_getsockopt_internal+0x12b>
  800ad1:	e9 26 01 00 00       	jmp    800bfc <lwip_getsockopt_internal+0x178>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800ad6:	83 f9 20             	cmp    $0x20,%ecx
  800ad9:	74 37                	je     800b12 <lwip_getsockopt_internal+0x8e>
  800adb:	83 f9 20             	cmp    $0x20,%ecx
  800ade:	7f 10                	jg     800af0 <lwip_getsockopt_internal+0x6c>
  800ae0:	83 f9 02             	cmp    $0x2,%ecx
  800ae3:	74 2d                	je     800b12 <lwip_getsockopt_internal+0x8e>
  800ae5:	83 f9 08             	cmp    $0x8,%ecx
  800ae8:	0f 85 0e 01 00 00    	jne    800bfc <lwip_getsockopt_internal+0x178>
  800aee:	eb 22                	jmp    800b12 <lwip_getsockopt_internal+0x8e>
  800af0:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  800af6:	74 2c                	je     800b24 <lwip_getsockopt_internal+0xa0>
  800af8:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800afe:	0f 84 9b 00 00 00    	je     800b9f <lwip_getsockopt_internal+0x11b>
  800b04:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  800b0a:	0f 85 ec 00 00 00    	jne    800bfc <lwip_getsockopt_internal+0x178>
  800b10:	eb 56                	jmp    800b68 <lwip_getsockopt_internal+0xe4>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800b12:	8b 02                	mov    (%edx),%eax
  800b14:	8b 40 08             	mov    0x8(%eax),%eax
  800b17:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800b1b:	21 c1                	and    %eax,%ecx
  800b1d:	89 0b                	mov    %ecx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800b1f:	e9 d8 00 00 00       	jmp    800bfc <lwip_getsockopt_internal+0x178>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800b24:	8b 02                	mov    (%edx),%eax
  800b26:	8b 08                	mov    (%eax),%ecx
  800b28:	89 c8                	mov    %ecx,%eax
  800b2a:	25 f0 00 00 00       	and    $0xf0,%eax
  800b2f:	83 f8 20             	cmp    $0x20,%eax
  800b32:	74 22                	je     800b56 <lwip_getsockopt_internal+0xd2>
  800b34:	83 f8 40             	cmp    $0x40,%eax
  800b37:	74 07                	je     800b40 <lwip_getsockopt_internal+0xbc>
  800b39:	83 f8 10             	cmp    $0x10,%eax
  800b3c:	75 23                	jne    800b61 <lwip_getsockopt_internal+0xdd>
  800b3e:	eb 0b                	jmp    800b4b <lwip_getsockopt_internal+0xc7>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  800b40:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800b46:	e9 b1 00 00 00       	jmp    800bfc <lwip_getsockopt_internal+0x178>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  800b4b:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
        break;
  800b51:	e9 a6 00 00 00       	jmp    800bfc <lwip_getsockopt_internal+0x178>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  800b56:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800b5c:	e9 9b 00 00 00       	jmp    800bfc <lwip_getsockopt_internal+0x178>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  800b61:	89 0b                	mov    %ecx,(%ebx)
  800b63:	e9 94 00 00 00       	jmp    800bfc <lwip_getsockopt_internal+0x178>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  800b68:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  800b6c:	75 23                	jne    800b91 <lwip_getsockopt_internal+0x10d>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800b6e:	8b 02                	mov    (%edx),%eax
  800b70:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800b74:	f7 d8                	neg    %eax
  800b76:	83 f8 0e             	cmp    $0xe,%eax
  800b79:	77 09                	ja     800b84 <lwip_getsockopt_internal+0x100>
  800b7b:	8b 04 85 c0 1c 81 00 	mov    0x811cc0(,%eax,4),%eax
  800b82:	eb 05                	jmp    800b89 <lwip_getsockopt_internal+0x105>
  800b84:	b8 05 00 00 00       	mov    $0x5,%eax
  800b89:	89 42 10             	mov    %eax,0x10(%edx)
  800b8c:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
      } 
      *(int *)optval = sock->err;
  800b91:	8b 42 10             	mov    0x10(%edx),%eax
  800b94:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800b96:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  800b9d:	eb 5d                	jmp    800bfc <lwip_getsockopt_internal+0x178>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800b9f:	8b 02                	mov    (%edx),%eax
  800ba1:	8b 40 08             	mov    0x8(%eax),%eax
  800ba4:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800ba8:	83 e0 01             	and    $0x1,%eax
  800bab:	89 03                	mov    %eax,(%ebx)
      break;
  800bad:	eb 4d                	jmp    800bfc <lwip_getsockopt_internal+0x178>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800baf:	83 f9 01             	cmp    $0x1,%ecx
  800bb2:	74 12                	je     800bc6 <lwip_getsockopt_internal+0x142>
  800bb4:	83 f9 02             	cmp    $0x2,%ecx
  800bb7:	75 43                	jne    800bfc <lwip_getsockopt_internal+0x178>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800bb9:	8b 02                	mov    (%edx),%eax
  800bbb:	8b 40 08             	mov    0x8(%eax),%eax
  800bbe:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800bc2:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  800bc4:	eb 36                	jmp    800bfc <lwip_getsockopt_internal+0x178>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  800bc6:	8b 02                	mov    (%edx),%eax
  800bc8:	8b 40 08             	mov    0x8(%eax),%eax
  800bcb:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800bcf:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  800bd1:	eb 29                	jmp    800bfc <lwip_getsockopt_internal+0x178>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800bd3:	83 f9 01             	cmp    $0x1,%ecx
  800bd6:	74 07                	je     800bdf <lwip_getsockopt_internal+0x15b>
  800bd8:	83 f9 02             	cmp    $0x2,%ecx
  800bdb:	75 1f                	jne    800bfc <lwip_getsockopt_internal+0x178>
  800bdd:	eb 10                	jmp    800bef <lwip_getsockopt_internal+0x16b>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800bdf:	8b 02                	mov    (%edx),%eax
  800be1:	8b 40 08             	mov    0x8(%eax),%eax
  800be4:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800be8:	83 e0 40             	and    $0x40,%eax
  800beb:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  800bed:	eb 0d                	jmp    800bfc <lwip_getsockopt_internal+0x178>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800bef:	8b 02                	mov    (%edx),%eax
  800bf1:	8b 40 08             	mov    0x8(%eax),%eax
  800bf4:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800bfa:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800bfc:	8b 02                	mov    (%edx),%eax
  800bfe:	8b 40 10             	mov    0x10(%eax),%eax
  800c01:	89 04 24             	mov    %eax,(%esp)
  800c04:	e8 b8 9b 00 00       	call   80a7c1 <sys_sem_signal>
}
  800c09:	83 c4 14             	add    $0x14,%esp
  800c0c:	5b                   	pop    %ebx
  800c0d:	5d                   	pop    %ebp
  800c0e:	c3                   	ret    

00800c0f <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  800c0f:	55                   	push   %ebp
  800c10:	89 e5                	mov    %esp,%ebp
  800c12:	57                   	push   %edi
  800c13:	56                   	push   %esi
  800c14:	53                   	push   %ebx
  800c15:	83 ec 4c             	sub    $0x4c,%esp
  800c18:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800c1b:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800c1e:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800c21:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800c28:	00 
  800c29:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800c30:	00 
  800c31:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800c34:	89 04 24             	mov    %eax,(%esp)
  800c37:	e8 16 ea 00 00       	call   80f652 <memset>
  FD_ZERO(&lwriteset);
  800c3c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800c43:	00 
  800c44:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800c4b:	00 
  800c4c:	8d 45 e0             	lea    -0x20(%ebp),%eax
  800c4f:	89 04 24             	mov    %eax,(%esp)
  800c52:	e8 fb e9 00 00       	call   80f652 <memset>
  FD_ZERO(&lexceptset);
  800c57:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800c5e:	00 
  800c5f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800c66:	00 
  800c67:	8d 45 dc             	lea    -0x24(%ebp),%eax
  800c6a:	89 04 24             	mov    %eax,(%esp)
  800c6d:	e8 e0 e9 00 00       	call   80f652 <memset>
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  800c72:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800c79:	bb 00 00 00 00       	mov    $0x0,%ebx
  800c7e:	e9 80 00 00 00       	jmp    800d03 <lwip_selscan+0xf4>
    if (FD_ISSET(i, readset)) {
  800c83:	89 de                	mov    %ebx,%esi
  800c85:	85 db                	test   %ebx,%ebx
  800c87:	79 03                	jns    800c8c <lwip_selscan+0x7d>
  800c89:	8d 73 07             	lea    0x7(%ebx),%esi
  800c8c:	c1 fe 03             	sar    $0x3,%esi
  800c8f:	89 f7                	mov    %esi,%edi
  800c91:	89 d9                	mov    %ebx,%ecx
  800c93:	83 e1 07             	and    $0x7,%ecx
  800c96:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  800c99:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800c9c:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  800ca0:	d3 f8                	sar    %cl,%eax
  800ca2:	a8 01                	test   $0x1,%al
  800ca4:	74 29                	je     800ccf <lwip_selscan+0xc0>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  800ca6:	89 d8                	mov    %ebx,%eax
  800ca8:	e8 93 fc ff ff       	call   800940 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  800cad:	85 c0                	test   %eax,%eax
  800caf:	74 1e                	je     800ccf <lwip_selscan+0xc0>
  800cb1:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  800cb5:	75 07                	jne    800cbe <lwip_selscan+0xaf>
  800cb7:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800cbc:	74 11                	je     800ccf <lwip_selscan+0xc0>
        FD_SET(i, &lreadset);
  800cbe:	b8 01 00 00 00       	mov    $0x1,%eax
  800cc3:	8a 4d d4             	mov    -0x2c(%ebp),%cl
  800cc6:	d3 e0                	shl    %cl,%eax
  800cc8:	08 44 3d e4          	or     %al,-0x1c(%ebp,%edi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  800ccc:	ff 45 c4             	incl   -0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  800ccf:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800cd2:	0f b6 04 31          	movzbl (%ecx,%esi,1),%eax
  800cd6:	8a 4d d4             	mov    -0x2c(%ebp),%cl
  800cd9:	d3 f8                	sar    %cl,%eax
  800cdb:	a8 01                	test   $0x1,%al
  800cdd:	74 23                	je     800d02 <lwip_selscan+0xf3>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800cdf:	89 d8                	mov    %ebx,%eax
  800ce1:	e8 5a fc ff ff       	call   800940 <get_socket>
      if (p_sock && p_sock->sendevent) {
  800ce6:	85 c0                	test   %eax,%eax
  800ce8:	74 18                	je     800d02 <lwip_selscan+0xf3>
  800cea:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800cef:	74 11                	je     800d02 <lwip_selscan+0xf3>
        FD_SET(i, &lwriteset);
  800cf1:	b8 01 00 00 00       	mov    $0x1,%eax
  800cf6:	8a 4d d4             	mov    -0x2c(%ebp),%cl
  800cf9:	d3 e0                	shl    %cl,%eax
  800cfb:	08 44 3d e0          	or     %al,-0x20(%ebp,%edi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800cff:	ff 45 c4             	incl   -0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800d02:	43                   	inc    %ebx
  800d03:	3b 5d d0             	cmp    -0x30(%ebp),%ebx
  800d06:	0f 8c 77 ff ff ff    	jl     800c83 <lwip_selscan+0x74>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  800d0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800d0f:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800d12:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800d14:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800d17:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800d1a:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800d1c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800d23:	00 
  800d24:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800d2b:	00 
  800d2c:	8b 45 08             	mov    0x8(%ebp),%eax
  800d2f:	89 04 24             	mov    %eax,(%esp)
  800d32:	e8 1b e9 00 00       	call   80f652 <memset>
  
  return nready;
}
  800d37:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800d3a:	83 c4 4c             	add    $0x4c,%esp
  800d3d:	5b                   	pop    %ebx
  800d3e:	5e                   	pop    %esi
  800d3f:	5f                   	pop    %edi
  800d40:	5d                   	pop    %ebp
  800d41:	c3                   	ret    

00800d42 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800d42:	55                   	push   %ebp
  800d43:	89 e5                	mov    %esp,%ebp
  800d45:	57                   	push   %edi
  800d46:	56                   	push   %esi
  800d47:	53                   	push   %ebx
  800d48:	83 ec 4c             	sub    $0x4c,%esp
  800d4b:	89 d7                	mov    %edx,%edi
  800d4d:	89 ce                	mov    %ecx,%esi
  800d4f:	8a 55 08             	mov    0x8(%ebp),%dl
  800d52:	88 55 c7             	mov    %dl,-0x39(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800d55:	e8 e6 fb ff ff       	call   800940 <get_socket>
  800d5a:	89 c3                	mov    %eax,%ebx
  if (!sock)
  800d5c:	85 c0                	test   %eax,%eax
  800d5e:	0f 84 91 00 00 00    	je     800df5 <lwip_getaddrname+0xb3>
    return -1;

  memset(&sin, 0, sizeof(sin));
  800d64:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  800d6b:	00 
  800d6c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800d73:	00 
  800d74:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800d77:	89 04 24             	mov    %eax,(%esp)
  800d7a:	e8 d3 e8 00 00       	call   80f652 <memset>
  sin.sin_len = sizeof(sin);
  800d7f:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800d83:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800d87:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  800d8b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800d8f:	8d 45 da             	lea    -0x26(%ebp),%eax
  800d92:	89 44 24 08          	mov    %eax,0x8(%esp)
  800d96:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800d99:	89 44 24 04          	mov    %eax,0x4(%esp)
  800d9d:	8b 03                	mov    (%ebx),%eax
  800d9f:	89 04 24             	mov    %eax,(%esp)
  800da2:	e8 04 a8 00 00       	call   80b5ab <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  800da7:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800dab:	89 04 24             	mov    %eax,(%esp)
  800dae:	e8 a6 6e 00 00       	call   807c59 <htons>
  800db3:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800db7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800dba:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  800dbd:	83 3e 10             	cmpl   $0x10,(%esi)
  800dc0:	76 06                	jbe    800dc8 <lwip_getaddrname+0x86>
    *namelen = sizeof(sin);
  800dc2:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  800dc8:	8b 06                	mov    (%esi),%eax
  800dca:	89 44 24 08          	mov    %eax,0x8(%esp)
  800dce:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800dd1:	89 44 24 04          	mov    %eax,0x4(%esp)
  800dd5:	89 3c 24             	mov    %edi,(%esp)
  800dd8:	e8 29 e9 00 00       	call   80f706 <memcpy>
  sock_set_errno(sock, 0);
  800ddd:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  800de4:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  800deb:	00 00 00 
  return 0;
  800dee:	b8 00 00 00 00       	mov    $0x0,%eax
  800df3:	eb 05                	jmp    800dfa <lwip_getaddrname+0xb8>
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
    return -1;
  800df5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    *namelen = sizeof(sin);

  SMEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
  800dfa:	83 c4 4c             	add    $0x4c,%esp
  800dfd:	5b                   	pop    %ebx
  800dfe:	5e                   	pop    %esi
  800dff:	5f                   	pop    %edi
  800e00:	5d                   	pop    %ebp
  800e01:	c3                   	ret    

00800e02 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  800e02:	55                   	push   %ebp
  800e03:	89 e5                	mov    %esp,%ebp
  800e05:	56                   	push   %esi
  800e06:	53                   	push   %ebx
  800e07:	83 ec 10             	sub    $0x10,%esp
  800e0a:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  800e0c:	a1 60 60 81 00       	mov    0x816060,%eax
  800e11:	89 04 24             	mov    %eax,(%esp)
  800e14:	e8 53 48 00 00       	call   80566c <sys_sem_wait>
  800e19:	b8 80 60 81 00       	mov    $0x816080,%eax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800e1e:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800e23:	83 38 00             	cmpl   $0x0,(%eax)
  800e26:	75 5d                	jne    800e85 <alloc_socket+0x83>
      sockets[i].conn       = newconn;
  800e28:	8d 14 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edx
  800e2f:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
  800e32:	c1 e1 02             	shl    $0x2,%ecx
  800e35:	89 b1 80 60 81 00    	mov    %esi,0x816080(%ecx)
      sockets[i].lastdata   = NULL;
  800e3b:	c7 81 84 60 81 00 00 	movl   $0x0,0x816084(%ecx)
  800e42:	00 00 00 
      sockets[i].lastoffset = 0;
  800e45:	66 c7 81 88 60 81 00 	movw   $0x0,0x816088(%ecx)
  800e4c:	00 00 
      sockets[i].rcvevent   = 0;
  800e4e:	66 c7 81 8a 60 81 00 	movw   $0x0,0x81608a(%ecx)
  800e55:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800e57:	66 c7 81 8c 60 81 00 	movw   $0x1,0x81608c(%ecx)
  800e5e:	01 00 
      sockets[i].flags      = 0;
  800e60:	66 c7 81 8e 60 81 00 	movw   $0x0,0x81608e(%ecx)
  800e67:	00 00 
      sockets[i].err        = 0;
  800e69:	01 da                	add    %ebx,%edx
  800e6b:	c7 04 95 90 60 81 00 	movl   $0x0,0x816090(,%edx,4)
  800e72:	00 00 00 00 
      sys_sem_signal(socksem);
  800e76:	a1 60 60 81 00       	mov    0x816060,%eax
  800e7b:	89 04 24             	mov    %eax,(%esp)
  800e7e:	e8 3e 99 00 00       	call   80a7c1 <sys_sem_signal>
      return i;
  800e83:	eb 1b                	jmp    800ea0 <alloc_socket+0x9e>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800e85:	43                   	inc    %ebx
  800e86:	83 c0 14             	add    $0x14,%eax
  800e89:	83 fb 20             	cmp    $0x20,%ebx
  800e8c:	75 95                	jne    800e23 <alloc_socket+0x21>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  800e8e:	a1 60 60 81 00       	mov    0x816060,%eax
  800e93:	89 04 24             	mov    %eax,(%esp)
  800e96:	e8 26 99 00 00       	call   80a7c1 <sys_sem_signal>
  return -1;
  800e9b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
  800ea0:	89 d8                	mov    %ebx,%eax
  800ea2:	83 c4 10             	add    $0x10,%esp
  800ea5:	5b                   	pop    %ebx
  800ea6:	5e                   	pop    %esi
  800ea7:	5d                   	pop    %ebp
  800ea8:	c3                   	ret    

00800ea9 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  800ea9:	55                   	push   %ebp
  800eaa:	89 e5                	mov    %esp,%ebp
  800eac:	57                   	push   %edi
  800ead:	56                   	push   %esi
  800eae:	53                   	push   %ebx
  800eaf:	83 ec 2c             	sub    $0x2c,%esp
  800eb2:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  800eb5:	85 f6                	test   %esi,%esi
  800eb7:	0f 84 5b 01 00 00    	je     801018 <event_callback+0x16f>
    s = conn->socket;
  800ebd:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  800ec0:	85 db                	test   %ebx,%ebx
  800ec2:	79 3d                	jns    800f01 <event_callback+0x58>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  800ec4:	a1 60 60 81 00       	mov    0x816060,%eax
  800ec9:	89 04 24             	mov    %eax,(%esp)
  800ecc:	e8 9b 47 00 00       	call   80566c <sys_sem_wait>
      if (conn->socket < 0) {
  800ed1:	8b 46 1c             	mov    0x1c(%esi),%eax
  800ed4:	85 c0                	test   %eax,%eax
  800ed6:	79 1c                	jns    800ef4 <event_callback+0x4b>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800ed8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  800edc:	75 04                	jne    800ee2 <event_callback+0x39>
          conn->socket--;
  800ede:	48                   	dec    %eax
  800edf:	89 46 1c             	mov    %eax,0x1c(%esi)
        }
        sys_sem_signal(socksem);
  800ee2:	a1 60 60 81 00       	mov    0x816060,%eax
  800ee7:	89 04 24             	mov    %eax,(%esp)
  800eea:	e8 d2 98 00 00       	call   80a7c1 <sys_sem_signal>
        return;
  800eef:	e9 24 01 00 00       	jmp    801018 <event_callback+0x16f>
      }
      sys_sem_signal(socksem);
  800ef4:	a1 60 60 81 00       	mov    0x816060,%eax
  800ef9:	89 04 24             	mov    %eax,(%esp)
  800efc:	e8 c0 98 00 00       	call   80a7c1 <sys_sem_signal>
    }

    sock = get_socket(s);
  800f01:	89 d8                	mov    %ebx,%eax
  800f03:	e8 38 fa ff ff       	call   800940 <get_socket>
  800f08:	89 c7                	mov    %eax,%edi
    if (!sock) {
  800f0a:	85 c0                	test   %eax,%eax
  800f0c:	0f 84 06 01 00 00    	je     801018 <event_callback+0x16f>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  800f12:	a1 64 60 81 00       	mov    0x816064,%eax
  800f17:	89 04 24             	mov    %eax,(%esp)
  800f1a:	e8 4d 47 00 00       	call   80566c <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  800f1f:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  800f23:	74 1a                	je     800f3f <event_callback+0x96>
  800f25:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  800f29:	72 0e                	jb     800f39 <event_callback+0x90>
  800f2b:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
  800f2f:	74 14                	je     800f45 <event_callback+0x9c>
  800f31:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
  800f35:	75 1e                	jne    800f55 <event_callback+0xac>
  800f37:	eb 14                	jmp    800f4d <event_callback+0xa4>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  800f39:	66 ff 47 0a          	incw   0xa(%edi)
      break;
  800f3d:	eb 32                	jmp    800f71 <event_callback+0xc8>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  800f3f:	66 ff 4f 0a          	decw   0xa(%edi)
      break;
  800f43:	eb 2c                	jmp    800f71 <event_callback+0xc8>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  800f45:	66 c7 47 0c 01 00    	movw   $0x1,0xc(%edi)
      break;
  800f4b:	eb 24                	jmp    800f71 <event_callback+0xc8>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  800f4d:	66 c7 47 0c 00 00    	movw   $0x0,0xc(%edi)
      break;
  800f53:	eb 1c                	jmp    800f71 <event_callback+0xc8>
    default:
      LWIP_ASSERT("unknown event", 0);
  800f55:	c7 44 24 08 1c 1c 81 	movl   $0x811c1c,0x8(%esp)
  800f5c:	00 
  800f5d:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  800f64:	00 
  800f65:	c7 04 24 05 1c 81 00 	movl   $0x811c05,(%esp)
  800f6c:	e8 0f df 00 00       	call   80ee80 <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  800f71:	a1 64 60 81 00       	mov    0x816064,%eax
  800f76:	89 04 24             	mov    %eax,(%esp)
  800f79:	e8 43 98 00 00       	call   80a7c1 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800f7e:	89 de                	mov    %ebx,%esi
  800f80:	85 db                	test   %ebx,%ebx
  800f82:	79 03                	jns    800f87 <event_callback+0xde>
  800f84:	8d 73 07             	lea    0x7(%ebx),%esi
  800f87:	c1 fe 03             	sar    $0x3,%esi
  800f8a:	89 d9                	mov    %ebx,%ecx
  800f8c:	83 e1 07             	and    $0x7,%ecx
  800f8f:	b8 01 00 00 00       	mov    $0x1,%eax
  800f94:	d3 e0                	shl    %cl,%eax
  800f96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  800f99:	a1 64 60 81 00       	mov    0x816064,%eax
  800f9e:	89 04 24             	mov    %eax,(%esp)
  800fa1:	e8 c6 46 00 00       	call   80566c <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800fa6:	8b 1d 00 63 81 00    	mov    0x816300,%ebx
  800fac:	eb 36                	jmp    800fe4 <event_callback+0x13b>
      if (scb->sem_signalled == 0) {
  800fae:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800fb2:	75 2e                	jne    800fe2 <event_callback+0x139>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800fb4:	8b 43 04             	mov    0x4(%ebx),%eax
  800fb7:	85 c0                	test   %eax,%eax
  800fb9:	74 10                	je     800fcb <event_callback+0x122>
  800fbb:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800fbf:	85 45 e4             	test   %eax,-0x1c(%ebp)
  800fc2:	74 07                	je     800fcb <event_callback+0x122>
          if (sock->rcvevent)
  800fc4:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  800fc9:	75 1f                	jne    800fea <event_callback+0x141>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800fcb:	8b 43 08             	mov    0x8(%ebx),%eax
  800fce:	85 c0                	test   %eax,%eax
  800fd0:	74 10                	je     800fe2 <event_callback+0x139>
  800fd2:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800fd6:	85 45 e4             	test   %eax,-0x1c(%ebp)
  800fd9:	74 07                	je     800fe2 <event_callback+0x139>
          if (sock->sendevent)
  800fdb:	66 83 7f 0c 00       	cmpw   $0x0,0xc(%edi)
  800fe0:	75 08                	jne    800fea <event_callback+0x141>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  800fe2:	8b 1b                	mov    (%ebx),%ebx
  800fe4:	85 db                	test   %ebx,%ebx
  800fe6:	75 c6                	jne    800fae <event_callback+0x105>
  800fe8:	eb 21                	jmp    80100b <event_callback+0x162>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  800fea:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800ff1:	a1 64 60 81 00       	mov    0x816064,%eax
  800ff6:	89 04 24             	mov    %eax,(%esp)
  800ff9:	e8 c3 97 00 00       	call   80a7c1 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800ffe:	8b 43 14             	mov    0x14(%ebx),%eax
  801001:	89 04 24             	mov    %eax,(%esp)
  801004:	e8 b8 97 00 00       	call   80a7c1 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  801009:	eb 8e                	jmp    800f99 <event_callback+0xf0>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  80100b:	a1 64 60 81 00       	mov    0x816064,%eax
  801010:	89 04 24             	mov    %eax,(%esp)
  801013:	e8 a9 97 00 00       	call   80a7c1 <sys_sem_signal>
      break;
    }
  }
}
  801018:	83 c4 2c             	add    $0x2c,%esp
  80101b:	5b                   	pop    %ebx
  80101c:	5e                   	pop    %esi
  80101d:	5f                   	pop    %edi
  80101e:	5d                   	pop    %ebp
  80101f:	c3                   	ret    

00801020 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  801020:	55                   	push   %ebp
  801021:	89 e5                	mov    %esp,%ebp
  801023:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  801026:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80102d:	e8 81 94 00 00       	call   80a4b3 <sys_sem_new>
  801032:	a3 60 60 81 00       	mov    %eax,0x816060
  selectsem = sys_sem_new(1);
  801037:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80103e:	e8 70 94 00 00       	call   80a4b3 <sys_sem_new>
  801043:	a3 64 60 81 00       	mov    %eax,0x816064
}
  801048:	c9                   	leave  
  801049:	c3                   	ret    

0080104a <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80104a:	55                   	push   %ebp
  80104b:	89 e5                	mov    %esp,%ebp
  80104d:	57                   	push   %edi
  80104e:	56                   	push   %esi
  80104f:	53                   	push   %ebx
  801050:	83 ec 4c             	sub    $0x4c,%esp
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  801053:	8b 45 08             	mov    0x8(%ebp),%eax
  801056:	e8 e5 f8 ff ff       	call   800940 <get_socket>
  80105b:	89 c7                	mov    %eax,%edi
  if (!sock)
  80105d:	85 c0                	test   %eax,%eax
  80105f:	0f 84 91 01 00 00    	je     8011f6 <lwip_accept+0x1ac>
    return -1;

  newconn = netconn_accept(sock->conn);
  801065:	8b 00                	mov    (%eax),%eax
  801067:	89 04 24             	mov    %eax,(%esp)
  80106a:	e8 10 a7 00 00       	call   80b77f <netconn_accept>
  80106f:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  801071:	85 c0                	test   %eax,%eax
  801073:	75 2d                	jne    8010a2 <lwip_accept+0x58>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  801075:	8b 07                	mov    (%edi),%eax
  801077:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  80107b:	f7 d8                	neg    %eax
  80107d:	83 f8 0e             	cmp    $0xe,%eax
  801080:	77 09                	ja     80108b <lwip_accept+0x41>
  801082:	8b 04 85 c0 1c 81 00 	mov    0x811cc0(,%eax,4),%eax
  801089:	eb 05                	jmp    801090 <lwip_accept+0x46>
  80108b:	b8 05 00 00 00       	mov    $0x5,%eax
  801090:	89 47 10             	mov    %eax,0x10(%edi)
  801093:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
    return -1;
  801098:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80109d:	e9 59 01 00 00       	jmp    8011fb <lwip_accept+0x1b1>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  8010a2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8010a9:	00 
  8010aa:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  8010ad:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010b1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8010b4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8010b8:	89 1c 24             	mov    %ebx,(%esp)
  8010bb:	e8 eb a4 00 00       	call   80b5ab <netconn_getaddr>
  8010c0:	89 c6                	mov    %eax,%esi
  if (err != ERR_OK) {
  8010c2:	84 c0                	test   %al,%al
  8010c4:	74 34                	je     8010fa <lwip_accept+0xb0>
    netconn_delete(newconn);
  8010c6:	89 1c 24             	mov    %ebx,(%esp)
  8010c9:	e8 76 a4 00 00       	call   80b544 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  8010ce:	89 f0                	mov    %esi,%eax
  8010d0:	0f be f0             	movsbl %al,%esi
  8010d3:	f7 de                	neg    %esi
  8010d5:	83 fe 0e             	cmp    $0xe,%esi
  8010d8:	77 09                	ja     8010e3 <lwip_accept+0x99>
  8010da:	8b 04 b5 c0 1c 81 00 	mov    0x811cc0(,%esi,4),%eax
  8010e1:	eb 05                	jmp    8010e8 <lwip_accept+0x9e>
  8010e3:	b8 05 00 00 00       	mov    $0x5,%eax
  8010e8:	89 47 10             	mov    %eax,0x10(%edi)
  8010eb:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
    return -1;
  8010f0:	be ff ff ff ff       	mov    $0xffffffff,%esi
  8010f5:	e9 01 01 00 00       	jmp    8011fb <lwip_accept+0x1b1>
  }

  memset(&sin, 0, sizeof(sin));
  8010fa:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  801101:	00 
  801102:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801109:	00 
  80110a:	8d 45 d0             	lea    -0x30(%ebp),%eax
  80110d:	89 04 24             	mov    %eax,(%esp)
  801110:	e8 3d e5 00 00       	call   80f652 <memset>
  sin.sin_len = sizeof(sin);
  801115:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  801119:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  80111d:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  801121:	89 04 24             	mov    %eax,(%esp)
  801124:	e8 30 6b 00 00       	call   807c59 <htons>
  801129:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  80112d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801130:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  801133:	8b 55 10             	mov    0x10(%ebp),%edx
  801136:	83 3a 10             	cmpl   $0x10,(%edx)
  801139:	76 06                	jbe    801141 <lwip_accept+0xf7>
    *addrlen = sizeof(sin);
  80113b:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

  SMEMCPY(addr, &sin, *addrlen);
  801141:	8b 55 10             	mov    0x10(%ebp),%edx
  801144:	8b 02                	mov    (%edx),%eax
  801146:	89 44 24 08          	mov    %eax,0x8(%esp)
  80114a:	8d 45 d0             	lea    -0x30(%ebp),%eax
  80114d:	89 44 24 04          	mov    %eax,0x4(%esp)
  801151:	8b 45 0c             	mov    0xc(%ebp),%eax
  801154:	89 04 24             	mov    %eax,(%esp)
  801157:	e8 aa e5 00 00       	call   80f706 <memcpy>

  newsock = alloc_socket(newconn);
  80115c:	89 d8                	mov    %ebx,%eax
  80115e:	e8 9f fc ff ff       	call   800e02 <alloc_socket>
  801163:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  801165:	83 f8 ff             	cmp    $0xffffffff,%eax
  801168:	75 1b                	jne    801185 <lwip_accept+0x13b>
    netconn_delete(newconn);
  80116a:	89 1c 24             	mov    %ebx,(%esp)
  80116d:	e8 d2 a3 00 00       	call   80b544 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  801172:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  801179:	c7 05 20 c2 b3 00 17 	movl   $0x17,0xb3c220
  801180:	00 00 00 
    return -1;
  801183:	eb 76                	jmp    8011fb <lwip_accept+0x1b1>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  801185:	83 f8 1f             	cmp    $0x1f,%eax
  801188:	76 1c                	jbe    8011a6 <lwip_accept+0x15c>
  80118a:	c7 44 24 08 2a 1c 81 	movl   $0x811c2a,0x8(%esp)
  801191:	00 
  801192:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  801199:	00 
  80119a:	c7 04 24 05 1c 81 00 	movl   $0x811c05,(%esp)
  8011a1:	e8 da dc 00 00       	call   80ee80 <_panic>
  newconn->callback = event_callback;
  8011a6:	c7 43 2c a9 0e 80 00 	movl   $0x800ea9,0x2c(%ebx)
  nsock = &sockets[newsock];
  8011ad:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8011b0:	8d 04 85 80 60 81 00 	lea    0x816080(,%eax,4),%eax
  8011b7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  8011ba:	a1 60 60 81 00       	mov    0x816060,%eax
  8011bf:	89 04 24             	mov    %eax,(%esp)
  8011c2:	e8 a5 44 00 00       	call   80566c <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  8011c7:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8011ca:	f7 d0                	not    %eax
  8011cc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8011cf:	66 01 42 0a          	add    %ax,0xa(%edx)
  newconn->socket = newsock;
  8011d3:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  8011d6:	a1 60 60 81 00       	mov    0x816060,%eax
  8011db:	89 04 24             	mov    %eax,(%esp)
  8011de:	e8 de 95 00 00       	call   80a7c1 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  8011e3:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8011ea:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8011f1:	00 00 00 
  return newsock;
  8011f4:	eb 05                	jmp    8011fb <lwip_accept+0x1b1>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  8011f6:	be ff ff ff ff       	mov    $0xffffffff,%esi
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  8011fb:	89 f0                	mov    %esi,%eax
  8011fd:	83 c4 4c             	add    $0x4c,%esp
  801200:	5b                   	pop    %ebx
  801201:	5e                   	pop    %esi
  801202:	5f                   	pop    %edi
  801203:	5d                   	pop    %ebp
  801204:	c3                   	ret    

00801205 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  801205:	55                   	push   %ebp
  801206:	89 e5                	mov    %esp,%ebp
  801208:	56                   	push   %esi
  801209:	53                   	push   %ebx
  80120a:	83 ec 20             	sub    $0x20,%esp
  80120d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  801210:	8b 45 08             	mov    0x8(%ebp),%eax
  801213:	e8 28 f7 ff ff       	call   800940 <get_socket>
  801218:	89 c6                	mov    %eax,%esi
  if (!sock)
  80121a:	85 c0                	test   %eax,%eax
  80121c:	0f 84 95 00 00 00    	je     8012b7 <lwip_bind+0xb2>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801222:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801226:	75 06                	jne    80122e <lwip_bind+0x29>
  801228:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  80122c:	74 1c                	je     80124a <lwip_bind+0x45>
  80122e:	c7 44 24 08 3f 1c 81 	movl   $0x811c3f,0x8(%esp)
  801235:	00 
  801236:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  80123d:	00 
  80123e:	c7 04 24 05 1c 81 00 	movl   $0x811c05,(%esp)
  801245:	e8 36 dc 00 00       	call   80ee80 <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80124a:	8b 43 04             	mov    0x4(%ebx),%eax
  80124d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  801250:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  801254:	89 04 24             	mov    %eax,(%esp)
  801257:	e8 09 6a 00 00       	call   807c65 <ntohs>
  80125c:	0f b7 c0             	movzwl %ax,%eax
  80125f:	89 44 24 08          	mov    %eax,0x8(%esp)
  801263:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801266:	89 44 24 04          	mov    %eax,0x4(%esp)
  80126a:	8b 06                	mov    (%esi),%eax
  80126c:	89 04 24             	mov    %eax,(%esp)
  80126f:	e8 d1 a3 00 00       	call   80b645 <netconn_bind>

  if (err != ERR_OK) {
  801274:	84 c0                	test   %al,%al
  801276:	74 27                	je     80129f <lwip_bind+0x9a>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801278:	0f be c0             	movsbl %al,%eax
  80127b:	f7 d8                	neg    %eax
  80127d:	83 f8 0e             	cmp    $0xe,%eax
  801280:	77 09                	ja     80128b <lwip_bind+0x86>
  801282:	8b 04 85 c0 1c 81 00 	mov    0x811cc0(,%eax,4),%eax
  801289:	eb 05                	jmp    801290 <lwip_bind+0x8b>
  80128b:	b8 05 00 00 00       	mov    $0x5,%eax
  801290:	89 46 10             	mov    %eax,0x10(%esi)
  801293:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
    return -1;
  801298:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80129d:	eb 1d                	jmp    8012bc <lwip_bind+0xb7>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  80129f:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8012a6:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8012ad:	00 00 00 
  return 0;
  8012b0:	b8 00 00 00 00       	mov    $0x0,%eax
  8012b5:	eb 05                	jmp    8012bc <lwip_bind+0xb7>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8012b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  8012bc:	83 c4 20             	add    $0x20,%esp
  8012bf:	5b                   	pop    %ebx
  8012c0:	5e                   	pop    %esi
  8012c1:	5d                   	pop    %ebp
  8012c2:	c3                   	ret    

008012c3 <lwip_close>:

int
lwip_close(int s)
{
  8012c3:	55                   	push   %ebp
  8012c4:	89 e5                	mov    %esp,%ebp
  8012c6:	53                   	push   %ebx
  8012c7:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  8012ca:	8b 45 08             	mov    0x8(%ebp),%eax
  8012cd:	e8 6e f6 ff ff       	call   800940 <get_socket>
  8012d2:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  8012d4:	85 c0                	test   %eax,%eax
  8012d6:	74 5e                	je     801336 <lwip_close+0x73>
    return -1;
  }

  netconn_delete(sock->conn);
  8012d8:	8b 00                	mov    (%eax),%eax
  8012da:	89 04 24             	mov    %eax,(%esp)
  8012dd:	e8 62 a2 00 00       	call   80b544 <netconn_delete>

  sys_sem_wait(socksem);
  8012e2:	a1 60 60 81 00       	mov    0x816060,%eax
  8012e7:	89 04 24             	mov    %eax,(%esp)
  8012ea:	e8 7d 43 00 00       	call   80566c <sys_sem_wait>
  if (sock->lastdata) {
  8012ef:	8b 43 04             	mov    0x4(%ebx),%eax
  8012f2:	85 c0                	test   %eax,%eax
  8012f4:	74 08                	je     8012fe <lwip_close+0x3b>
    netbuf_delete(sock->lastdata);
  8012f6:	89 04 24             	mov    %eax,(%esp)
  8012f9:	e8 e6 14 00 00       	call   8027e4 <netbuf_delete>
  }
  sock->lastdata   = NULL;
  8012fe:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801305:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  80130b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  801311:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801318:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  80131f:	00 00 00 
  sys_sem_signal(socksem);
  801322:	a1 60 60 81 00       	mov    0x816060,%eax
  801327:	89 04 24             	mov    %eax,(%esp)
  80132a:	e8 92 94 00 00       	call   80a7c1 <sys_sem_signal>
  return 0;
  80132f:	b8 00 00 00 00       	mov    $0x0,%eax
  801334:	eb 05                	jmp    80133b <lwip_close+0x78>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
  801336:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  sock->lastoffset = 0;
  sock->conn       = NULL;
  sock_set_errno(sock, 0);
  sys_sem_signal(socksem);
  return 0;
}
  80133b:	83 c4 14             	add    $0x14,%esp
  80133e:	5b                   	pop    %ebx
  80133f:	5d                   	pop    %ebp
  801340:	c3                   	ret    

00801341 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  801341:	55                   	push   %ebp
  801342:	89 e5                	mov    %esp,%ebp
  801344:	56                   	push   %esi
  801345:	53                   	push   %ebx
  801346:	83 ec 20             	sub    $0x20,%esp
  801349:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  80134c:	8b 45 08             	mov    0x8(%ebp),%eax
  80134f:	e8 ec f5 ff ff       	call   800940 <get_socket>
  801354:	89 c6                	mov    %eax,%esi
  if (!sock)
  801356:	85 c0                	test   %eax,%eax
  801358:	0f 84 95 00 00 00    	je     8013f3 <lwip_connect+0xb2>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80135e:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801362:	75 06                	jne    80136a <lwip_connect+0x29>
  801364:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  801368:	74 1c                	je     801386 <lwip_connect+0x45>
  80136a:	c7 44 24 08 5a 1c 81 	movl   $0x811c5a,0x8(%esp)
  801371:	00 
  801372:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  801379:	00 
  80137a:	c7 04 24 05 1c 81 00 	movl   $0x811c05,(%esp)
  801381:	e8 fa da 00 00       	call   80ee80 <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801386:	8b 43 04             	mov    0x4(%ebx),%eax
  801389:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80138c:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  801390:	89 04 24             	mov    %eax,(%esp)
  801393:	e8 cd 68 00 00       	call   807c65 <ntohs>
  801398:	0f b7 c0             	movzwl %ax,%eax
  80139b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80139f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8013a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8013a6:	8b 06                	mov    (%esi),%eax
  8013a8:	89 04 24             	mov    %eax,(%esp)
  8013ab:	e8 ea a2 00 00       	call   80b69a <netconn_connect>
  }

  if (err != ERR_OK) {
  8013b0:	84 c0                	test   %al,%al
  8013b2:	74 27                	je     8013db <lwip_connect+0x9a>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8013b4:	0f be c0             	movsbl %al,%eax
  8013b7:	f7 d8                	neg    %eax
  8013b9:	83 f8 0e             	cmp    $0xe,%eax
  8013bc:	77 09                	ja     8013c7 <lwip_connect+0x86>
  8013be:	8b 04 85 c0 1c 81 00 	mov    0x811cc0(,%eax,4),%eax
  8013c5:	eb 05                	jmp    8013cc <lwip_connect+0x8b>
  8013c7:	b8 05 00 00 00       	mov    $0x5,%eax
  8013cc:	89 46 10             	mov    %eax,0x10(%esi)
  8013cf:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
    return -1;
  8013d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8013d9:	eb 1d                	jmp    8013f8 <lwip_connect+0xb7>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8013db:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8013e2:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8013e9:	00 00 00 
  return 0;
  8013ec:	b8 00 00 00 00       	mov    $0x0,%eax
  8013f1:	eb 05                	jmp    8013f8 <lwip_connect+0xb7>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8013f3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  8013f8:	83 c4 20             	add    $0x20,%esp
  8013fb:	5b                   	pop    %ebx
  8013fc:	5e                   	pop    %esi
  8013fd:	5d                   	pop    %ebp
  8013fe:	c3                   	ret    

008013ff <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  8013ff:	55                   	push   %ebp
  801400:	89 e5                	mov    %esp,%ebp
  801402:	56                   	push   %esi
  801403:	53                   	push   %ebx
  801404:	83 ec 10             	sub    $0x10,%esp
  801407:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80140a:	8b 45 08             	mov    0x8(%ebp),%eax
  80140d:	e8 2e f5 ff ff       	call   800940 <get_socket>
  801412:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801414:	85 c0                	test   %eax,%eax
  801416:	74 6d                	je     801485 <lwip_listen+0x86>
  801418:	89 f0                	mov    %esi,%eax
  80141a:	85 f6                	test   %esi,%esi
  80141c:	79 05                	jns    801423 <lwip_listen+0x24>
  80141e:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  801423:	89 c2                	mov    %eax,%edx
  801425:	3d ff 00 00 00       	cmp    $0xff,%eax
  80142a:	7e 05                	jle    801431 <lwip_listen+0x32>
  80142c:	ba ff 00 00 00       	mov    $0xff,%edx
  801431:	0f b6 d2             	movzbl %dl,%edx
  801434:	89 54 24 04          	mov    %edx,0x4(%esp)
  801438:	8b 03                	mov    (%ebx),%eax
  80143a:	89 04 24             	mov    %eax,(%esp)
  80143d:	e8 f5 a2 00 00       	call   80b737 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  801442:	84 c0                	test   %al,%al
  801444:	74 27                	je     80146d <lwip_listen+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801446:	0f be c0             	movsbl %al,%eax
  801449:	f7 d8                	neg    %eax
  80144b:	83 f8 0e             	cmp    $0xe,%eax
  80144e:	77 09                	ja     801459 <lwip_listen+0x5a>
  801450:	8b 04 85 c0 1c 81 00 	mov    0x811cc0(,%eax,4),%eax
  801457:	eb 05                	jmp    80145e <lwip_listen+0x5f>
  801459:	b8 05 00 00 00       	mov    $0x5,%eax
  80145e:	89 43 10             	mov    %eax,0x10(%ebx)
  801461:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
    return -1;
  801466:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80146b:	eb 1d                	jmp    80148a <lwip_listen+0x8b>
  }

  sock_set_errno(sock, 0);
  80146d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801474:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  80147b:	00 00 00 
  return 0;
  80147e:	b8 00 00 00 00       	mov    $0x0,%eax
  801483:	eb 05                	jmp    80148a <lwip_listen+0x8b>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801485:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
  80148a:	83 c4 10             	add    $0x10,%esp
  80148d:	5b                   	pop    %ebx
  80148e:	5e                   	pop    %esi
  80148f:	5d                   	pop    %ebp
  801490:	c3                   	ret    

00801491 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  801491:	55                   	push   %ebp
  801492:	89 e5                	mov    %esp,%ebp
  801494:	57                   	push   %edi
  801495:	56                   	push   %esi
  801496:	53                   	push   %ebx
  801497:	83 ec 5c             	sub    $0x5c,%esp
  80149a:	8b 75 14             	mov    0x14(%ebp),%esi
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  80149d:	8b 45 08             	mov    0x8(%ebp),%eax
  8014a0:	e8 9b f4 ff ff       	call   800940 <get_socket>
  8014a5:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8014a7:	85 c0                	test   %eax,%eax
  8014a9:	0f 84 36 02 00 00    	je     8016e5 <lwip_recvfrom+0x254>
  8014af:	bf 00 00 00 00       	mov    $0x0,%edi
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8014b4:	89 f0                	mov    %esi,%eax
  8014b6:	83 e0 08             	and    $0x8,%eax
  8014b9:	89 45 b0             	mov    %eax,-0x50(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8014bc:	83 e6 01             	and    $0x1,%esi
  8014bf:	89 75 b4             	mov    %esi,-0x4c(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8014c2:	8b 43 04             	mov    0x4(%ebx),%eax
  8014c5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  8014c8:	85 c0                	test   %eax,%eax
  8014ca:	0f 85 82 00 00 00    	jne    801552 <lwip_recvfrom+0xc1>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8014d0:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  8014d4:	75 06                	jne    8014dc <lwip_recvfrom+0x4b>
  8014d6:	f6 43 0f 08          	testb  $0x8,0xf(%ebx)
  8014da:	74 22                	je     8014fe <lwip_recvfrom+0x6d>
  8014dc:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8014e1:	75 1b                	jne    8014fe <lwip_recvfrom+0x6d>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  8014e3:	c7 43 10 0b 00 00 00 	movl   $0xb,0x10(%ebx)
  8014ea:	c7 05 20 c2 b3 00 0b 	movl   $0xb,0xb3c220
  8014f1:	00 00 00 
        return -1;
  8014f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8014f9:	e9 ec 01 00 00       	jmp    8016ea <lwip_recvfrom+0x259>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  8014fe:	8b 03                	mov    (%ebx),%eax
  801500:	89 04 24             	mov    %eax,(%esp)
  801503:	e8 01 a3 00 00       	call   80b809 <netconn_recv>
  801508:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  80150b:	89 43 04             	mov    %eax,0x4(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  80150e:	85 c0                	test   %eax,%eax
  801510:	75 40                	jne    801552 <lwip_recvfrom+0xc1>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801512:	8b 03                	mov    (%ebx),%eax
  801514:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  801518:	74 06                	je     801520 <lwip_recvfrom+0x8f>
  80151a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80151e:	74 14                	je     801534 <lwip_recvfrom+0xa3>
  801520:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  801524:	f7 d8                	neg    %eax
  801526:	83 f8 0e             	cmp    $0xe,%eax
  801529:	77 10                	ja     80153b <lwip_recvfrom+0xaa>
  80152b:	8b 04 85 c0 1c 81 00 	mov    0x811cc0(,%eax,4),%eax
  801532:	eb 0c                	jmp    801540 <lwip_recvfrom+0xaf>
  801534:	b8 6e 00 00 00       	mov    $0x6e,%eax
  801539:	eb 05                	jmp    801540 <lwip_recvfrom+0xaf>
  80153b:	b8 05 00 00 00       	mov    $0x5,%eax
  801540:	89 43 10             	mov    %eax,0x10(%ebx)
  801543:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
        return 0;
  801548:	b8 00 00 00 00       	mov    $0x0,%eax
  80154d:	e9 98 01 00 00       	jmp    8016ea <lwip_recvfrom+0x259>
      }
    }

    buflen = netbuf_len(buf);
  801552:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801555:	8b 02                	mov    (%edx),%eax
  801557:	8b 70 08             	mov    0x8(%eax),%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  80155a:	8b 53 08             	mov    0x8(%ebx),%edx
  80155d:	66 29 d6             	sub    %dx,%si

    if (len > buflen) {
  801560:	0f b7 ce             	movzwl %si,%ecx
  801563:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  801566:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  801569:	7f 03                	jg     80156e <lwip_recvfrom+0xdd>
      copylen = buflen;
    } else {
      copylen = len;
  80156b:	8b 75 10             	mov    0x10(%ebp),%esi
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80156e:	0f b7 ce             	movzwl %si,%ecx
  801571:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801574:	0f b7 d2             	movzwl %dx,%edx
  801577:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80157b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80157f:	0f b7 d7             	movzwl %di,%edx
  801582:	03 55 0c             	add    0xc(%ebp),%edx
  801585:	89 54 24 04          	mov    %edx,0x4(%esp)
  801589:	89 04 24             	mov    %eax,(%esp)
  80158c:	e8 56 3f 00 00       	call   8054e7 <pbuf_copy_partial>

    off += copylen;
  801591:	01 f7                	add    %esi,%edi

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801593:	8b 03                	mov    (%ebx),%eax
  801595:	89 04 24             	mov    %eax,(%esp)
  801598:	e8 e1 9f 00 00       	call   80b57e <netconn_type>
  80159d:	83 f8 10             	cmp    $0x10,%eax
  8015a0:	75 22                	jne    8015c4 <lwip_recvfrom+0x133>
      len -= copylen;
  8015a2:	8b 45 c0             	mov    -0x40(%ebp),%eax
  8015a5:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8015a8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8015ac:	7e 1c                	jle    8015ca <lwip_recvfrom+0x139>
  8015ae:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8015b1:	8b 02                	mov    (%edx),%eax
  8015b3:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8015b7:	75 17                	jne    8015d0 <lwip_recvfrom+0x13f>
  8015b9:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8015be:	0f 94 45 bb          	sete   -0x45(%ebp)
  8015c2:	eb 10                	jmp    8015d4 <lwip_recvfrom+0x143>
        done = 1;
      }
    } else {
      done = 1;
  8015c4:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
  8015c8:	eb 0a                	jmp    8015d4 <lwip_recvfrom+0x143>
    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
  8015ca:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
  8015ce:	eb 04                	jmp    8015d4 <lwip_recvfrom+0x143>
  8015d0:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8015d4:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8015d8:	75 3f                	jne    801619 <lwip_recvfrom+0x188>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8015da:	8b 03                	mov    (%ebx),%eax
  8015dc:	83 38 10             	cmpl   $0x10,(%eax)
  8015df:	75 16                	jne    8015f7 <lwip_recvfrom+0x166>
  8015e1:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8015e4:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8015e7:	85 c0                	test   %eax,%eax
  8015e9:	7e 0c                	jle    8015f7 <lwip_recvfrom+0x166>
        sock->lastdata = buf;
  8015eb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  8015ee:	89 43 04             	mov    %eax,0x4(%ebx)
        sock->lastoffset += copylen;
  8015f1:	66 01 73 08          	add    %si,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8015f5:	eb 18                	jmp    80160f <lwip_recvfrom+0x17e>
      } else {
        sock->lastdata = NULL;
  8015f7:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        sock->lastoffset = 0;
  8015fe:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  801604:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801607:	89 04 24             	mov    %eax,(%esp)
  80160a:	e8 d5 11 00 00       	call   8027e4 <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  80160f:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
  801613:	0f 84 a9 fe ff ff    	je     8014c2 <lwip_recvfrom+0x31>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  801619:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  80161d:	0f 84 ac 00 00 00    	je     8016cf <lwip_recvfrom+0x23e>
  801623:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801627:	0f 84 a2 00 00 00    	je     8016cf <lwip_recvfrom+0x23e>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80162d:	8b 03                	mov    (%ebx),%eax
  80162f:	89 04 24             	mov    %eax,(%esp)
  801632:	e8 47 9f 00 00       	call   80b57e <netconn_type>
  801637:	83 f8 10             	cmp    $0x10,%eax
  80163a:	75 25                	jne    801661 <lwip_recvfrom+0x1d0>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
  80163c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801643:	00 
  801644:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801647:	89 44 24 08          	mov    %eax,0x8(%esp)
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  80164b:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80164e:	89 44 24 04          	mov    %eax,0x4(%esp)
      netconn_getaddr(sock->conn, addr, &port, 0);
  801652:	8b 03                	mov    (%ebx),%eax
  801654:	89 04 24             	mov    %eax,(%esp)
  801657:	e8 4f 9f 00 00       	call   80b5ab <netconn_getaddr>
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  80165c:	8d 75 d8             	lea    -0x28(%ebp),%esi
  80165f:	eb 0d                	jmp    80166e <lwip_recvfrom+0x1dd>
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
  801661:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801664:	8b 70 08             	mov    0x8(%eax),%esi
      port = netbuf_fromport(buf);
  801667:	8b 40 0c             	mov    0xc(%eax),%eax
  80166a:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  80166e:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  801675:	00 
  801676:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80167d:	00 
  80167e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801681:	89 04 24             	mov    %eax,(%esp)
  801684:	e8 c9 df 00 00       	call   80f652 <memset>
    sin.sin_len = sizeof(sin);
  801689:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  80168d:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  801691:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  801695:	89 04 24             	mov    %eax,(%esp)
  801698:	e8 bc 65 00 00       	call   807c59 <htons>
  80169d:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8016a1:	8b 06                	mov    (%esi),%eax
  8016a3:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  8016a6:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  8016a9:	83 39 10             	cmpl   $0x10,(%ecx)
  8016ac:	76 06                	jbe    8016b4 <lwip_recvfrom+0x223>
      *fromlen = sizeof(sin);
  8016ae:	c7 01 10 00 00 00    	movl   $0x10,(%ecx)

    SMEMCPY(from, &sin, *fromlen);
  8016b4:	8b 55 1c             	mov    0x1c(%ebp),%edx
  8016b7:	8b 02                	mov    (%edx),%eax
  8016b9:	89 44 24 08          	mov    %eax,0x8(%esp)
  8016bd:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8016c0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8016c4:	8b 4d 18             	mov    0x18(%ebp),%ecx
  8016c7:	89 0c 24             	mov    %ecx,(%esp)
  8016ca:	e8 37 e0 00 00       	call   80f706 <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8016cf:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8016d6:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8016dd:	00 00 00 
  return off;
  8016e0:	0f b7 c7             	movzwl %di,%eax
  8016e3:	eb 05                	jmp    8016ea <lwip_recvfrom+0x259>
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;
  8016e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  return off;
}
  8016ea:	83 c4 5c             	add    $0x5c,%esp
  8016ed:	5b                   	pop    %ebx
  8016ee:	5e                   	pop    %esi
  8016ef:	5f                   	pop    %edi
  8016f0:	5d                   	pop    %ebp
  8016f1:	c3                   	ret    

008016f2 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  8016f2:	55                   	push   %ebp
  8016f3:	89 e5                	mov    %esp,%ebp
  8016f5:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8016f8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8016ff:	00 
  801700:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  801707:	00 
  801708:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80170f:	00 
  801710:	8b 45 10             	mov    0x10(%ebp),%eax
  801713:	89 44 24 08          	mov    %eax,0x8(%esp)
  801717:	8b 45 0c             	mov    0xc(%ebp),%eax
  80171a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80171e:	8b 45 08             	mov    0x8(%ebp),%eax
  801721:	89 04 24             	mov    %eax,(%esp)
  801724:	e8 68 fd ff ff       	call   801491 <lwip_recvfrom>
}
  801729:	c9                   	leave  
  80172a:	c3                   	ret    

0080172b <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  80172b:	55                   	push   %ebp
  80172c:	89 e5                	mov    %esp,%ebp
  80172e:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  801731:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  801738:	00 
  801739:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  801740:	00 
  801741:	8b 45 14             	mov    0x14(%ebp),%eax
  801744:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801748:	8b 45 10             	mov    0x10(%ebp),%eax
  80174b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80174f:	8b 45 0c             	mov    0xc(%ebp),%eax
  801752:	89 44 24 04          	mov    %eax,0x4(%esp)
  801756:	8b 45 08             	mov    0x8(%ebp),%eax
  801759:	89 04 24             	mov    %eax,(%esp)
  80175c:	e8 30 fd ff ff       	call   801491 <lwip_recvfrom>
}
  801761:	c9                   	leave  
  801762:	c3                   	ret    

00801763 <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  801763:	55                   	push   %ebp
  801764:	89 e5                	mov    %esp,%ebp
  801766:	57                   	push   %edi
  801767:	56                   	push   %esi
  801768:	53                   	push   %ebx
  801769:	83 ec 3c             	sub    $0x3c,%esp
  80176c:	8b 7d 10             	mov    0x10(%ebp),%edi
  80176f:	8b 5d 18             	mov    0x18(%ebp),%ebx
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  801772:	8b 45 08             	mov    0x8(%ebp),%eax
  801775:	e8 c6 f1 ff ff       	call   800940 <get_socket>
  80177a:	89 c6                	mov    %eax,%esi
  if (!sock)
  80177c:	85 c0                	test   %eax,%eax
  80177e:	0f 84 36 01 00 00    	je     8018ba <lwip_sendto+0x157>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  801784:	8b 00                	mov    (%eax),%eax
  801786:	83 38 10             	cmpl   $0x10,(%eax)
  801789:	75 24                	jne    8017af <lwip_sendto+0x4c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  80178b:	8b 45 14             	mov    0x14(%ebp),%eax
  80178e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801792:	89 7c 24 08          	mov    %edi,0x8(%esp)
  801796:	8b 45 0c             	mov    0xc(%ebp),%eax
  801799:	89 44 24 04          	mov    %eax,0x4(%esp)
  80179d:	8b 45 08             	mov    0x8(%ebp),%eax
  8017a0:	89 04 24             	mov    %eax,(%esp)
  8017a3:	e8 34 01 00 00       	call   8018dc <lwip_send>
  8017a8:	89 c7                	mov    %eax,%edi
  8017aa:	e9 10 01 00 00       	jmp    8018bf <lwip_sendto+0x15c>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8017af:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  8017b5:	76 1c                	jbe    8017d3 <lwip_sendto+0x70>
  8017b7:	c7 44 24 08 98 1c 81 	movl   $0x811c98,0x8(%esp)
  8017be:	00 
  8017bf:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  8017c6:	00 
  8017c7:	c7 04 24 05 1c 81 00 	movl   $0x811c05,(%esp)
  8017ce:	e8 ad d6 00 00       	call   80ee80 <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8017d3:	85 db                	test   %ebx,%ebx
  8017d5:	75 0a                	jne    8017e1 <lwip_sendto+0x7e>
  8017d7:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8017db:	0f 84 e8 00 00 00    	je     8018c9 <lwip_sendto+0x166>
  8017e1:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8017e5:	75 06                	jne    8017ed <lwip_sendto+0x8a>
  8017e7:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  8017eb:	74 1c                	je     801809 <lwip_sendto+0xa6>
  8017ed:	c7 44 24 08 78 1c 81 	movl   $0x811c78,0x8(%esp)
  8017f4:	00 
  8017f5:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  8017fc:	00 
  8017fd:	c7 04 24 05 1c 81 00 	movl   $0x811c05,(%esp)
  801804:	e8 77 d6 00 00       	call   80ee80 <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  801809:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801810:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  801817:	85 db                	test   %ebx,%ebx
  801819:	74 1e                	je     801839 <lwip_sendto+0xd6>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  80181b:	8b 43 04             	mov    0x4(%ebx),%eax
  80181e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801821:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  801825:	89 04 24             	mov    %eax,(%esp)
  801828:	e8 38 64 00 00       	call   807c65 <ntohs>
    buf.addr         = &remote_addr;
  80182d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801830:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801833:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  801837:	eb 14                	jmp    80184d <lwip_sendto+0xea>
  } else {
    remote_addr.addr = 0;
  801839:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  801840:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801847:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  80184d:	0f b7 c7             	movzwl %di,%eax
  801850:	89 44 24 08          	mov    %eax,0x8(%esp)
  801854:	8b 45 0c             	mov    0xc(%ebp),%eax
  801857:	89 44 24 04          	mov    %eax,0x4(%esp)
  80185b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80185e:	89 04 24             	mov    %eax,(%esp)
  801861:	e8 9b 10 00 00       	call   802901 <netbuf_ref>
  801866:	0f be d8             	movsbl %al,%ebx
  801869:	85 db                	test   %ebx,%ebx
  80186b:	75 14                	jne    801881 <lwip_sendto+0x11e>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  80186d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801870:	89 44 24 04          	mov    %eax,0x4(%esp)
  801874:	8b 06                	mov    (%esi),%eax
  801876:	89 04 24             	mov    %eax,(%esp)
  801879:	e8 34 a1 00 00       	call   80b9b2 <netconn_send>
  80187e:	0f be d8             	movsbl %al,%ebx
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  801881:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  801884:	85 c0                	test   %eax,%eax
  801886:	74 08                	je     801890 <lwip_sendto+0x12d>
    pbuf_free(buf.p);
  801888:	89 04 24             	mov    %eax,(%esp)
  80188b:	e8 c1 34 00 00       	call   804d51 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  801890:	89 d8                	mov    %ebx,%eax
  801892:	f7 d8                	neg    %eax
  801894:	83 f8 0e             	cmp    $0xe,%eax
  801897:	77 09                	ja     8018a2 <lwip_sendto+0x13f>
  801899:	8b 04 85 c0 1c 81 00 	mov    0x811cc0(,%eax,4),%eax
  8018a0:	eb 05                	jmp    8018a7 <lwip_sendto+0x144>
  8018a2:	b8 05 00 00 00       	mov    $0x5,%eax
  8018a7:	89 46 10             	mov    %eax,0x10(%esi)
  8018aa:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  return (err==ERR_OK?size:-1);
  8018af:	85 db                	test   %ebx,%ebx
  8018b1:	74 0c                	je     8018bf <lwip_sendto+0x15c>
  8018b3:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  8018b8:	eb 05                	jmp    8018bf <lwip_sendto+0x15c>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  8018ba:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  8018bf:	89 f8                	mov    %edi,%eax
  8018c1:	83 c4 3c             	add    $0x3c,%esp
  8018c4:	5b                   	pop    %ebx
  8018c5:	5e                   	pop    %esi
  8018c6:	5f                   	pop    %edi
  8018c7:	5d                   	pop    %ebp
  8018c8:	c3                   	ret    
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  8018c9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8018d0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  8018d7:	e9 5d ff ff ff       	jmp    801839 <lwip_sendto+0xd6>

008018dc <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  8018dc:	55                   	push   %ebp
  8018dd:	89 e5                	mov    %esp,%ebp
  8018df:	57                   	push   %edi
  8018e0:	56                   	push   %esi
  8018e1:	53                   	push   %ebx
  8018e2:	83 ec 2c             	sub    $0x2c,%esp
  8018e5:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8018e8:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  8018eb:	8b 45 08             	mov    0x8(%ebp),%eax
  8018ee:	e8 4d f0 ff ff       	call   800940 <get_socket>
  8018f3:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8018f5:	85 c0                	test   %eax,%eax
  8018f7:	0f 84 86 00 00 00    	je     801983 <lwip_send+0xa7>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  8018fd:	8b 00                	mov    (%eax),%eax
  8018ff:	83 38 10             	cmpl   $0x10,(%eax)
  801902:	74 2e                	je     801932 <lwip_send+0x56>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  801904:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80190b:	00 
  80190c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  801913:	00 
  801914:	8b 45 14             	mov    0x14(%ebp),%eax
  801917:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80191b:	89 74 24 08          	mov    %esi,0x8(%esp)
  80191f:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801923:	8b 45 08             	mov    0x8(%ebp),%eax
  801926:	89 04 24             	mov    %eax,(%esp)
  801929:	e8 35 fe ff ff       	call   801763 <lwip_sendto>
  80192e:	89 c6                	mov    %eax,%esi
  801930:	eb 56                	jmp    801988 <lwip_send+0xac>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801932:	8b 55 14             	mov    0x14(%ebp),%edx
  801935:	83 e2 10             	and    $0x10,%edx
  801938:	83 fa 01             	cmp    $0x1,%edx
  80193b:	19 d2                	sbb    %edx,%edx
  80193d:	83 e2 fe             	and    $0xfffffffe,%edx
  801940:	83 c2 03             	add    $0x3,%edx
  801943:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801947:	89 74 24 08          	mov    %esi,0x8(%esp)
  80194b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80194f:	89 04 24             	mov    %eax,(%esp)
  801952:	e8 d8 a0 00 00       	call   80ba2f <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  801957:	0f be d0             	movsbl %al,%edx
  80195a:	f7 da                	neg    %edx
  80195c:	83 fa 0e             	cmp    $0xe,%edx
  80195f:	77 09                	ja     80196a <lwip_send+0x8e>
  801961:	8b 14 95 c0 1c 81 00 	mov    0x811cc0(,%edx,4),%edx
  801968:	eb 05                	jmp    80196f <lwip_send+0x93>
  80196a:	ba 05 00 00 00       	mov    $0x5,%edx
  80196f:	89 53 10             	mov    %edx,0x10(%ebx)
  801972:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  return (err==ERR_OK?size:-1);
  801978:	84 c0                	test   %al,%al
  80197a:	74 0c                	je     801988 <lwip_send+0xac>
  80197c:	be ff ff ff ff       	mov    $0xffffffff,%esi
  801981:	eb 05                	jmp    801988 <lwip_send+0xac>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801983:	be ff ff ff ff       	mov    $0xffffffff,%esi
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801988:	89 f0                	mov    %esi,%eax
  80198a:	83 c4 2c             	add    $0x2c,%esp
  80198d:	5b                   	pop    %ebx
  80198e:	5e                   	pop    %esi
  80198f:	5f                   	pop    %edi
  801990:	5d                   	pop    %ebp
  801991:	c3                   	ret    

00801992 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  801992:	55                   	push   %ebp
  801993:	89 e5                	mov    %esp,%ebp
  801995:	56                   	push   %esi
  801996:	53                   	push   %ebx
  801997:	83 ec 10             	sub    $0x10,%esp
  80199a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80199d:	8b 55 10             	mov    0x10(%ebp),%edx
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  8019a0:	83 f8 02             	cmp    $0x2,%eax
  8019a3:	74 2b                	je     8019d0 <lwip_socket+0x3e>
  8019a5:	83 f8 03             	cmp    $0x3,%eax
  8019a8:	74 07                	je     8019b1 <lwip_socket+0x1f>
  8019aa:	83 f8 01             	cmp    $0x1,%eax
  8019ad:	75 6c                	jne    801a1b <lwip_socket+0x89>
  8019af:	eb 4a                	jmp    8019fb <lwip_socket+0x69>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  8019b1:	c7 44 24 08 a9 0e 80 	movl   $0x800ea9,0x8(%esp)
  8019b8:	00 
  8019b9:	0f b6 d2             	movzbl %dl,%edx
  8019bc:	89 54 24 04          	mov    %edx,0x4(%esp)
  8019c0:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  8019c7:	e8 70 9a 00 00       	call   80b43c <netconn_new_with_proto_and_callback>
  8019cc:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8019ce:	eb 5c                	jmp    801a2c <lwip_socket+0x9a>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  8019d0:	81 fa 88 00 00 00    	cmp    $0x88,%edx
  8019d6:	0f 94 c0             	sete   %al
  8019d9:	0f b6 c0             	movzbl %al,%eax
  8019dc:	83 c0 20             	add    $0x20,%eax
  8019df:	c7 44 24 08 a9 0e 80 	movl   $0x800ea9,0x8(%esp)
  8019e6:	00 
  8019e7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8019ee:	00 
  8019ef:	89 04 24             	mov    %eax,(%esp)
  8019f2:	e8 45 9a 00 00       	call   80b43c <netconn_new_with_proto_and_callback>
  8019f7:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8019f9:	eb 31                	jmp    801a2c <lwip_socket+0x9a>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8019fb:	c7 44 24 08 a9 0e 80 	movl   $0x800ea9,0x8(%esp)
  801a02:	00 
  801a03:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801a0a:	00 
  801a0b:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  801a12:	e8 25 9a 00 00       	call   80b43c <netconn_new_with_proto_and_callback>
  801a17:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801a19:	eb 11                	jmp    801a2c <lwip_socket+0x9a>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  801a1b:	c7 05 20 c2 b3 00 16 	movl   $0x16,0xb3c220
  801a22:	00 00 00 
    return -1;
  801a25:	be ff ff ff ff       	mov    $0xffffffff,%esi
  801a2a:	eb 44                	jmp    801a70 <lwip_socket+0xde>
  }

  if (!conn) {
  801a2c:	85 db                	test   %ebx,%ebx
  801a2e:	75 11                	jne    801a41 <lwip_socket+0xaf>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  801a30:	c7 05 20 c2 b3 00 69 	movl   $0x69,0xb3c220
  801a37:	00 00 00 
    return -1;
  801a3a:	be ff ff ff ff       	mov    $0xffffffff,%esi
  801a3f:	eb 2f                	jmp    801a70 <lwip_socket+0xde>
  }

  i = alloc_socket(conn);
  801a41:	89 d8                	mov    %ebx,%eax
  801a43:	e8 ba f3 ff ff       	call   800e02 <alloc_socket>
  801a48:	89 c6                	mov    %eax,%esi

  if (i == -1) {
  801a4a:	83 f8 ff             	cmp    $0xffffffff,%eax
  801a4d:	75 14                	jne    801a63 <lwip_socket+0xd1>
    netconn_delete(conn);
  801a4f:	89 1c 24             	mov    %ebx,(%esp)
  801a52:	e8 ed 9a 00 00       	call   80b544 <netconn_delete>
    set_errno(ENFILE);
  801a57:	c7 05 20 c2 b3 00 17 	movl   $0x17,0xb3c220
  801a5e:	00 00 00 
    return -1;
  801a61:	eb 0d                	jmp    801a70 <lwip_socket+0xde>
  }
  conn->socket = i;
  801a63:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  801a66:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  801a6d:	00 00 00 
  return i;
}
  801a70:	89 f0                	mov    %esi,%eax
  801a72:	83 c4 10             	add    $0x10,%esp
  801a75:	5b                   	pop    %ebx
  801a76:	5e                   	pop    %esi
  801a77:	5d                   	pop    %ebp
  801a78:	c3                   	ret    

00801a79 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  801a79:	55                   	push   %ebp
  801a7a:	89 e5                	mov    %esp,%ebp
  801a7c:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  801a7f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801a86:	00 
  801a87:	8b 45 10             	mov    0x10(%ebp),%eax
  801a8a:	89 44 24 08          	mov    %eax,0x8(%esp)
  801a8e:	8b 45 0c             	mov    0xc(%ebp),%eax
  801a91:	89 44 24 04          	mov    %eax,0x4(%esp)
  801a95:	8b 45 08             	mov    0x8(%ebp),%eax
  801a98:	89 04 24             	mov    %eax,(%esp)
  801a9b:	e8 3c fe ff ff       	call   8018dc <lwip_send>
}
  801aa0:	c9                   	leave  
  801aa1:	c3                   	ret    

00801aa2 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  801aa2:	55                   	push   %ebp
  801aa3:	89 e5                	mov    %esp,%ebp
  801aa5:	57                   	push   %edi
  801aa6:	56                   	push   %esi
  801aa7:	53                   	push   %ebx
  801aa8:	83 ec 5c             	sub    $0x5c,%esp
  801aab:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801aae:	8b 75 10             	mov    0x10(%ebp),%esi
  801ab1:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  801ab4:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801abb:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  801abe:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  801ac1:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801ac4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  801acb:	a1 64 60 81 00       	mov    0x816064,%eax
  801ad0:	89 04 24             	mov    %eax,(%esp)
  801ad3:	e8 94 3b 00 00       	call   80566c <sys_sem_wait>

  if (readset)
  801ad8:	85 ff                	test   %edi,%edi
  801ada:	74 07                	je     801ae3 <lwip_select+0x41>
    lreadset = *readset;
  801adc:	8b 07                	mov    (%edi),%eax
  801ade:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801ae1:	eb 1b                	jmp    801afe <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  801ae3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801aea:	00 
  801aeb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801af2:	00 
  801af3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801af6:	89 04 24             	mov    %eax,(%esp)
  801af9:	e8 54 db 00 00       	call   80f652 <memset>
  if (writeset)
  801afe:	85 f6                	test   %esi,%esi
  801b00:	74 07                	je     801b09 <lwip_select+0x67>
    lwriteset = *writeset;
  801b02:	8b 06                	mov    (%esi),%eax
  801b04:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801b07:	eb 1b                	jmp    801b24 <lwip_select+0x82>
  else
    FD_ZERO(&lwriteset);
  801b09:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b10:	00 
  801b11:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b18:	00 
  801b19:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801b1c:	89 04 24             	mov    %eax,(%esp)
  801b1f:	e8 2e db 00 00       	call   80f652 <memset>
  if (exceptset)
  801b24:	85 db                	test   %ebx,%ebx
  801b26:	74 07                	je     801b2f <lwip_select+0x8d>
    lexceptset = *exceptset;
  801b28:	8b 03                	mov    (%ebx),%eax
  801b2a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801b2d:	eb 1b                	jmp    801b4a <lwip_select+0xa8>
  else
    FD_ZERO(&lexceptset);
  801b2f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b36:	00 
  801b37:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b3e:	00 
  801b3f:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b42:	89 04 24             	mov    %eax,(%esp)
  801b45:	e8 08 db 00 00       	call   80f652 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801b4a:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b4d:	89 04 24             	mov    %eax,(%esp)
  801b50:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801b53:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801b56:	8b 45 08             	mov    0x8(%ebp),%eax
  801b59:	e8 b1 f0 ff ff       	call   800c0f <lwip_selscan>
  801b5e:	89 45 b0             	mov    %eax,-0x50(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  801b61:	85 c0                	test   %eax,%eax
  801b63:	0f 85 21 02 00 00    	jne    801d8a <lwip_select+0x2e8>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801b69:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801b6d:	0f 84 86 00 00 00    	je     801bf9 <lwip_select+0x157>
  801b73:	8b 45 18             	mov    0x18(%ebp),%eax
  801b76:	83 38 00             	cmpl   $0x0,(%eax)
  801b79:	0f 85 48 02 00 00    	jne    801dc7 <lwip_select+0x325>
  801b7f:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  801b83:	0f 85 3e 02 00 00    	jne    801dc7 <lwip_select+0x325>
      sys_sem_signal(selectsem);
  801b89:	a1 64 60 81 00       	mov    0x816064,%eax
  801b8e:	89 04 24             	mov    %eax,(%esp)
  801b91:	e8 2b 8c 00 00       	call   80a7c1 <sys_sem_signal>
      if (readset)
  801b96:	85 ff                	test   %edi,%edi
  801b98:	74 18                	je     801bb2 <lwip_select+0x110>
        FD_ZERO(readset);
  801b9a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801ba1:	00 
  801ba2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801ba9:	00 
  801baa:	89 3c 24             	mov    %edi,(%esp)
  801bad:	e8 a0 da 00 00       	call   80f652 <memset>
      if (writeset)
  801bb2:	85 f6                	test   %esi,%esi
  801bb4:	74 18                	je     801bce <lwip_select+0x12c>
        FD_ZERO(writeset);
  801bb6:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801bbd:	00 
  801bbe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801bc5:	00 
  801bc6:	89 34 24             	mov    %esi,(%esp)
  801bc9:	e8 84 da 00 00       	call   80f652 <memset>
      if (exceptset)
  801bce:	85 db                	test   %ebx,%ebx
  801bd0:	74 18                	je     801bea <lwip_select+0x148>
        FD_ZERO(exceptset);
  801bd2:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801bd9:	00 
  801bda:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801be1:	00 
  801be2:	89 1c 24             	mov    %ebx,(%esp)
  801be5:	e8 68 da 00 00       	call   80f652 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  801bea:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  801bf1:	00 00 00 
  
      return 0;
  801bf4:	e9 c3 01 00 00       	jmp    801dbc <lwip_select+0x31a>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801bf9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801c00:	e8 ae 88 00 00       	call   80a4b3 <sys_sem_new>
  801c05:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801c08:	a1 00 63 81 00       	mov    0x816300,%eax
  801c0d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801c10:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801c13:	a3 00 63 81 00       	mov    %eax,0x816300
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801c18:	a1 64 60 81 00       	mov    0x816064,%eax
  801c1d:	89 04 24             	mov    %eax,(%esp)
  801c20:	e8 9c 8b 00 00       	call   80a7c1 <sys_sem_signal>
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  801c25:	b8 00 00 00 00       	mov    $0x0,%eax
  801c2a:	eb 05                	jmp    801c31 <lwip_select+0x18f>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
  801c2c:	b8 01 00 00 00       	mov    $0x1,%eax
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801c31:	89 44 24 04          	mov    %eax,0x4(%esp)
  801c35:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801c38:	89 04 24             	mov    %eax,(%esp)
  801c3b:	e8 ff 3b 00 00       	call   80583f <sys_sem_wait_timeout>
  801c40:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  801c43:	a1 64 60 81 00       	mov    0x816064,%eax
  801c48:	89 04 24             	mov    %eax,(%esp)
  801c4b:	e8 1c 3a 00 00       	call   80566c <sys_sem_wait>
    if (select_cb_list == &select_cb)
  801c50:	a1 00 63 81 00       	mov    0x816300,%eax
  801c55:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  801c58:	39 d0                	cmp    %edx,%eax
  801c5a:	75 1b                	jne    801c77 <lwip_select+0x1d5>
      select_cb_list = select_cb.next;
  801c5c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801c5f:	a3 00 63 81 00       	mov    %eax,0x816300
  801c64:	eb 18                	jmp    801c7e <lwip_select+0x1dc>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  801c66:	8b 10                	mov    (%eax),%edx
  801c68:	39 ca                	cmp    %ecx,%edx
  801c6a:	75 07                	jne    801c73 <lwip_select+0x1d1>
          p_selcb->next = select_cb.next;
  801c6c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801c6f:	89 10                	mov    %edx,(%eax)
          break;
  801c71:	eb 0b                	jmp    801c7e <lwip_select+0x1dc>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801c73:	89 d0                	mov    %edx,%eax
  801c75:	eb 03                	jmp    801c7a <lwip_select+0x1d8>
        if (p_selcb->next == &select_cb) {
  801c77:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801c7a:	85 c0                	test   %eax,%eax
  801c7c:	75 e8                	jne    801c66 <lwip_select+0x1c4>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  801c7e:	a1 64 60 81 00       	mov    0x816064,%eax
  801c83:	89 04 24             	mov    %eax,(%esp)
  801c86:	e8 36 8b 00 00       	call   80a7c1 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  801c8b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801c8e:	89 04 24             	mov    %eax,(%esp)
  801c91:	e8 b9 88 00 00       	call   80a54f <sys_sem_free>
    if (i == 0)  {
  801c96:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801c9a:	75 63                	jne    801cff <lwip_select+0x25d>
      /* Timeout */
      if (readset)
  801c9c:	85 ff                	test   %edi,%edi
  801c9e:	74 18                	je     801cb8 <lwip_select+0x216>
        FD_ZERO(readset);
  801ca0:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801ca7:	00 
  801ca8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801caf:	00 
  801cb0:	89 3c 24             	mov    %edi,(%esp)
  801cb3:	e8 9a d9 00 00       	call   80f652 <memset>
      if (writeset)
  801cb8:	85 f6                	test   %esi,%esi
  801cba:	74 18                	je     801cd4 <lwip_select+0x232>
        FD_ZERO(writeset);
  801cbc:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801cc3:	00 
  801cc4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801ccb:	00 
  801ccc:	89 34 24             	mov    %esi,(%esp)
  801ccf:	e8 7e d9 00 00       	call   80f652 <memset>
      if (exceptset)
  801cd4:	85 db                	test   %ebx,%ebx
  801cd6:	74 18                	je     801cf0 <lwip_select+0x24e>
        FD_ZERO(exceptset);
  801cd8:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801cdf:	00 
  801ce0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801ce7:	00 
  801ce8:	89 1c 24             	mov    %ebx,(%esp)
  801ceb:	e8 62 d9 00 00       	call   80f652 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  801cf0:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  801cf7:	00 00 00 
  
      return 0;
  801cfa:	e9 bd 00 00 00       	jmp    801dbc <lwip_select+0x31a>
    }
    
    if (readset)
  801cff:	85 ff                	test   %edi,%edi
  801d01:	74 07                	je     801d0a <lwip_select+0x268>
      lreadset = *readset;
  801d03:	8b 07                	mov    (%edi),%eax
  801d05:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801d08:	eb 1b                	jmp    801d25 <lwip_select+0x283>
    else
      FD_ZERO(&lreadset);
  801d0a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801d11:	00 
  801d12:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d19:	00 
  801d1a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801d1d:	89 04 24             	mov    %eax,(%esp)
  801d20:	e8 2d d9 00 00       	call   80f652 <memset>
    if (writeset)
  801d25:	85 f6                	test   %esi,%esi
  801d27:	74 07                	je     801d30 <lwip_select+0x28e>
      lwriteset = *writeset;
  801d29:	8b 06                	mov    (%esi),%eax
  801d2b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801d2e:	eb 1b                	jmp    801d4b <lwip_select+0x2a9>
    else
      FD_ZERO(&lwriteset);
  801d30:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801d37:	00 
  801d38:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d3f:	00 
  801d40:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801d43:	89 04 24             	mov    %eax,(%esp)
  801d46:	e8 07 d9 00 00       	call   80f652 <memset>
    if (exceptset)
  801d4b:	85 db                	test   %ebx,%ebx
  801d4d:	74 07                	je     801d56 <lwip_select+0x2b4>
      lexceptset = *exceptset;
  801d4f:	8b 03                	mov    (%ebx),%eax
  801d51:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801d54:	eb 1b                	jmp    801d71 <lwip_select+0x2cf>
    else
      FD_ZERO(&lexceptset);
  801d56:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801d5d:	00 
  801d5e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d65:	00 
  801d66:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801d69:	89 04 24             	mov    %eax,(%esp)
  801d6c:	e8 e1 d8 00 00       	call   80f652 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801d71:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801d74:	89 04 24             	mov    %eax,(%esp)
  801d77:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801d7a:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801d7d:	8b 45 08             	mov    0x8(%ebp),%eax
  801d80:	e8 8a ee ff ff       	call   800c0f <lwip_selscan>
  801d85:	89 45 b0             	mov    %eax,-0x50(%ebp)
  801d88:	eb 0d                	jmp    801d97 <lwip_select+0x2f5>
  } else
    sys_sem_signal(selectsem);
  801d8a:	a1 64 60 81 00       	mov    0x816064,%eax
  801d8f:	89 04 24             	mov    %eax,(%esp)
  801d92:	e8 2a 8a 00 00       	call   80a7c1 <sys_sem_signal>
  
  if (readset)
  801d97:	85 ff                	test   %edi,%edi
  801d99:	74 05                	je     801da0 <lwip_select+0x2fe>
    *readset = lreadset;
  801d9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801d9e:	89 07                	mov    %eax,(%edi)
  if (writeset)
  801da0:	85 f6                	test   %esi,%esi
  801da2:	74 05                	je     801da9 <lwip_select+0x307>
    *writeset = lwriteset;
  801da4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801da7:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801da9:	85 db                	test   %ebx,%ebx
  801dab:	74 05                	je     801db2 <lwip_select+0x310>
    *exceptset = lexceptset;
  801dad:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801db0:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  801db2:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  801db9:	00 00 00 
  
  return nready;
}
  801dbc:	8b 45 b0             	mov    -0x50(%ebp),%eax
  801dbf:	83 c4 5c             	add    $0x5c,%esp
  801dc2:	5b                   	pop    %ebx
  801dc3:	5e                   	pop    %esi
  801dc4:	5f                   	pop    %edi
  801dc5:	5d                   	pop    %ebp
  801dc6:	c3                   	ret    
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801dc7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801dce:	e8 e0 86 00 00       	call   80a4b3 <sys_sem_new>
  801dd3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801dd6:	a1 00 63 81 00       	mov    0x816300,%eax
  801ddb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801dde:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801de1:	a3 00 63 81 00       	mov    %eax,0x816300
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801de6:	a1 64 60 81 00       	mov    0x816064,%eax
  801deb:	89 04 24             	mov    %eax,(%esp)
  801dee:	e8 ce 89 00 00       	call   80a7c1 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801df3:	8b 55 18             	mov    0x18(%ebp),%edx
  801df6:	8b 02                	mov    (%edx),%eax
  801df8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  801dfb:	8d 04 80             	lea    (%eax,%eax,4),%eax
  801dfe:	8d 04 80             	lea    (%eax,%eax,4),%eax
  801e01:	89 45 a8             	mov    %eax,-0x58(%ebp)
  801e04:	8b 52 04             	mov    0x4(%edx),%edx
  801e07:	81 c2 f4 01 00 00    	add    $0x1f4,%edx
  801e0d:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  801e10:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  801e15:	f7 ea                	imul   %edx
  801e17:	89 d1                	mov    %edx,%ecx
  801e19:	c1 f9 06             	sar    $0x6,%ecx
  801e1c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801e1f:	99                   	cltd   
  801e20:	89 c8                	mov    %ecx,%eax
  801e22:	29 d0                	sub    %edx,%eax
  801e24:	8b 4d a8             	mov    -0x58(%ebp),%ecx
  801e27:	8d 04 c8             	lea    (%eax,%ecx,8),%eax
      if(msectimeout == 0)
  801e2a:	85 c0                	test   %eax,%eax
  801e2c:	0f 84 fa fd ff ff    	je     801c2c <lwip_select+0x18a>
  801e32:	e9 fa fd ff ff       	jmp    801c31 <lwip_select+0x18f>

00801e37 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801e37:	55                   	push   %ebp
  801e38:	89 e5                	mov    %esp,%ebp
  801e3a:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801e3d:	8b 45 08             	mov    0x8(%ebp),%eax
  801e40:	89 04 24             	mov    %eax,(%esp)
  801e43:	e8 7b f4 ff ff       	call   8012c3 <lwip_close>
}
  801e48:	c9                   	leave  
  801e49:	c3                   	ret    

00801e4a <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  801e4a:	55                   	push   %ebp
  801e4b:	89 e5                	mov    %esp,%ebp
  801e4d:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801e50:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801e57:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801e5a:	8b 55 0c             	mov    0xc(%ebp),%edx
  801e5d:	8b 45 08             	mov    0x8(%ebp),%eax
  801e60:	e8 dd ee ff ff       	call   800d42 <lwip_getaddrname>
}
  801e65:	c9                   	leave  
  801e66:	c3                   	ret    

00801e67 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  801e67:	55                   	push   %ebp
  801e68:	89 e5                	mov    %esp,%ebp
  801e6a:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801e6d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801e74:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801e77:	8b 55 0c             	mov    0xc(%ebp),%edx
  801e7a:	8b 45 08             	mov    0x8(%ebp),%eax
  801e7d:	e8 c0 ee ff ff       	call   800d42 <lwip_getaddrname>
}
  801e82:	c9                   	leave  
  801e83:	c3                   	ret    

00801e84 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  801e84:	55                   	push   %ebp
  801e85:	89 e5                	mov    %esp,%ebp
  801e87:	57                   	push   %edi
  801e88:	56                   	push   %esi
  801e89:	53                   	push   %ebx
  801e8a:	83 ec 3c             	sub    $0x3c,%esp
  801e8d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801e90:	8b 75 18             	mov    0x18(%ebp),%esi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  801e93:	8b 45 08             	mov    0x8(%ebp),%eax
  801e96:	e8 a5 ea ff ff       	call   800940 <get_socket>
  801e9b:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801e9d:	85 c0                	test   %eax,%eax
  801e9f:	0f 84 62 01 00 00    	je     802007 <lwip_getsockopt+0x183>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  801ea5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801ea9:	74 04                	je     801eaf <lwip_getsockopt+0x2b>
  801eab:	85 f6                	test   %esi,%esi
  801ead:	75 1b                	jne    801eca <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  801eaf:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801eb6:	c7 05 20 c2 b3 00 0e 	movl   $0xe,0xb3c220
  801ebd:	00 00 00 
    return -1;
  801ec0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ec5:	e9 49 01 00 00       	jmp    802013 <lwip_getsockopt+0x18f>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801eca:	83 ff 06             	cmp    $0x6,%edi
  801ecd:	0f 84 8d 00 00 00    	je     801f60 <lwip_getsockopt+0xdc>
  801ed3:	81 ff ff 0f 00 00    	cmp    $0xfff,%edi
  801ed9:	74 09                	je     801ee4 <lwip_getsockopt+0x60>
  801edb:	85 ff                	test   %edi,%edi
  801edd:	74 6d                	je     801f4c <lwip_getsockopt+0xc8>
  801edf:	e9 9f 00 00 00       	jmp    801f83 <lwip_getsockopt+0xff>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801ee4:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801ee8:	74 35                	je     801f1f <lwip_getsockopt+0x9b>
  801eea:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801eee:	7f 12                	jg     801f02 <lwip_getsockopt+0x7e>
  801ef0:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801ef4:	74 29                	je     801f1f <lwip_getsockopt+0x9b>
  801ef6:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801efa:	0f 85 87 00 00 00    	jne    801f87 <lwip_getsockopt+0x103>
  801f00:	eb 1d                	jmp    801f1f <lwip_getsockopt+0x9b>
  801f02:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801f09:	7c 7c                	jl     801f87 <lwip_getsockopt+0x103>
  801f0b:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801f12:	7e 0b                	jle    801f1f <lwip_getsockopt+0x9b>
  801f14:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801f1b:	75 6a                	jne    801f87 <lwip_getsockopt+0x103>
  801f1d:	eb 0b                	jmp    801f2a <lwip_getsockopt+0xa6>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  801f1f:	83 3e 03             	cmpl   $0x3,(%esi)
  801f22:	0f 86 f3 00 00 00    	jbe    80201b <lwip_getsockopt+0x197>
  801f28:	eb 7d                	jmp    801fa7 <lwip_getsockopt+0x123>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801f2a:	83 3e 04             	cmpl   $0x4,(%esi)
  801f2d:	19 c0                	sbb    %eax,%eax
  801f2f:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801f32:	8b 13                	mov    (%ebx),%edx
  801f34:	83 3a 20             	cmpl   $0x20,(%edx)
  801f37:	0f 85 e5 00 00 00    	jne    802022 <lwip_getsockopt+0x19e>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801f3d:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801f40:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801f44:	0f 85 df 00 00 00    	jne    802029 <lwip_getsockopt+0x1a5>
  801f4a:	eb 45                	jmp    801f91 <lwip_getsockopt+0x10d>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801f4c:	8b 45 10             	mov    0x10(%ebp),%eax
  801f4f:	48                   	dec    %eax
  801f50:	83 f8 01             	cmp    $0x1,%eax
  801f53:	77 36                	ja     801f8b <lwip_getsockopt+0x107>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  801f55:	83 3e 03             	cmpl   $0x3,(%esi)
  801f58:	0f 86 d2 00 00 00    	jbe    802030 <lwip_getsockopt+0x1ac>
  801f5e:	eb 47                	jmp    801fa7 <lwip_getsockopt+0x123>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  801f60:	83 3e 03             	cmpl   $0x3,(%esi)
  801f63:	0f 86 ce 00 00 00    	jbe    802037 <lwip_getsockopt+0x1b3>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801f69:	8b 00                	mov    (%eax),%eax
  801f6b:	83 38 10             	cmpl   $0x10,(%eax)
  801f6e:	0f 85 9a 00 00 00    	jne    80200e <lwip_getsockopt+0x18a>
      return 0;

    switch (optname) {
  801f74:	8b 45 10             	mov    0x10(%ebp),%eax
  801f77:	48                   	dec    %eax
  801f78:	83 f8 01             	cmp    $0x1,%eax
  801f7b:	0f 87 bd 00 00 00    	ja     80203e <lwip_getsockopt+0x1ba>
  801f81:	eb 0c                	jmp    801f8f <lwip_getsockopt+0x10b>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  801f83:	b0 5c                	mov    $0x5c,%al
  801f85:	eb 0a                	jmp    801f91 <lwip_getsockopt+0x10d>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801f87:	b0 5c                	mov    $0x5c,%al
  801f89:	eb 06                	jmp    801f91 <lwip_getsockopt+0x10d>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801f8b:	b0 5c                	mov    $0x5c,%al
  801f8d:	eb 02                	jmp    801f91 <lwip_getsockopt+0x10d>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801f8f:	b0 00                	mov    $0x0,%al
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  801f91:	84 c0                	test   %al,%al
  801f93:	74 12                	je     801fa7 <lwip_getsockopt+0x123>
    sock_set_errno(sock, err);
  801f95:	0f be c0             	movsbl %al,%eax
  801f98:	89 43 10             	mov    %eax,0x10(%ebx)
  801f9b:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
    return -1;
  801fa0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fa5:	eb 6c                	jmp    802013 <lwip_getsockopt+0x18f>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  801fa7:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801faa:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  data.optname = optname;
  801fad:	8b 45 10             	mov    0x10(%ebp),%eax
  801fb0:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801fb3:	8b 45 14             	mov    0x14(%ebp),%eax
  801fb6:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801fb9:	89 75 e0             	mov    %esi,-0x20(%ebp)
  data.err = err;
  801fbc:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801fc0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  801fc7:	00 
  801fc8:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801fcb:	89 44 24 04          	mov    %eax,0x4(%esp)
  801fcf:	c7 04 24 84 0a 80 00 	movl   $0x800a84,(%esp)
  801fd6:	e8 09 06 00 00       	call   8025e4 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801fdb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801fe2:	00 
  801fe3:	8b 03                	mov    (%ebx),%eax
  801fe5:	8b 40 10             	mov    0x10(%eax),%eax
  801fe8:	89 04 24             	mov    %eax,(%esp)
  801feb:	e8 35 88 00 00       	call   80a825 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  801ff0:	8a 45 e4             	mov    -0x1c(%ebp),%al

  sock_set_errno(sock, err);
  801ff3:	0f be d0             	movsbl %al,%edx
  801ff6:	89 53 10             	mov    %edx,0x10(%ebx)
  801ff9:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  return err ? -1 : 0;
  801fff:	3c 01                	cmp    $0x1,%al
  802001:	19 c0                	sbb    %eax,%eax
  802003:	f7 d0                	not    %eax
  802005:	eb 0c                	jmp    802013 <lwip_getsockopt+0x18f>
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  802007:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80200c:	eb 05                	jmp    802013 <lwip_getsockopt+0x18f>
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
      return 0;
  80200e:	b8 00 00 00 00       	mov    $0x0,%eax
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  802013:	83 c4 3c             	add    $0x3c,%esp
  802016:	5b                   	pop    %ebx
  802017:	5e                   	pop    %esi
  802018:	5f                   	pop    %edi
  802019:	5d                   	pop    %ebp
  80201a:	c3                   	ret    
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  80201b:	b0 16                	mov    $0x16,%al
  80201d:	e9 73 ff ff ff       	jmp    801f95 <lwip_getsockopt+0x111>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  802022:	b0 61                	mov    $0x61,%al
  802024:	e9 6c ff ff ff       	jmp    801f95 <lwip_getsockopt+0x111>
  802029:	b0 61                	mov    $0x61,%al
  80202b:	e9 65 ff ff ff       	jmp    801f95 <lwip_getsockopt+0x111>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  802030:	b0 16                	mov    $0x16,%al
  802032:	e9 5e ff ff ff       	jmp    801f95 <lwip_getsockopt+0x111>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  802037:	b0 16                	mov    $0x16,%al
  802039:	e9 57 ff ff ff       	jmp    801f95 <lwip_getsockopt+0x111>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  80203e:	b0 5c                	mov    $0x5c,%al
  802040:	e9 50 ff ff ff       	jmp    801f95 <lwip_getsockopt+0x111>

00802045 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  802045:	55                   	push   %ebp
  802046:	89 e5                	mov    %esp,%ebp
  802048:	57                   	push   %edi
  802049:	56                   	push   %esi
  80204a:	53                   	push   %ebx
  80204b:	83 ec 3c             	sub    $0x3c,%esp
  80204e:	8b 75 0c             	mov    0xc(%ebp),%esi
  802051:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  802054:	8b 45 08             	mov    0x8(%ebp),%eax
  802057:	e8 e4 e8 ff ff       	call   800940 <get_socket>
  80205c:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  80205e:	85 c0                	test   %eax,%eax
  802060:	0f 84 40 01 00 00    	je     8021a6 <lwip_setsockopt+0x161>
    return -1;

  if (NULL == optval) {
  802066:	85 ff                	test   %edi,%edi
  802068:	75 1b                	jne    802085 <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  80206a:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  802071:	c7 05 20 c2 b3 00 0e 	movl   $0xe,0xb3c220
  802078:	00 00 00 
    return -1;
  80207b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802080:	e9 2d 01 00 00       	jmp    8021b2 <lwip_setsockopt+0x16d>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  802085:	83 fe 06             	cmp    $0x6,%esi
  802088:	74 6d                	je     8020f7 <lwip_setsockopt+0xb2>
  80208a:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  802090:	74 09                	je     80209b <lwip_setsockopt+0x56>
  802092:	85 f6                	test   %esi,%esi
  802094:	74 4c                	je     8020e2 <lwip_setsockopt+0x9d>
  802096:	e9 80 00 00 00       	jmp    80211b <lwip_setsockopt+0xd6>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80209b:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  80209f:	74 0f                	je     8020b0 <lwip_setsockopt+0x6b>
  8020a1:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8020a8:	74 15                	je     8020bf <lwip_setsockopt+0x7a>
  8020aa:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8020ae:	75 72                	jne    802122 <lwip_setsockopt+0xdd>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  8020b0:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8020b4:	0f 86 00 01 00 00    	jbe    8021ba <lwip_setsockopt+0x175>
  8020ba:	e9 89 00 00 00       	jmp    802148 <lwip_setsockopt+0x103>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  8020bf:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  8020c3:	19 c0                	sbb    %eax,%eax
  8020c5:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8020c8:	8b 13                	mov    (%ebx),%edx
  8020ca:	83 3a 20             	cmpl   $0x20,(%edx)
  8020cd:	0f 85 f1 00 00 00    	jne    8021c4 <lwip_setsockopt+0x17f>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  8020d3:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8020d6:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  8020da:	0f 85 ee 00 00 00    	jne    8021ce <lwip_setsockopt+0x189>
  8020e0:	eb 53                	jmp    802135 <lwip_setsockopt+0xf0>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8020e2:	8b 45 10             	mov    0x10(%ebp),%eax
  8020e5:	48                   	dec    %eax
  8020e6:	83 f8 01             	cmp    $0x1,%eax
  8020e9:	77 3e                	ja     802129 <lwip_setsockopt+0xe4>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  8020eb:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8020ef:	0f 86 e3 00 00 00    	jbe    8021d8 <lwip_setsockopt+0x193>
  8020f5:	eb 51                	jmp    802148 <lwip_setsockopt+0x103>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  8020f7:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8020fb:	0f 86 e1 00 00 00    	jbe    8021e2 <lwip_setsockopt+0x19d>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  802101:	8b 00                	mov    (%eax),%eax
  802103:	83 38 10             	cmpl   $0x10,(%eax)
  802106:	0f 85 a1 00 00 00    	jne    8021ad <lwip_setsockopt+0x168>
      return 0;

    switch (optname) {
  80210c:	8b 45 10             	mov    0x10(%ebp),%eax
  80210f:	48                   	dec    %eax
  802110:	83 f8 01             	cmp    $0x1,%eax
  802113:	0f 87 d3 00 00 00    	ja     8021ec <lwip_setsockopt+0x1a7>
  802119:	eb 15                	jmp    802130 <lwip_setsockopt+0xeb>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  80211b:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802120:	eb 13                	jmp    802135 <lwip_setsockopt+0xf0>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  802122:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802127:	eb 0c                	jmp    802135 <lwip_setsockopt+0xf0>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  802129:	b8 5c 00 00 00       	mov    $0x5c,%eax
  80212e:	eb 05                	jmp    802135 <lwip_setsockopt+0xf0>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  802130:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  802135:	85 c0                	test   %eax,%eax
  802137:	74 0f                	je     802148 <lwip_setsockopt+0x103>
    sock_set_errno(sock, err);
  802139:	89 43 10             	mov    %eax,0x10(%ebx)
  80213c:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
    return -1;
  802141:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802146:	eb 6a                	jmp    8021b2 <lwip_setsockopt+0x16d>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  802148:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  80214b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  80214e:	8b 45 10             	mov    0x10(%ebp),%eax
  802151:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  802154:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  802157:	8d 45 18             	lea    0x18(%ebp),%eax
  80215a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  80215d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  802161:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  802168:	00 
  802169:	8d 45 cc             	lea    -0x34(%ebp),%eax
  80216c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802170:	c7 04 24 7f 09 80 00 	movl   $0x80097f,(%esp)
  802177:	e8 68 04 00 00       	call   8025e4 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  80217c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802183:	00 
  802184:	8b 03                	mov    (%ebx),%eax
  802186:	8b 40 10             	mov    0x10(%eax),%eax
  802189:	89 04 24             	mov    %eax,(%esp)
  80218c:	e8 94 86 00 00       	call   80a825 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  802191:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  802195:	89 43 10             	mov    %eax,0x10(%ebx)
  802198:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  return err ? -1 : 0;
  80219d:	83 f8 01             	cmp    $0x1,%eax
  8021a0:	19 c0                	sbb    %eax,%eax
  8021a2:	f7 d0                	not    %eax
  8021a4:	eb 0c                	jmp    8021b2 <lwip_setsockopt+0x16d>
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  8021a6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8021ab:	eb 05                	jmp    8021b2 <lwip_setsockopt+0x16d>
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
      return 0;
  8021ad:	b8 00 00 00 00       	mov    $0x0,%eax
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  8021b2:	83 c4 3c             	add    $0x3c,%esp
  8021b5:	5b                   	pop    %ebx
  8021b6:	5e                   	pop    %esi
  8021b7:	5f                   	pop    %edi
  8021b8:	5d                   	pop    %ebp
  8021b9:	c3                   	ret    
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  8021ba:	b8 16 00 00 00       	mov    $0x16,%eax
  8021bf:	e9 75 ff ff ff       	jmp    802139 <lwip_setsockopt+0xf4>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  8021c4:	b8 61 00 00 00       	mov    $0x61,%eax
  8021c9:	e9 6b ff ff ff       	jmp    802139 <lwip_setsockopt+0xf4>
  8021ce:	b8 61 00 00 00       	mov    $0x61,%eax
  8021d3:	e9 61 ff ff ff       	jmp    802139 <lwip_setsockopt+0xf4>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  8021d8:	b8 16 00 00 00       	mov    $0x16,%eax
  8021dd:	e9 57 ff ff ff       	jmp    802139 <lwip_setsockopt+0xf4>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  8021e2:	b8 16 00 00 00       	mov    $0x16,%eax
  8021e7:	e9 4d ff ff ff       	jmp    802139 <lwip_setsockopt+0xf4>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  8021ec:	b8 5c 00 00 00       	mov    $0x5c,%eax
  8021f1:	e9 43 ff ff ff       	jmp    802139 <lwip_setsockopt+0xf4>

008021f6 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8021f6:	55                   	push   %ebp
  8021f7:	89 e5                	mov    %esp,%ebp
  8021f9:	56                   	push   %esi
  8021fa:	53                   	push   %ebx
  8021fb:	8b 75 0c             	mov    0xc(%ebp),%esi
  8021fe:	8b 5d 10             	mov    0x10(%ebp),%ebx
  struct lwip_socket *sock = get_socket(s);
  802201:	8b 45 08             	mov    0x8(%ebp),%eax
  802204:	e8 37 e7 ff ff       	call   800940 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  802209:	85 c0                	test   %eax,%eax
  80220b:	0f 84 a6 00 00 00    	je     8022b7 <lwip_ioctl+0xc1>
    return -1;

  switch (cmd) {
  802211:	81 fe 7e 66 04 80    	cmp    $0x8004667e,%esi
  802217:	74 57                	je     802270 <lwip_ioctl+0x7a>
  802219:	81 fe 7f 66 04 40    	cmp    $0x4004667f,%esi
  80221f:	75 7e                	jne    80229f <lwip_ioctl+0xa9>
  case FIONREAD:
    if (!argp) {
  802221:	85 db                	test   %ebx,%ebx
  802223:	75 18                	jne    80223d <lwip_ioctl+0x47>
      sock_set_errno(sock, EINVAL);
  802225:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  80222c:	c7 05 20 c2 b3 00 16 	movl   $0x16,0xb3c220
  802233:	00 00 00 
      return -1;
  802236:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80223b:	eb 7f                	jmp    8022bc <lwip_ioctl+0xc6>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  80223d:	8b 10                	mov    (%eax),%edx
  80223f:	8b 52 20             	mov    0x20(%edx),%edx
  802242:	66 89 13             	mov    %dx,(%ebx)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  802245:	8b 48 04             	mov    0x4(%eax),%ecx
  802248:	85 c9                	test   %ecx,%ecx
  80224a:	74 0c                	je     802258 <lwip_ioctl+0x62>
      buflen = netbuf_len(sock->lastdata);
  80224c:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;
  80224e:	03 51 08             	add    0x8(%ecx),%edx

      *((u16_t*)argp) += buflen;
  802251:	66 2b 50 08          	sub    0x8(%eax),%dx
  802255:	66 89 13             	mov    %dx,(%ebx)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  802258:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  80225f:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  802266:	00 00 00 
    return 0;
  802269:	b8 00 00 00 00       	mov    $0x0,%eax
  80226e:	eb 4c                	jmp    8022bc <lwip_ioctl+0xc6>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  802270:	85 db                	test   %ebx,%ebx
  802272:	74 0d                	je     802281 <lwip_ioctl+0x8b>
  802274:	83 3b 00             	cmpl   $0x0,(%ebx)
  802277:	74 08                	je     802281 <lwip_ioctl+0x8b>
      sock->flags |= O_NONBLOCK;
  802279:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  80227f:	eb 06                	jmp    802287 <lwip_ioctl+0x91>
    else
      sock->flags &= ~O_NONBLOCK;
  802281:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  802287:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  80228e:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  802295:	00 00 00 
    return 0;
  802298:	b8 00 00 00 00       	mov    $0x0,%eax
  80229d:	eb 1d                	jmp    8022bc <lwip_ioctl+0xc6>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  80229f:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  8022a6:	c7 05 20 c2 b3 00 26 	movl   $0x26,0xb3c220
  8022ad:	00 00 00 
    return -1;
  8022b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022b5:	eb 05                	jmp    8022bc <lwip_ioctl+0xc6>
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
    return -1;
  8022b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  8022bc:	5b                   	pop    %ebx
  8022bd:	5e                   	pop    %esi
  8022be:	5d                   	pop    %ebp
  8022bf:	c3                   	ret    

008022c0 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8022c0:	55                   	push   %ebp
  8022c1:	89 e5                	mov    %esp,%ebp
  8022c3:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  8022c6:	8b 45 08             	mov    0x8(%ebp),%eax
  8022c9:	89 04 24             	mov    %eax,(%esp)
  8022cc:	e8 80 2a 00 00       	call   804d51 <pbuf_free>
}
  8022d1:	c9                   	leave  
  8022d2:	c3                   	ret    

008022d3 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  8022d3:	55                   	push   %ebp
  8022d4:	89 e5                	mov    %esp,%ebp
  8022d6:	53                   	push   %ebx
  8022d7:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8022da:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8022e1:	00 
  8022e2:	c7 44 24 04 be 24 80 	movl   $0x8024be,0x4(%esp)
  8022e9:	00 
  8022ea:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  8022f1:	e8 03 34 00 00       	call   8056f9 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8022f6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8022fd:	00 
  8022fe:	c7 44 24 04 95 24 80 	movl   $0x802495,0x4(%esp)
  802305:	00 
  802306:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  80230d:	e8 e7 33 00 00       	call   8056f9 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802312:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802319:	00 
  80231a:	c7 44 24 04 6c 24 80 	movl   $0x80246c,0x4(%esp)
  802321:	00 
  802322:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  802329:	e8 cb 33 00 00       	call   8056f9 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80232e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802335:	00 
  802336:	c7 44 24 04 43 24 80 	movl   $0x802443,0x4(%esp)
  80233d:	00 
  80233e:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  802345:	e8 af 33 00 00       	call   8056f9 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80234a:	a1 08 63 81 00       	mov    0x816308,%eax
  80234f:	85 c0                	test   %eax,%eax
  802351:	74 0b                	je     80235e <tcpip_thread+0x8b>
    tcpip_init_done(tcpip_init_done_arg);
  802353:	8b 15 0c 63 81 00    	mov    0x81630c,%edx
  802359:	89 14 24             	mov    %edx,(%esp)
  80235c:	ff d0                	call   *%eax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  80235e:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  802361:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802365:	a1 00 50 81 00       	mov    0x815000,%eax
  80236a:	89 04 24             	mov    %eax,(%esp)
  80236d:	e8 5f 32 00 00       	call   8055d1 <sys_mbox_fetch>
    switch (msg->type) {
  802372:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802375:	8b 10                	mov    (%eax),%edx
  802377:	83 fa 01             	cmp    $0x1,%edx
  80237a:	74 1e                	je     80239a <tcpip_thread+0xc7>
  80237c:	83 fa 01             	cmp    $0x1,%edx
  80237f:	72 0c                	jb     80238d <tcpip_thread+0xba>
  802381:	83 fa 02             	cmp    $0x2,%edx
  802384:	74 52                	je     8023d8 <tcpip_thread+0x105>
  802386:	83 fa 03             	cmp    $0x3,%edx
  802389:	75 d6                	jne    802361 <tcpip_thread+0x8e>
  80238b:	eb 6c                	jmp    8023f9 <tcpip_thread+0x126>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  80238d:	8b 40 08             	mov    0x8(%eax),%eax
  802390:	8d 50 04             	lea    0x4(%eax),%edx
  802393:	89 14 24             	mov    %edx,(%esp)
  802396:	ff 10                	call   *(%eax)
      break;
  802398:	eb c7                	jmp    802361 <tcpip_thread+0x8e>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  80239a:	8b 50 0c             	mov    0xc(%eax),%edx
  80239d:	f6 42 2e 20          	testb  $0x20,0x2e(%edx)
  8023a1:	74 11                	je     8023b4 <tcpip_thread+0xe1>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  8023a3:	89 54 24 04          	mov    %edx,0x4(%esp)
  8023a7:	8b 40 08             	mov    0x8(%eax),%eax
  8023aa:	89 04 24             	mov    %eax,(%esp)
  8023ad:	e8 44 7f 00 00       	call   80a2f6 <ethernet_input>
  8023b2:	eb 0f                	jmp    8023c3 <tcpip_thread+0xf0>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8023b4:	89 54 24 04          	mov    %edx,0x4(%esp)
  8023b8:	8b 40 08             	mov    0x8(%eax),%eax
  8023bb:	89 04 24             	mov    %eax,(%esp)
  8023be:	e8 70 46 00 00       	call   806a33 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8023c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8023c6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023ca:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8023d1:	e8 f0 25 00 00       	call   8049c6 <memp_free>
      break;
  8023d6:	eb 89                	jmp    802361 <tcpip_thread+0x8e>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8023d8:	8b 50 0c             	mov    0xc(%eax),%edx
  8023db:	89 14 24             	mov    %edx,(%esp)
  8023de:	ff 50 08             	call   *0x8(%eax)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8023e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8023e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023e8:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8023ef:	e8 d2 25 00 00       	call   8049c6 <memp_free>
      break;
  8023f4:	e9 68 ff ff ff       	jmp    802361 <tcpip_thread+0x8e>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8023f9:	8b 50 08             	mov    0x8(%eax),%edx
  8023fc:	83 fa ff             	cmp    $0xffffffff,%edx
  8023ff:	74 18                	je     802419 <tcpip_thread+0x146>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  802401:	8b 48 10             	mov    0x10(%eax),%ecx
  802404:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  802408:	8b 40 0c             	mov    0xc(%eax),%eax
  80240b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80240f:	89 14 24             	mov    %edx,(%esp)
  802412:	e8 e2 32 00 00       	call   8056f9 <sys_timeout>
  802417:	eb 12                	jmp    80242b <tcpip_thread+0x158>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  802419:	8b 50 10             	mov    0x10(%eax),%edx
  80241c:	89 54 24 04          	mov    %edx,0x4(%esp)
  802420:	8b 40 0c             	mov    0xc(%eax),%eax
  802423:	89 04 24             	mov    %eax,(%esp)
  802426:	e8 8b 33 00 00       	call   8057b6 <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80242b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80242e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802432:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802439:	e8 88 25 00 00       	call   8049c6 <memp_free>
      break;
  80243e:	e9 1e ff ff ff       	jmp    802361 <tcpip_thread+0x8e>

00802443 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  802443:	55                   	push   %ebp
  802444:	89 e5                	mov    %esp,%ebp
  802446:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  802449:	e8 41 1d 00 00       	call   80418f <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80244e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802455:	00 
  802456:	c7 44 24 04 43 24 80 	movl   $0x802443,0x4(%esp)
  80245d:	00 
  80245e:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  802465:	e8 8f 32 00 00       	call   8056f9 <sys_timeout>
}
  80246a:	c9                   	leave  
  80246b:	c3                   	ret    

0080246c <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  80246c:	55                   	push   %ebp
  80246d:	89 e5                	mov    %esp,%ebp
  80246f:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  802472:	e8 31 1b 00 00       	call   803fa8 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802477:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80247e:	00 
  80247f:	c7 44 24 04 6c 24 80 	movl   $0x80246c,0x4(%esp)
  802486:	00 
  802487:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80248e:	e8 66 32 00 00       	call   8056f9 <sys_timeout>
}
  802493:	c9                   	leave  
  802494:	c3                   	ret    

00802495 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  802495:	55                   	push   %ebp
  802496:	89 e5                	mov    %esp,%ebp
  802498:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  80249b:	e8 f1 76 00 00       	call   809b91 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8024a0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024a7:	00 
  8024a8:	c7 44 24 04 95 24 80 	movl   $0x802495,0x4(%esp)
  8024af:	00 
  8024b0:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8024b7:	e8 3d 32 00 00       	call   8056f9 <sys_timeout>
}
  8024bc:	c9                   	leave  
  8024bd:	c3                   	ret    

008024be <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  8024be:	55                   	push   %ebp
  8024bf:	89 e5                	mov    %esp,%ebp
  8024c1:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  8024c4:	e8 12 4c 00 00       	call   8070db <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8024c9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024d0:	00 
  8024d1:	c7 44 24 04 be 24 80 	movl   $0x8024be,0x4(%esp)
  8024d8:	00 
  8024d9:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  8024e0:	e8 14 32 00 00       	call   8056f9 <sys_timeout>
}
  8024e5:	c9                   	leave  
  8024e6:	c3                   	ret    

008024e7 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  8024e7:	55                   	push   %ebp
  8024e8:	89 e5                	mov    %esp,%ebp
  8024ea:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  8024ed:	e8 bd 3f 00 00       	call   8064af <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8024f2:	83 3d 7c c2 b3 00 00 	cmpl   $0x0,0xb3c27c
  8024f9:	75 09                	jne    802504 <tcpip_tcp_timer+0x1d>
  8024fb:	83 3d 90 c2 b3 00 00 	cmpl   $0x0,0xb3c290
  802502:	74 1e                	je     802522 <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802504:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80250b:	00 
  80250c:	c7 44 24 04 e7 24 80 	movl   $0x8024e7,0x4(%esp)
  802513:	00 
  802514:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80251b:	e8 d9 31 00 00       	call   8056f9 <sys_timeout>
  802520:	eb 0a                	jmp    80252c <tcpip_tcp_timer+0x45>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  802522:	c7 05 04 63 81 00 00 	movl   $0x0,0x816304
  802529:	00 00 00 
  }
}
  80252c:	c9                   	leave  
  80252d:	c3                   	ret    

0080252e <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  80252e:	55                   	push   %ebp
  80252f:	89 e5                	mov    %esp,%ebp
  802531:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802534:	83 3d 04 63 81 00 00 	cmpl   $0x0,0x816304
  80253b:	75 38                	jne    802575 <tcp_timer_needed+0x47>
  80253d:	83 3d 7c c2 b3 00 00 	cmpl   $0x0,0xb3c27c
  802544:	75 09                	jne    80254f <tcp_timer_needed+0x21>
  802546:	83 3d 90 c2 b3 00 00 	cmpl   $0x0,0xb3c290
  80254d:	74 26                	je     802575 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  80254f:	c7 05 04 63 81 00 01 	movl   $0x1,0x816304
  802556:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802559:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802560:	00 
  802561:	c7 44 24 04 e7 24 80 	movl   $0x8024e7,0x4(%esp)
  802568:	00 
  802569:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  802570:	e8 84 31 00 00       	call   8056f9 <sys_timeout>
  }
}
  802575:	c9                   	leave  
  802576:	c3                   	ret    

00802577 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  802577:	55                   	push   %ebp
  802578:	89 e5                	mov    %esp,%ebp
  80257a:	53                   	push   %ebx
  80257b:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80257e:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  802585:	74 4d                	je     8025d4 <tcpip_input+0x5d>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  802587:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  80258e:	e8 d3 23 00 00       	call   804966 <memp_malloc>
  802593:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802595:	85 c0                	test   %eax,%eax
  802597:	74 3f                	je     8025d8 <tcpip_input+0x61>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  802599:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  80259f:	8b 45 08             	mov    0x8(%ebp),%eax
  8025a2:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8025a5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8025a8:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8025ab:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8025af:	a1 00 50 81 00       	mov    0x815000,%eax
  8025b4:	89 04 24             	mov    %eax,(%esp)
  8025b7:	e8 7e 83 00 00       	call   80a93a <sys_mbox_trypost>
  8025bc:	84 c0                	test   %al,%al
  8025be:	74 1c                	je     8025dc <tcpip_input+0x65>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8025c0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8025c4:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8025cb:	e8 f6 23 00 00       	call   8049c6 <memp_free>
      return ERR_MEM;
  8025d0:	b0 ff                	mov    $0xff,%al
  8025d2:	eb 0a                	jmp    8025de <tcpip_input+0x67>
    }
    return ERR_OK;
  }
  return ERR_VAL;
  8025d4:	b0 f7                	mov    $0xf7,%al
  8025d6:	eb 06                	jmp    8025de <tcpip_input+0x67>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
  8025d8:	b0 ff                	mov    $0xff,%al
  8025da:	eb 02                	jmp    8025de <tcpip_input+0x67>
    msg->msg.inp.netif = inp;
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
      return ERR_MEM;
    }
    return ERR_OK;
  8025dc:	b0 00                	mov    $0x0,%al
  }
  return ERR_VAL;
}
  8025de:	83 c4 14             	add    $0x14,%esp
  8025e1:	5b                   	pop    %ebx
  8025e2:	5d                   	pop    %ebp
  8025e3:	c3                   	ret    

008025e4 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  8025e4:	55                   	push   %ebp
  8025e5:	89 e5                	mov    %esp,%ebp
  8025e7:	53                   	push   %ebx
  8025e8:	83 ec 24             	sub    $0x24,%esp
  8025eb:	8a 45 10             	mov    0x10(%ebp),%al
  8025ee:	88 45 f7             	mov    %al,-0x9(%ebp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8025f1:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  8025f8:	74 68                	je     802662 <tcpip_callback_with_block+0x7e>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8025fa:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802601:	e8 60 23 00 00       	call   804966 <memp_malloc>
  802606:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802608:	85 c0                	test   %eax,%eax
  80260a:	74 5a                	je     802666 <tcpip_callback_with_block+0x82>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  80260c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  802612:	8b 45 08             	mov    0x8(%ebp),%eax
  802615:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802618:	8b 45 0c             	mov    0xc(%ebp),%eax
  80261b:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  80261e:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  802622:	74 15                	je     802639 <tcpip_callback_with_block+0x55>
      sys_mbox_post(mbox, msg);
  802624:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802628:	a1 00 50 81 00       	mov    0x815000,%eax
  80262d:	89 04 24             	mov    %eax,(%esp)
  802630:	e8 f6 83 00 00       	call   80aa2b <sys_mbox_post>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  802635:	b0 00                	mov    $0x0,%al
  802637:	eb 33                	jmp    80266c <tcpip_callback_with_block+0x88>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  802639:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80263d:	a1 00 50 81 00       	mov    0x815000,%eax
  802642:	89 04 24             	mov    %eax,(%esp)
  802645:	e8 f0 82 00 00       	call   80a93a <sys_mbox_trypost>
  80264a:	84 c0                	test   %al,%al
  80264c:	74 1c                	je     80266a <tcpip_callback_with_block+0x86>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  80264e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802652:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802659:	e8 68 23 00 00       	call   8049c6 <memp_free>
        return ERR_MEM;
  80265e:	b0 ff                	mov    $0xff,%al
  802660:	eb 0a                	jmp    80266c <tcpip_callback_with_block+0x88>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  802662:	b0 f7                	mov    $0xf7,%al
  802664:	eb 06                	jmp    80266c <tcpip_callback_with_block+0x88>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  802666:	b0 ff                	mov    $0xff,%al
  802668:	eb 02                	jmp    80266c <tcpip_callback_with_block+0x88>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  80266a:	b0 00                	mov    $0x0,%al
  }
  return ERR_VAL;
}
  80266c:	83 c4 24             	add    $0x24,%esp
  80266f:	5b                   	pop    %ebx
  802670:	5d                   	pop    %ebp
  802671:	c3                   	ret    

00802672 <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  802672:	55                   	push   %ebp
  802673:	89 e5                	mov    %esp,%ebp
  802675:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  802678:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  80267f:	74 3d                	je     8026be <tcpip_timeout+0x4c>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802681:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802688:	e8 d9 22 00 00       	call   804966 <memp_malloc>
    if (msg == NULL) {
  80268d:	85 c0                	test   %eax,%eax
  80268f:	74 31                	je     8026c2 <tcpip_timeout+0x50>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  802691:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  802697:	8b 55 08             	mov    0x8(%ebp),%edx
  80269a:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  80269d:	8b 55 0c             	mov    0xc(%ebp),%edx
  8026a0:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8026a3:	8b 55 10             	mov    0x10(%ebp),%edx
  8026a6:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8026a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8026ad:	a1 00 50 81 00       	mov    0x815000,%eax
  8026b2:	89 04 24             	mov    %eax,(%esp)
  8026b5:	e8 71 83 00 00       	call   80aa2b <sys_mbox_post>
    return ERR_OK;
  8026ba:	b0 00                	mov    $0x0,%al
  8026bc:	eb 06                	jmp    8026c4 <tcpip_timeout+0x52>
  }
  return ERR_VAL;
  8026be:	b0 f7                	mov    $0xf7,%al
  8026c0:	eb 02                	jmp    8026c4 <tcpip_timeout+0x52>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  8026c2:	b0 ff                	mov    $0xff,%al
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
  8026c4:	c9                   	leave  
  8026c5:	c3                   	ret    

008026c6 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  8026c6:	55                   	push   %ebp
  8026c7:	89 e5                	mov    %esp,%ebp
  8026c9:	53                   	push   %ebx
  8026ca:	83 ec 34             	sub    $0x34,%esp
  8026cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8026d0:	a1 00 50 81 00       	mov    0x815000,%eax
  8026d5:	83 f8 ff             	cmp    $0xffffffff,%eax
  8026d8:	74 33                	je     80270d <tcpip_apimsg+0x47>
    msg.type = TCPIP_MSG_API;
  8026da:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  8026e1:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  8026e4:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8026e7:	89 54 24 04          	mov    %edx,0x4(%esp)
  8026eb:	89 04 24             	mov    %eax,(%esp)
  8026ee:	e8 38 83 00 00       	call   80aa2b <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  8026f3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8026fa:	00 
  8026fb:	8b 43 04             	mov    0x4(%ebx),%eax
  8026fe:	8b 40 10             	mov    0x10(%eax),%eax
  802701:	89 04 24             	mov    %eax,(%esp)
  802704:	e8 1c 81 00 00       	call   80a825 <sys_arch_sem_wait>
    return ERR_OK;
  802709:	b0 00                	mov    $0x0,%al
  80270b:	eb 02                	jmp    80270f <tcpip_apimsg+0x49>
  }
  return ERR_VAL;
  80270d:	b0 f7                	mov    $0xf7,%al
}
  80270f:	83 c4 34             	add    $0x34,%esp
  802712:	5b                   	pop    %ebx
  802713:	5d                   	pop    %ebp
  802714:	c3                   	ret    

00802715 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  802715:	55                   	push   %ebp
  802716:	89 e5                	mov    %esp,%ebp
  802718:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  80271b:	e8 e8 03 00 00       	call   802b08 <lwip_init>

  tcpip_init_done = initfunc;
  802720:	8b 45 08             	mov    0x8(%ebp),%eax
  802723:	a3 08 63 81 00       	mov    %eax,0x816308
  tcpip_init_done_arg = arg;
  802728:	8b 45 0c             	mov    0xc(%ebp),%eax
  80272b:	a3 0c 63 81 00       	mov    %eax,0x81630c
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  802730:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802737:	e8 50 7f 00 00       	call   80a68c <sys_mbox_new>
  80273c:	a3 00 50 81 00       	mov    %eax,0x815000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  802741:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  802748:	00 
  802749:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  802750:	00 
  802751:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802758:	00 
  802759:	c7 44 24 04 d3 22 80 	movl   $0x8022d3,0x4(%esp)
  802760:	00 
  802761:	c7 04 24 fc 1c 81 00 	movl   $0x811cfc,(%esp)
  802768:	e8 2d 84 00 00       	call   80ab9a <sys_thread_new>
}
  80276d:	c9                   	leave  
  80276e:	c3                   	ret    

0080276f <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  80276f:	55                   	push   %ebp
  802770:	89 e5                	mov    %esp,%ebp
  802772:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  802775:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80277c:	00 
  80277d:	8b 45 08             	mov    0x8(%ebp),%eax
  802780:	89 44 24 04          	mov    %eax,0x4(%esp)
  802784:	c7 04 24 c0 22 80 00 	movl   $0x8022c0,(%esp)
  80278b:	e8 54 fe ff ff       	call   8025e4 <tcpip_callback_with_block>
}
  802790:	c9                   	leave  
  802791:	c3                   	ret    

00802792 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  802792:	55                   	push   %ebp
  802793:	89 e5                	mov    %esp,%ebp
  802795:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  802798:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80279f:	00 
  8027a0:	8b 45 08             	mov    0x8(%ebp),%eax
  8027a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027a7:	c7 04 24 44 44 80 00 	movl   $0x804444,(%esp)
  8027ae:	e8 31 fe ff ff       	call   8025e4 <tcpip_callback_with_block>
}
  8027b3:	c9                   	leave  
  8027b4:	c3                   	ret    
  8027b5:	00 00                	add    %al,(%eax)
	...

008027b8 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8027b8:	55                   	push   %ebp
  8027b9:	89 e5                	mov    %esp,%ebp
  8027bb:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8027be:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8027c5:	e8 9c 21 00 00       	call   804966 <memp_malloc>
  if (buf != NULL) {
  8027ca:	85 c0                	test   %eax,%eax
  8027cc:	74 14                	je     8027e2 <netbuf_new+0x2a>
    buf->p = NULL;
  8027ce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8027d4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8027db:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  8027e2:	c9                   	leave  
  8027e3:	c3                   	ret    

008027e4 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8027e4:	55                   	push   %ebp
  8027e5:	89 e5                	mov    %esp,%ebp
  8027e7:	53                   	push   %ebx
  8027e8:	83 ec 14             	sub    $0x14,%esp
  8027eb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  8027ee:	85 db                	test   %ebx,%ebx
  8027f0:	74 2b                	je     80281d <netbuf_delete+0x39>
    if (buf->p != NULL) {
  8027f2:	8b 03                	mov    (%ebx),%eax
  8027f4:	85 c0                	test   %eax,%eax
  8027f6:	74 15                	je     80280d <netbuf_delete+0x29>
      pbuf_free(buf->p);
  8027f8:	89 04 24             	mov    %eax,(%esp)
  8027fb:	e8 51 25 00 00       	call   804d51 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802800:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802807:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  80280d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802811:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  802818:	e8 a9 21 00 00       	call   8049c6 <memp_free>
  }
}
  80281d:	83 c4 14             	add    $0x14,%esp
  802820:	5b                   	pop    %ebx
  802821:	5d                   	pop    %ebp
  802822:	c3                   	ret    

00802823 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802823:	55                   	push   %ebp
  802824:	89 e5                	mov    %esp,%ebp
  802826:	56                   	push   %esi
  802827:	53                   	push   %ebx
  802828:	83 ec 10             	sub    $0x10,%esp
  80282b:	8b 75 08             	mov    0x8(%ebp),%esi
  80282e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802831:	85 f6                	test   %esi,%esi
  802833:	75 1c                	jne    802851 <netbuf_alloc+0x2e>
  802835:	c7 44 24 08 09 1d 81 	movl   $0x811d09,0x8(%esp)
  80283c:	00 
  80283d:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  802844:	00 
  802845:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  80284c:	e8 2f c6 00 00       	call   80ee80 <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802851:	8b 06                	mov    (%esi),%eax
  802853:	85 c0                	test   %eax,%eax
  802855:	74 08                	je     80285f <netbuf_alloc+0x3c>
    pbuf_free(buf->p);
  802857:	89 04 24             	mov    %eax,(%esp)
  80285a:	e8 f2 24 00 00       	call   804d51 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  80285f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802866:	00 
  802867:	0f b7 c3             	movzwl %bx,%eax
  80286a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80286e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802875:	e8 d8 26 00 00       	call   804f52 <pbuf_alloc>
  80287a:	89 06                	mov    %eax,(%esi)
  if (buf->p == NULL) {
  80287c:	85 c0                	test   %eax,%eax
  80287e:	74 2a                	je     8028aa <netbuf_alloc+0x87>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  802880:	66 3b 58 0a          	cmp    0xa(%eax),%bx
  802884:	76 1c                	jbe    8028a2 <netbuf_alloc+0x7f>
  802886:	c7 44 24 08 f0 1d 81 	movl   $0x811df0,0x8(%esp)
  80288d:	00 
  80288e:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  802895:	00 
  802896:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  80289d:	e8 de c5 00 00       	call   80ee80 <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8028a2:	89 46 04             	mov    %eax,0x4(%esi)
  return buf->p->payload;
  8028a5:	8b 40 04             	mov    0x4(%eax),%eax
  8028a8:	eb 05                	jmp    8028af <netbuf_alloc+0x8c>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  8028aa:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  8028af:	83 c4 10             	add    $0x10,%esp
  8028b2:	5b                   	pop    %ebx
  8028b3:	5e                   	pop    %esi
  8028b4:	5d                   	pop    %ebp
  8028b5:	c3                   	ret    

008028b6 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8028b6:	55                   	push   %ebp
  8028b7:	89 e5                	mov    %esp,%ebp
  8028b9:	53                   	push   %ebx
  8028ba:	83 ec 14             	sub    $0x14,%esp
  8028bd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8028c0:	85 db                	test   %ebx,%ebx
  8028c2:	75 1c                	jne    8028e0 <netbuf_free+0x2a>
  8028c4:	c7 44 24 08 39 1d 81 	movl   $0x811d39,0x8(%esp)
  8028cb:	00 
  8028cc:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  8028d3:	00 
  8028d4:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  8028db:	e8 a0 c5 00 00       	call   80ee80 <_panic>
  if (buf->p != NULL) {
  8028e0:	8b 03                	mov    (%ebx),%eax
  8028e2:	85 c0                	test   %eax,%eax
  8028e4:	74 08                	je     8028ee <netbuf_free+0x38>
    pbuf_free(buf->p);
  8028e6:	89 04 24             	mov    %eax,(%esp)
  8028e9:	e8 63 24 00 00       	call   804d51 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  8028ee:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8028f5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8028fb:	83 c4 14             	add    $0x14,%esp
  8028fe:	5b                   	pop    %ebx
  8028ff:	5d                   	pop    %ebp
  802900:	c3                   	ret    

00802901 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802901:	55                   	push   %ebp
  802902:	89 e5                	mov    %esp,%ebp
  802904:	56                   	push   %esi
  802905:	53                   	push   %ebx
  802906:	83 ec 10             	sub    $0x10,%esp
  802909:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80290c:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  80290f:	85 db                	test   %ebx,%ebx
  802911:	75 1c                	jne    80292f <netbuf_ref+0x2e>
  802913:	c7 44 24 08 52 1d 81 	movl   $0x811d52,0x8(%esp)
  80291a:	00 
  80291b:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  802922:	00 
  802923:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  80292a:	e8 51 c5 00 00       	call   80ee80 <_panic>
  if (buf->p != NULL) {
  80292f:	8b 03                	mov    (%ebx),%eax
  802931:	85 c0                	test   %eax,%eax
  802933:	74 08                	je     80293d <netbuf_ref+0x3c>
    pbuf_free(buf->p);
  802935:	89 04 24             	mov    %eax,(%esp)
  802938:	e8 14 24 00 00       	call   804d51 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80293d:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  802944:	00 
  802945:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80294c:	00 
  80294d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802954:	e8 f9 25 00 00       	call   804f52 <pbuf_alloc>
  802959:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80295b:	85 c0                	test   %eax,%eax
  80295d:	75 0b                	jne    80296a <netbuf_ref+0x69>
    buf->ptr = NULL;
  80295f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  802966:	b0 ff                	mov    $0xff,%al
  802968:	eb 17                	jmp    802981 <netbuf_ref+0x80>
  }
  buf->p->payload = (void*)dataptr;
  80296a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80296d:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802970:	8b 03                	mov    (%ebx),%eax
  802972:	66 89 70 08          	mov    %si,0x8(%eax)
  802976:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  80297a:	8b 03                	mov    (%ebx),%eax
  80297c:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  80297f:	b0 00                	mov    $0x0,%al
}
  802981:	83 c4 10             	add    $0x10,%esp
  802984:	5b                   	pop    %ebx
  802985:	5e                   	pop    %esi
  802986:	5d                   	pop    %ebp
  802987:	c3                   	ret    

00802988 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  802988:	55                   	push   %ebp
  802989:	89 e5                	mov    %esp,%ebp
  80298b:	56                   	push   %esi
  80298c:	53                   	push   %ebx
  80298d:	83 ec 10             	sub    $0x10,%esp
  802990:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802993:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  802996:	85 db                	test   %ebx,%ebx
  802998:	75 1c                	jne    8029b6 <netbuf_chain+0x2e>
  80299a:	c7 44 24 08 6a 1d 81 	movl   $0x811d6a,0x8(%esp)
  8029a1:	00 
  8029a2:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  8029a9:	00 
  8029aa:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  8029b1:	e8 ca c4 00 00       	call   80ee80 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8029b6:	85 f6                	test   %esi,%esi
  8029b8:	75 1c                	jne    8029d6 <netbuf_chain+0x4e>
  8029ba:	c7 44 24 08 83 1d 81 	movl   $0x811d83,0x8(%esp)
  8029c1:	00 
  8029c2:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  8029c9:	00 
  8029ca:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  8029d1:	e8 aa c4 00 00       	call   80ee80 <_panic>
  pbuf_chain(head->p, tail->p);
  8029d6:	8b 06                	mov    (%esi),%eax
  8029d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8029dc:	8b 03                	mov    (%ebx),%eax
  8029de:	89 04 24             	mov    %eax,(%esp)
  8029e1:	e8 89 28 00 00       	call   80526f <pbuf_chain>
  head->ptr = head->p;
  8029e6:	8b 03                	mov    (%ebx),%eax
  8029e8:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8029eb:	89 74 24 04          	mov    %esi,0x4(%esp)
  8029ef:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8029f6:	e8 cb 1f 00 00       	call   8049c6 <memp_free>
}
  8029fb:	83 c4 10             	add    $0x10,%esp
  8029fe:	5b                   	pop    %ebx
  8029ff:	5e                   	pop    %esi
  802a00:	5d                   	pop    %ebp
  802a01:	c3                   	ret    

00802a02 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  802a02:	55                   	push   %ebp
  802a03:	89 e5                	mov    %esp,%ebp
  802a05:	53                   	push   %ebx
  802a06:	83 ec 14             	sub    $0x14,%esp
  802a09:	8b 45 08             	mov    0x8(%ebp),%eax
  802a0c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  802a0f:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802a12:	85 c0                	test   %eax,%eax
  802a14:	75 1c                	jne    802a32 <netbuf_data+0x30>
  802a16:	c7 44 24 08 9e 1d 81 	movl   $0x811d9e,0x8(%esp)
  802a1d:	00 
  802a1e:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  802a25:	00 
  802a26:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  802a2d:	e8 4e c4 00 00       	call   80ee80 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802a32:	85 c9                	test   %ecx,%ecx
  802a34:	75 1c                	jne    802a52 <netbuf_data+0x50>
  802a36:	c7 44 24 08 b7 1d 81 	movl   $0x811db7,0x8(%esp)
  802a3d:	00 
  802a3e:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  802a45:	00 
  802a46:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  802a4d:	e8 2e c4 00 00       	call   80ee80 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802a52:	85 d2                	test   %edx,%edx
  802a54:	75 1c                	jne    802a72 <netbuf_data+0x70>
  802a56:	c7 44 24 08 d4 1d 81 	movl   $0x811dd4,0x8(%esp)
  802a5d:	00 
  802a5e:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  802a65:	00 
  802a66:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  802a6d:	e8 0e c4 00 00       	call   80ee80 <_panic>

  if (buf->ptr == NULL) {
  802a72:	8b 58 04             	mov    0x4(%eax),%ebx
  802a75:	85 db                	test   %ebx,%ebx
  802a77:	74 13                	je     802a8c <netbuf_data+0x8a>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802a79:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802a7c:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802a7e:	8b 40 04             	mov    0x4(%eax),%eax
  802a81:	66 8b 40 0a          	mov    0xa(%eax),%ax
  802a85:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802a88:	b0 00                	mov    $0x0,%al
  802a8a:	eb 02                	jmp    802a8e <netbuf_data+0x8c>
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  802a8c:	b0 fe                	mov    $0xfe,%al
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
  802a8e:	83 c4 14             	add    $0x14,%esp
  802a91:	5b                   	pop    %ebx
  802a92:	5d                   	pop    %ebp
  802a93:	c3                   	ret    

00802a94 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802a94:	55                   	push   %ebp
  802a95:	89 e5                	mov    %esp,%ebp
  802a97:	83 ec 18             	sub    $0x18,%esp
  802a9a:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802a9d:	85 c0                	test   %eax,%eax
  802a9f:	75 1c                	jne    802abd <netbuf_next+0x29>
  802aa1:	c7 44 24 08 39 1d 81 	movl   $0x811d39,0x8(%esp)
  802aa8:	00 
  802aa9:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  802ab0:	00 
  802ab1:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  802ab8:	e8 c3 c3 00 00       	call   80ee80 <_panic>
  if (buf->ptr->next == NULL) {
  802abd:	8b 50 04             	mov    0x4(%eax),%edx
  802ac0:	8b 12                	mov    (%edx),%edx
  802ac2:	85 d2                	test   %edx,%edx
  802ac4:	74 0b                	je     802ad1 <netbuf_next+0x3d>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  802ac6:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
  802ac9:	83 3a 00             	cmpl   $0x0,(%edx)
  802acc:	0f 94 c0             	sete   %al
  802acf:	eb 02                	jmp    802ad3 <netbuf_next+0x3f>
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
    return -1;
  802ad1:	b0 ff                	mov    $0xff,%al
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  802ad3:	c9                   	leave  
  802ad4:	c3                   	ret    

00802ad5 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  802ad5:	55                   	push   %ebp
  802ad6:	89 e5                	mov    %esp,%ebp
  802ad8:	83 ec 18             	sub    $0x18,%esp
  802adb:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802ade:	85 c0                	test   %eax,%eax
  802ae0:	75 1c                	jne    802afe <netbuf_first+0x29>
  802ae2:	c7 44 24 08 39 1d 81 	movl   $0x811d39,0x8(%esp)
  802ae9:	00 
  802aea:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  802af1:	00 
  802af2:	c7 04 24 23 1d 81 00 	movl   $0x811d23,(%esp)
  802af9:	e8 82 c3 00 00       	call   80ee80 <_panic>
  buf->ptr = buf->p;
  802afe:	8b 10                	mov    (%eax),%edx
  802b00:	89 50 04             	mov    %edx,0x4(%eax)
}
  802b03:	c9                   	leave  
  802b04:	c3                   	ret    
  802b05:	00 00                	add    %al,(%eax)
	...

00802b08 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  802b08:	55                   	push   %ebp
  802b09:	89 e5                	mov    %esp,%ebp
  802b0b:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802b0e:	e8 f2 78 00 00       	call   80a405 <sys_init>
  mem_init();
  802b13:	e8 c4 18 00 00       	call   8043dc <mem_init>
  memp_init();
  802b18:	e8 f3 1d 00 00       	call   804910 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802b1d:	e8 fe e4 ff ff       	call   801020 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802b22:	c9                   	leave  
  802b23:	c3                   	ret    

00802b24 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  802b24:	55                   	push   %ebp
  802b25:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  802b27:	38 10                	cmp    %dl,(%eax)
  802b29:	74 06                	je     802b31 <dhcp_set_state+0xd>
    dhcp->state = new_state;
  802b2b:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802b2d:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802b31:	5d                   	pop    %ebp
  802b32:	c3                   	ret    

00802b33 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802b33:	55                   	push   %ebp
  802b34:	89 e5                	mov    %esp,%ebp
  802b36:	57                   	push   %edi
  802b37:	56                   	push   %esi
  802b38:	53                   	push   %ebx
  802b39:	83 ec 08             	sub    $0x8,%esp
  802b3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802b3f:	8b 70 14             	mov    0x14(%eax),%esi
  802b42:	85 f6                	test   %esi,%esi
  802b44:	0f 84 c5 00 00 00    	je     802c0f <dhcp_get_option_ptr+0xdc>
  802b4a:	8b 78 18             	mov    0x18(%eax),%edi
  802b4d:	66 85 ff             	test   %di,%di
  802b50:	0f 84 c0 00 00 00    	je     802c16 <dhcp_get_option_ptr+0xe3>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  802b56:	b9 00 00 00 00       	mov    $0x0,%ecx
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  u8_t overload = DHCP_OVERLOAD_NONE;
  802b5b:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  802b5f:	eb 2c                	jmp    802b8d <dhcp_get_option_ptr+0x5a>
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802b61:	80 fb 34             	cmp    $0x34,%bl
  802b64:	75 11                	jne    802b77 <dhcp_get_option_ptr+0x44>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  802b66:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802b69:	0f b7 c0             	movzwl %ax,%eax
  802b6c:	8a 04 06             	mov    (%esi,%eax,1),%al
  802b6f:	88 45 f3             	mov    %al,-0xd(%ebp)
  802b72:	83 c1 03             	add    $0x3,%ecx
  802b75:	eb 16                	jmp    802b8d <dhcp_get_option_ptr+0x5a>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802b77:	38 d3                	cmp    %dl,%bl
  802b79:	0f 84 aa 00 00 00    	je     802c29 <dhcp_get_option_ptr+0xf6>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  802b7f:	8d 41 01             	lea    0x1(%ecx),%eax
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  802b82:	0f b7 c0             	movzwl %ax,%eax
  802b85:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802b89:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802b8d:	66 39 f9             	cmp    %di,%cx
  802b90:	73 0c                	jae    802b9e <dhcp_get_option_ptr+0x6b>
  802b92:	0f b7 c1             	movzwl %cx,%eax
  802b95:	01 f0                	add    %esi,%eax
  802b97:	8a 18                	mov    (%eax),%bl
  802b99:	80 fb ff             	cmp    $0xff,%bl
  802b9c:	75 c3                	jne    802b61 <dhcp_get_option_ptr+0x2e>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  802b9e:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  802ba2:	74 79                	je     802c1d <dhcp_get_option_ptr+0xea>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  802ba4:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
  802ba8:	75 10                	jne    802bba <dhcp_get_option_ptr+0x87>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  802baa:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802bad:	8b 70 10             	mov    0x10(%eax),%esi
  802bb0:	83 c6 6c             	add    $0x6c,%esi
        field_len = DHCP_FILE_LEN;
  802bb3:	bf 80 00 00 00       	mov    $0x80,%edi
  802bb8:	eb 24                	jmp    802bde <dhcp_get_option_ptr+0xab>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  802bba:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
  802bbe:	75 10                	jne    802bd0 <dhcp_get_option_ptr+0x9d>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802bc0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802bc3:	8b 70 10             	mov    0x10(%eax),%esi
  802bc6:	83 c6 2c             	add    $0x2c,%esi
        field_len = DHCP_SNAME_LEN;
  802bc9:	bf 40 00 00 00       	mov    $0x40,%edi
  802bce:	eb 0e                	jmp    802bde <dhcp_get_option_ptr+0xab>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802bd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802bd3:	8b 70 10             	mov    0x10(%eax),%esi
  802bd6:	83 c6 2c             	add    $0x2c,%esi
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  802bd9:	bf c0 00 00 00       	mov    $0xc0,%edi
      }
      offset = 0;
  802bde:	b9 00 00 00 00       	mov    $0x0,%ecx

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802be3:	eb 12                	jmp    802bf7 <dhcp_get_option_ptr+0xc4>
        if (options[offset] == option_type) {
  802be5:	38 da                	cmp    %bl,%dl
  802be7:	74 40                	je     802c29 <dhcp_get_option_ptr+0xf6>
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  802be9:	8d 41 01             	lea    0x1(%ecx),%eax
          offset += 1 + options[offset];
  802bec:	0f b7 c0             	movzwl %ax,%eax
  802bef:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802bf3:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802bf7:	66 39 f9             	cmp    %di,%cx
  802bfa:	73 28                	jae    802c24 <dhcp_get_option_ptr+0xf1>
  802bfc:	0f b7 c1             	movzwl %cx,%eax
  802bff:	01 f0                	add    %esi,%eax
  802c01:	8a 18                	mov    (%eax),%bl
  802c03:	80 fb ff             	cmp    $0xff,%bl
  802c06:	75 dd                	jne    802be5 <dhcp_get_option_ptr+0xb2>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802c08:	b8 00 00 00 00       	mov    $0x0,%eax
  802c0d:	eb 1a                	jmp    802c29 <dhcp_get_option_ptr+0xf6>
  802c0f:	b8 00 00 00 00       	mov    $0x0,%eax
  802c14:	eb 13                	jmp    802c29 <dhcp_get_option_ptr+0xf6>
  802c16:	b8 00 00 00 00       	mov    $0x0,%eax
  802c1b:	eb 0c                	jmp    802c29 <dhcp_get_option_ptr+0xf6>
  802c1d:	b8 00 00 00 00       	mov    $0x0,%eax
  802c22:	eb 05                	jmp    802c29 <dhcp_get_option_ptr+0xf6>
  802c24:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802c29:	83 c4 08             	add    $0x8,%esp
  802c2c:	5b                   	pop    %ebx
  802c2d:	5e                   	pop    %esi
  802c2e:	5f                   	pop    %edi
  802c2f:	5d                   	pop    %ebp
  802c30:	c3                   	ret    

00802c31 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  802c31:	55                   	push   %ebp
  802c32:	89 e5                	mov    %esp,%ebp
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  802c34:	8a 00                	mov    (%eax),%al
}
  802c36:	5d                   	pop    %ebp
  802c37:	c3                   	ret    

00802c38 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802c38:	55                   	push   %ebp
  802c39:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802c3b:	0f b6 08             	movzbl (%eax),%ecx
  802c3e:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802c41:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802c45:	c1 e2 10             	shl    $0x10,%edx
  802c48:	09 d1                	or     %edx,%ecx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802c4a:	0f b6 50 03          	movzbl 0x3(%eax),%edx
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  value |= (u32_t)(*ptr++) << 16;
  value |= (u32_t)(*ptr++) << 8;
  802c4e:	09 d1                	or     %edx,%ecx
  802c50:	0f b6 50 02          	movzbl 0x2(%eax),%edx
  802c54:	c1 e2 08             	shl    $0x8,%edx
  value |= (u32_t)(*ptr++);
  802c57:	89 c8                	mov    %ecx,%eax
  802c59:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802c5b:	5d                   	pop    %ebp
  802c5c:	c3                   	ret    

00802c5d <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  802c5d:	55                   	push   %ebp
  802c5e:	89 e5                	mov    %esp,%ebp
  802c60:	57                   	push   %edi
  802c61:	56                   	push   %esi
  802c62:	53                   	push   %ebx
  802c63:	83 ec 2c             	sub    $0x2c,%esp
  802c66:	89 d6                	mov    %edx,%esi
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802c68:	8b 58 24             	mov    0x24(%eax),%ebx
  802c6b:	0f b7 fb             	movzwl %bx,%edi
  802c6e:	88 4d e3             	mov    %cl,-0x1d(%ebp)
  802c71:	8d 4c 39 02          	lea    0x2(%ecx,%edi,1),%ecx
  802c75:	83 f9 44             	cmp    $0x44,%ecx
  802c78:	76 1c                	jbe    802c96 <dhcp_option+0x39>
  802c7a:	c7 44 24 08 14 1e 81 	movl   $0x811e14,0x8(%esp)
  802c81:	00 
  802c82:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  802c89:	00 
  802c8a:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802c91:	e8 ea c1 00 00       	call   80ee80 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802c96:	0f b7 d3             	movzwl %bx,%edx
  802c99:	89 f1                	mov    %esi,%ecx
  802c9b:	8b 78 20             	mov    0x20(%eax),%edi
  802c9e:	88 8c 17 f0 00 00 00 	mov    %cl,0xf0(%edi,%edx,1)
  802ca5:	8d 4b 01             	lea    0x1(%ebx),%ecx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802ca8:	8b 70 20             	mov    0x20(%eax),%esi
  802cab:	0f b7 c9             	movzwl %cx,%ecx
  802cae:	8a 55 e3             	mov    -0x1d(%ebp),%dl
  802cb1:	88 94 0e f0 00 00 00 	mov    %dl,0xf0(%esi,%ecx,1)
  802cb8:	83 c3 02             	add    $0x2,%ebx
  802cbb:	66 89 58 24          	mov    %bx,0x24(%eax)
}
  802cbf:	83 c4 2c             	add    $0x2c,%esp
  802cc2:	5b                   	pop    %ebx
  802cc3:	5e                   	pop    %esi
  802cc4:	5f                   	pop    %edi
  802cc5:	5d                   	pop    %ebp
  802cc6:	c3                   	ret    

00802cc7 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  802cc7:	55                   	push   %ebp
  802cc8:	89 e5                	mov    %esp,%ebp
  802cca:	56                   	push   %esi
  802ccb:	53                   	push   %ebx
  802ccc:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802ccf:	8b 48 24             	mov    0x24(%eax),%ecx
  802cd2:	66 83 f9 43          	cmp    $0x43,%cx
  802cd6:	76 1c                	jbe    802cf4 <dhcp_option_byte+0x2d>
  802cd8:	c7 44 24 08 5c 1e 81 	movl   $0x811e5c,0x8(%esp)
  802cdf:	00 
  802ce0:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  802ce7:	00 
  802ce8:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802cef:	e8 8c c1 00 00       	call   80ee80 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802cf4:	8b 70 20             	mov    0x20(%eax),%esi
  802cf7:	0f b7 d9             	movzwl %cx,%ebx
  802cfa:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  802d01:	41                   	inc    %ecx
  802d02:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  802d06:	83 c4 10             	add    $0x10,%esp
  802d09:	5b                   	pop    %ebx
  802d0a:	5e                   	pop    %esi
  802d0b:	5d                   	pop    %ebp
  802d0c:	c3                   	ret    

00802d0d <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802d0d:	55                   	push   %ebp
  802d0e:	89 e5                	mov    %esp,%ebp
  802d10:	53                   	push   %ebx
  802d11:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802d14:	85 c0                	test   %eax,%eax
  802d16:	75 1c                	jne    802d34 <dhcp_option_trailer+0x27>
  802d18:	c7 44 24 08 98 1e 81 	movl   $0x811e98,0x8(%esp)
  802d1f:	00 
  802d20:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  802d27:	00 
  802d28:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802d2f:	e8 4c c1 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802d34:	8b 48 20             	mov    0x20(%eax),%ecx
  802d37:	85 c9                	test   %ecx,%ecx
  802d39:	75 1c                	jne    802d57 <dhcp_option_trailer+0x4a>
  802d3b:	c7 44 24 08 bc 1e 81 	movl   $0x811ebc,0x8(%esp)
  802d42:	00 
  802d43:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  802d4a:	00 
  802d4b:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802d52:	e8 29 c1 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802d57:	8b 50 24             	mov    0x24(%eax),%edx
  802d5a:	66 83 fa 43          	cmp    $0x43,%dx
  802d5e:	76 1c                	jbe    802d7c <dhcp_option_trailer+0x6f>
  802d60:	c7 44 24 08 e8 1e 81 	movl   $0x811ee8,0x8(%esp)
  802d67:	00 
  802d68:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  802d6f:	00 
  802d70:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802d77:	e8 04 c1 00 00       	call   80ee80 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802d7c:	0f b7 da             	movzwl %dx,%ebx
  802d7f:	c6 84 19 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%ebx,1)
  802d86:	ff 
  802d87:	42                   	inc    %edx
  802d88:	66 89 50 24          	mov    %dx,0x24(%eax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802d8c:	eb 2f                	jmp    802dbd <dhcp_option_trailer+0xb0>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802d8e:	c7 44 24 08 e8 1e 81 	movl   $0x811ee8,0x8(%esp)
  802d95:	00 
  802d96:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  802d9d:	00 
  802d9e:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802da5:	e8 d6 c0 00 00       	call   80ee80 <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802daa:	8b 58 20             	mov    0x20(%eax),%ebx
  802dad:	0f b7 ca             	movzwl %dx,%ecx
  802db0:	c6 84 0b f0 00 00 00 	movb   $0x0,0xf0(%ebx,%ecx,1)
  802db7:	00 
  802db8:	42                   	inc    %edx
  802db9:	66 89 50 24          	mov    %dx,0x24(%eax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802dbd:	8b 50 24             	mov    0x24(%eax),%edx
  802dc0:	66 83 fa 43          	cmp    $0x43,%dx
  802dc4:	76 e4                	jbe    802daa <dhcp_option_trailer+0x9d>
  802dc6:	f6 c2 03             	test   $0x3,%dl
  802dc9:	75 c3                	jne    802d8e <dhcp_option_trailer+0x81>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  802dcb:	83 c4 14             	add    $0x14,%esp
  802dce:	5b                   	pop    %ebx
  802dcf:	5d                   	pop    %ebp
  802dd0:	c3                   	ret    

00802dd1 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  802dd1:	55                   	push   %ebp
  802dd2:	89 e5                	mov    %esp,%ebp
  802dd4:	57                   	push   %edi
  802dd5:	56                   	push   %esi
  802dd6:	53                   	push   %ebx
  802dd7:	83 ec 2c             	sub    $0x2c,%esp
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802dda:	8b 48 24             	mov    0x24(%eax),%ecx
  802ddd:	0f b7 d9             	movzwl %cx,%ebx
  802de0:	83 c3 02             	add    $0x2,%ebx
  802de3:	83 fb 44             	cmp    $0x44,%ebx
  802de6:	76 1c                	jbe    802e04 <dhcp_option_short+0x33>
  802de8:	c7 44 24 08 28 1f 81 	movl   $0x811f28,0x8(%esp)
  802def:	00 
  802df0:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  802df7:	00 
  802df8:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802dff:	e8 7c c0 00 00       	call   80ee80 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802e04:	0f b7 d9             	movzwl %cx,%ebx
  802e07:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802e0a:	89 d6                	mov    %edx,%esi
  802e0c:	66 c1 ee 08          	shr    $0x8,%si
  802e10:	66 89 75 e2          	mov    %si,-0x1e(%ebp)
  802e14:	8a 5d e2             	mov    -0x1e(%ebp),%bl
  802e17:	8b 78 20             	mov    0x20(%eax),%edi
  802e1a:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802e1d:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802e24:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802e27:	8b 70 20             	mov    0x20(%eax),%esi
  802e2a:	0f b7 db             	movzwl %bx,%ebx
  802e2d:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  802e34:	83 c1 02             	add    $0x2,%ecx
  802e37:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  802e3b:	83 c4 2c             	add    $0x2c,%esp
  802e3e:	5b                   	pop    %ebx
  802e3f:	5e                   	pop    %esi
  802e40:	5f                   	pop    %edi
  802e41:	5d                   	pop    %ebp
  802e42:	c3                   	ret    

00802e43 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  802e43:	55                   	push   %ebp
  802e44:	89 e5                	mov    %esp,%ebp
  802e46:	57                   	push   %edi
  802e47:	56                   	push   %esi
  802e48:	53                   	push   %ebx
  802e49:	83 ec 2c             	sub    $0x2c,%esp
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802e4c:	8b 48 24             	mov    0x24(%eax),%ecx
  802e4f:	0f b7 d9             	movzwl %cx,%ebx
  802e52:	83 c3 04             	add    $0x4,%ebx
  802e55:	83 fb 44             	cmp    $0x44,%ebx
  802e58:	76 1c                	jbe    802e76 <dhcp_option_long+0x33>
  802e5a:	c7 44 24 08 6c 1f 81 	movl   $0x811f6c,0x8(%esp)
  802e61:	00 
  802e62:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  802e69:	00 
  802e6a:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802e71:	e8 0a c0 00 00       	call   80ee80 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802e76:	0f b7 d9             	movzwl %cx,%ebx
  802e79:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802e7c:	89 d6                	mov    %edx,%esi
  802e7e:	c1 ee 18             	shr    $0x18,%esi
  802e81:	89 75 e0             	mov    %esi,-0x20(%ebp)
  802e84:	8a 5d e0             	mov    -0x20(%ebp),%bl
  802e87:	8b 78 20             	mov    0x20(%eax),%edi
  802e8a:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802e8d:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802e94:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802e97:	0f b7 db             	movzwl %bx,%ebx
  802e9a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802e9d:	89 d3                	mov    %edx,%ebx
  802e9f:	c1 eb 10             	shr    $0x10,%ebx
  802ea2:	8b 78 20             	mov    0x20(%eax),%edi
  802ea5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802ea8:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802eaf:	8d 59 02             	lea    0x2(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802eb2:	0f b7 db             	movzwl %bx,%ebx
  802eb5:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802eb8:	0f b6 de             	movzbl %dh,%ebx
  802ebb:	8b 78 20             	mov    0x20(%eax),%edi
  802ebe:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802ec1:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802ec8:	8d 59 03             	lea    0x3(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802ecb:	8b 70 20             	mov    0x20(%eax),%esi
  802ece:	0f b7 db             	movzwl %bx,%ebx
  802ed1:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  802ed8:	83 c1 04             	add    $0x4,%ecx
  802edb:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  802edf:	83 c4 2c             	add    $0x2c,%esp
  802ee2:	5b                   	pop    %ebx
  802ee3:	5e                   	pop    %esi
  802ee4:	5f                   	pop    %edi
  802ee5:	5d                   	pop    %ebp
  802ee6:	c3                   	ret    

00802ee7 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  802ee7:	55                   	push   %ebp
  802ee8:	89 e5                	mov    %esp,%ebp
  802eea:	53                   	push   %ebx
  802eeb:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802eee:	85 c0                	test   %eax,%eax
  802ef0:	75 1c                	jne    802f0e <dhcp_delete_request+0x27>
  802ef2:	c7 44 24 08 ac 1f 81 	movl   $0x811fac,0x8(%esp)
  802ef9:	00 
  802efa:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  802f01:	00 
  802f02:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802f09:	e8 72 bf 00 00       	call   80ee80 <_panic>
  dhcp = netif->dhcp;
  802f0e:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802f11:	85 db                	test   %ebx,%ebx
  802f13:	75 1c                	jne    802f31 <dhcp_delete_request+0x4a>
  802f15:	c7 44 24 08 d0 1f 81 	movl   $0x811fd0,0x8(%esp)
  802f1c:	00 
  802f1d:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  802f24:	00 
  802f25:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802f2c:	e8 4f bf 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802f31:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802f34:	85 c0                	test   %eax,%eax
  802f36:	75 1c                	jne    802f54 <dhcp_delete_request+0x6d>
  802f38:	c7 44 24 08 f4 1f 81 	movl   $0x811ff4,0x8(%esp)
  802f3f:	00 
  802f40:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  802f47:	00 
  802f48:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802f4f:	e8 2c bf 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802f54:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802f58:	75 1c                	jne    802f76 <dhcp_delete_request+0x8f>
  802f5a:	c7 44 24 08 20 20 81 	movl   $0x812020,0x8(%esp)
  802f61:	00 
  802f62:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  802f69:	00 
  802f6a:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802f71:	e8 0a bf 00 00       	call   80ee80 <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  802f76:	89 04 24             	mov    %eax,(%esp)
  802f79:	e8 d3 1d 00 00       	call   804d51 <pbuf_free>
  }
  dhcp->p_out = NULL;
  802f7e:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802f85:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  802f8c:	83 c4 14             	add    $0x14,%esp
  802f8f:	5b                   	pop    %ebx
  802f90:	5d                   	pop    %ebp
  802f91:	c3                   	ret    

00802f92 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  802f92:	55                   	push   %ebp
  802f93:	89 e5                	mov    %esp,%ebp
  802f95:	53                   	push   %ebx
  802f96:	83 ec 14             	sub    $0x14,%esp
  802f99:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  802f9b:	8b 40 10             	mov    0x10(%eax),%eax
  802f9e:	85 c0                	test   %eax,%eax
  802fa0:	74 0f                	je     802fb1 <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  802fa2:	89 04 24             	mov    %eax,(%esp)
  802fa5:	e8 9a 14 00 00       	call   804444 <mem_free>
    dhcp->msg_in = NULL;
  802faa:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  802fb1:	8b 43 14             	mov    0x14(%ebx),%eax
  802fb4:	85 c0                	test   %eax,%eax
  802fb6:	74 15                	je     802fcd <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  802fb8:	89 04 24             	mov    %eax,(%esp)
  802fbb:	e8 84 14 00 00       	call   804444 <mem_free>
    dhcp->options_in = NULL;
  802fc0:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  802fc7:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  802fcd:	83 c4 14             	add    $0x14,%esp
  802fd0:	5b                   	pop    %ebx
  802fd1:	5d                   	pop    %ebp
  802fd2:	c3                   	ret    

00802fd3 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  802fd3:	55                   	push   %ebp
  802fd4:	89 e5                	mov    %esp,%ebp
  802fd6:	57                   	push   %edi
  802fd7:	56                   	push   %esi
  802fd8:	53                   	push   %ebx
  802fd9:	83 ec 2c             	sub    $0x2c,%esp
  802fdc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802fdf:	85 c0                	test   %eax,%eax
  802fe1:	75 1c                	jne    802fff <dhcp_create_request+0x2c>
  802fe3:	c7 44 24 08 4c 20 81 	movl   $0x81204c,0x8(%esp)
  802fea:	00 
  802feb:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  802ff2:	00 
  802ff3:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  802ffa:	e8 81 be 00 00       	call   80ee80 <_panic>
  dhcp = netif->dhcp;
  802fff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803002:	8b 70 20             	mov    0x20(%eax),%esi
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  803005:	85 f6                	test   %esi,%esi
  803007:	75 1c                	jne    803025 <dhcp_create_request+0x52>
  803009:	c7 44 24 08 70 20 81 	movl   $0x812070,0x8(%esp)
  803010:	00 
  803011:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  803018:	00 
  803019:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  803020:	e8 5b be 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  803025:	83 7e 1c 00          	cmpl   $0x0,0x1c(%esi)
  803029:	74 1c                	je     803047 <dhcp_create_request+0x74>
  80302b:	c7 44 24 08 94 20 81 	movl   $0x812094,0x8(%esp)
  803032:	00 
  803033:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  80303a:	00 
  80303b:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  803042:	e8 39 be 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  803047:	83 7e 20 00          	cmpl   $0x0,0x20(%esi)
  80304b:	74 1c                	je     803069 <dhcp_create_request+0x96>
  80304d:	c7 44 24 08 c0 20 81 	movl   $0x8120c0,0x8(%esp)
  803054:	00 
  803055:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  80305c:	00 
  80305d:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  803064:	e8 17 be 00 00       	call   80ee80 <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  803069:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  803070:	00 
  803071:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  803078:	00 
  803079:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803080:	e8 cd 1e 00 00       	call   804f52 <pbuf_alloc>
  803085:	89 46 1c             	mov    %eax,0x1c(%esi)
  if (dhcp->p_out == NULL) {
  803088:	85 c0                	test   %eax,%eax
  80308a:	0f 84 23 01 00 00    	je     8031b3 <dhcp_create_request+0x1e0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  803090:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  803096:	77 1c                	ja     8030b4 <dhcp_create_request+0xe1>
  803098:	c7 44 24 08 ec 20 81 	movl   $0x8120ec,0x8(%esp)
  80309f:	00 
  8030a0:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  8030a7:	00 
  8030a8:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  8030af:	e8 cc bd 00 00       	call   80ee80 <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  8030b4:	8b 15 04 50 81 00    	mov    0x815004,%edx
  8030ba:	89 56 04             	mov    %edx,0x4(%esi)
  8030bd:	42                   	inc    %edx
  8030be:	89 15 04 50 81 00    	mov    %edx,0x815004
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  8030c4:	8b 40 04             	mov    0x4(%eax),%eax
  8030c7:	89 46 20             	mov    %eax,0x20(%esi)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  8030ca:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  8030cd:	8b 46 20             	mov    0x20(%esi),%eax
  8030d0:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  8030d4:	8b 46 20             	mov    0x20(%esi),%eax
  8030d7:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  8030db:	8b 46 20             	mov    0x20(%esi),%eax
  8030de:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  8030e2:	8b 7e 20             	mov    0x20(%esi),%edi
  8030e5:	8b 46 04             	mov    0x4(%esi),%eax
  8030e8:	89 04 24             	mov    %eax,(%esp)
  8030eb:	e8 89 4b 00 00       	call   807c79 <htonl>
  8030f0:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  8030f3:	8b 46 20             	mov    0x20(%esi),%eax
  8030f6:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  8030fc:	8b 46 20             	mov    0x20(%esi),%eax
  8030ff:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  803105:	8b 46 20             	mov    0x20(%esi),%eax
  803108:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80310b:	8b 51 04             	mov    0x4(%ecx),%edx
  80310e:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  803111:	8b 46 20             	mov    0x20(%esi),%eax
  803114:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  80311b:	8b 46 20             	mov    0x20(%esi),%eax
  80311e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  803125:	8b 46 20             	mov    0x20(%esi),%eax
  803128:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  80312f:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  803134:	8b 4e 20             	mov    0x20(%esi),%ecx
  803137:	89 c2                	mov    %eax,%edx
  803139:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80313c:	0f b6 7b 24          	movzbl 0x24(%ebx),%edi
  803140:	66 39 c7             	cmp    %ax,%di
  803143:	76 07                	jbe    80314c <dhcp_create_request+0x179>
  803145:	0f b6 7c 03 25       	movzbl 0x25(%ebx,%eax,1),%edi
  80314a:	eb 05                	jmp    803151 <dhcp_create_request+0x17e>
  80314c:	bf 00 00 00 00       	mov    $0x0,%edi
  803151:	89 fb                	mov    %edi,%ebx
  803153:	88 5c 11 1c          	mov    %bl,0x1c(%ecx,%edx,1)
  803157:	40                   	inc    %eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  803158:	83 f8 10             	cmp    $0x10,%eax
  80315b:	75 d7                	jne    803134 <dhcp_create_request+0x161>
  80315d:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  80315f:	8b 56 20             	mov    0x20(%esi),%edx
  803162:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  803167:	40                   	inc    %eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  803168:	83 f8 40             	cmp    $0x40,%eax
  80316b:	75 f2                	jne    80315f <dhcp_create_request+0x18c>
  80316d:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  80316f:	8b 56 20             	mov    0x20(%esi),%edx
  803172:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  803177:	40                   	inc    %eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  803178:	3d 80 00 00 00       	cmp    $0x80,%eax
  80317d:	75 f0                	jne    80316f <dhcp_create_request+0x19c>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  80317f:	8b 5e 20             	mov    0x20(%esi),%ebx
  803182:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  803189:	e8 eb 4a 00 00       	call   807c79 <htonl>
  80318e:	89 83 ec 00 00 00    	mov    %eax,0xec(%ebx)
  dhcp->options_out_len = 0;
  803194:	66 c7 46 24 00 00    	movw   $0x0,0x24(%esi)
  80319a:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  80319f:	8b 56 20             	mov    0x20(%esi),%edx
  8031a2:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  8031a9:	40                   	inc    %eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  8031aa:	83 f8 44             	cmp    $0x44,%eax
  8031ad:	75 f0                	jne    80319f <dhcp_create_request+0x1cc>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  8031af:	b0 00                	mov    $0x0,%al
  8031b1:	eb 02                	jmp    8031b5 <dhcp_create_request+0x1e2>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  8031b3:	b0 ff                	mov    $0xff,%al
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  8031b5:	83 c4 2c             	add    $0x2c,%esp
  8031b8:	5b                   	pop    %ebx
  8031b9:	5e                   	pop    %esi
  8031ba:	5f                   	pop    %edi
  8031bb:	5d                   	pop    %ebp
  8031bc:	c3                   	ret    

008031bd <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  8031bd:	55                   	push   %ebp
  8031be:	89 e5                	mov    %esp,%ebp
  8031c0:	57                   	push   %edi
  8031c1:	56                   	push   %esi
  8031c2:	53                   	push   %ebx
  8031c3:	83 ec 2c             	sub    $0x2c,%esp
  8031c6:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8031c8:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  8031cb:	a1 38 2a 81 00       	mov    0x812a38,%eax
  8031d0:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8031d3:	89 f8                	mov    %edi,%eax
  8031d5:	e8 f9 fd ff ff       	call   802fd3 <dhcp_create_request>
  8031da:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8031dc:	84 c0                	test   %al,%al
  8031de:	0f 85 f0 00 00 00    	jne    8032d4 <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8031e4:	b9 01 00 00 00       	mov    $0x1,%ecx
  8031e9:	ba 35 00 00 00       	mov    $0x35,%edx
  8031ee:	89 d8                	mov    %ebx,%eax
  8031f0:	e8 68 fa ff ff       	call   802c5d <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  8031f5:	ba 01 00 00 00       	mov    $0x1,%edx
  8031fa:	89 d8                	mov    %ebx,%eax
  8031fc:	e8 c6 fa ff ff       	call   802cc7 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803201:	b9 02 00 00 00       	mov    $0x2,%ecx
  803206:	ba 39 00 00 00       	mov    $0x39,%edx
  80320b:	89 d8                	mov    %ebx,%eax
  80320d:	e8 4b fa ff ff       	call   802c5d <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803212:	ba 40 02 00 00       	mov    $0x240,%edx
  803217:	89 d8                	mov    %ebx,%eax
  803219:	e8 b3 fb ff ff       	call   802dd1 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80321e:	b9 04 00 00 00       	mov    $0x4,%ecx
  803223:	ba 37 00 00 00       	mov    $0x37,%edx
  803228:	89 d8                	mov    %ebx,%eax
  80322a:	e8 2e fa ff ff       	call   802c5d <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80322f:	ba 01 00 00 00       	mov    $0x1,%edx
  803234:	89 d8                	mov    %ebx,%eax
  803236:	e8 8c fa ff ff       	call   802cc7 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80323b:	ba 03 00 00 00       	mov    $0x3,%edx
  803240:	89 d8                	mov    %ebx,%eax
  803242:	e8 80 fa ff ff       	call   802cc7 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803247:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80324c:	89 d8                	mov    %ebx,%eax
  80324e:	e8 74 fa ff ff       	call   802cc7 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803253:	ba 06 00 00 00       	mov    $0x6,%edx
  803258:	89 d8                	mov    %ebx,%eax
  80325a:	e8 68 fa ff ff       	call   802cc7 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  80325f:	89 d8                	mov    %ebx,%eax
  803261:	e8 a7 fa ff ff       	call   802d0d <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803266:	8b 43 24             	mov    0x24(%ebx),%eax
  803269:	05 f0 00 00 00       	add    $0xf0,%eax
  80326e:	0f b7 c0             	movzwl %ax,%eax
  803271:	89 44 24 04          	mov    %eax,0x4(%esp)
  803275:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803278:	89 04 24             	mov    %eax,(%esp)
  80327b:	e8 a3 1b 00 00       	call   804e23 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803280:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803287:	00 
  803288:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  80328f:	00 
  803290:	8b 43 08             	mov    0x8(%ebx),%eax
  803293:	89 04 24             	mov    %eax,(%esp)
  803296:	e8 43 63 00 00       	call   8095de <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80329b:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80329f:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8032a6:	00 
  8032a7:	c7 44 24 08 34 2a 81 	movl   $0x812a34,0x8(%esp)
  8032ae:	00 
  8032af:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8032b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8032b6:	8b 43 08             	mov    0x8(%ebx),%eax
  8032b9:	89 04 24             	mov    %eax,(%esp)
  8032bc:	e8 f8 60 00 00       	call   8093b9 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  8032c1:	89 f8                	mov    %edi,%eax
  8032c3:	e8 1f fc ff ff       	call   802ee7 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  8032c8:	ba 06 00 00 00       	mov    $0x6,%edx
  8032cd:	89 d8                	mov    %ebx,%eax
  8032cf:	e8 50 f8 ff ff       	call   802b24 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8032d4:	8a 43 01             	mov    0x1(%ebx),%al
  8032d7:	40                   	inc    %eax
  8032d8:	88 43 01             	mov    %al,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  8032db:	3c 03                	cmp    $0x3,%al
  8032dd:	77 12                	ja     8032f1 <dhcp_discover+0x134>
  8032df:	0f b6 d0             	movzbl %al,%edx
  8032e2:	8d 54 92 05          	lea    0x5(%edx,%edx,4),%edx
  8032e6:	8d 14 92             	lea    (%edx,%edx,4),%edx
  8032e9:	8d 14 92             	lea    (%edx,%edx,4),%edx
  8032ec:	c1 e2 03             	shl    $0x3,%edx
  8032ef:	eb 05                	jmp    8032f6 <dhcp_discover+0x139>
  8032f1:	ba 10 27 00 00       	mov    $0x2710,%edx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8032f6:	0f b7 d2             	movzwl %dx,%edx
  8032f9:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8032ff:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  803304:	f7 ea                	imul   %edx
  803306:	89 d0                	mov    %edx,%eax
  803308:	c1 f8 05             	sar    $0x5,%eax
  80330b:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  80330f:	89 f0                	mov    %esi,%eax
  803311:	83 c4 2c             	add    $0x2c,%esp
  803314:	5b                   	pop    %ebx
  803315:	5e                   	pop    %esi
  803316:	5f                   	pop    %edi
  803317:	5d                   	pop    %ebp
  803318:	c3                   	ret    

00803319 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  803319:	55                   	push   %ebp
  80331a:	89 e5                	mov    %esp,%ebp
  80331c:	57                   	push   %edi
  80331d:	56                   	push   %esi
  80331e:	53                   	push   %ebx
  80331f:	83 ec 2c             	sub    $0x2c,%esp
  803322:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803324:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  803327:	ba 04 00 00 00       	mov    $0x4,%edx
  80332c:	89 d8                	mov    %ebx,%eax
  80332e:	e8 f1 f7 ff ff       	call   802b24 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803333:	89 f8                	mov    %edi,%eax
  803335:	e8 99 fc ff ff       	call   802fd3 <dhcp_create_request>
  80333a:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80333c:	84 c0                	test   %al,%al
  80333e:	0f 85 a3 00 00 00    	jne    8033e7 <dhcp_rebind+0xce>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803344:	b9 01 00 00 00       	mov    $0x1,%ecx
  803349:	ba 35 00 00 00       	mov    $0x35,%edx
  80334e:	89 d8                	mov    %ebx,%eax
  803350:	e8 08 f9 ff ff       	call   802c5d <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803355:	ba 03 00 00 00       	mov    $0x3,%edx
  80335a:	89 d8                	mov    %ebx,%eax
  80335c:	e8 66 f9 ff ff       	call   802cc7 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803361:	b9 02 00 00 00       	mov    $0x2,%ecx
  803366:	ba 39 00 00 00       	mov    $0x39,%edx
  80336b:	89 d8                	mov    %ebx,%eax
  80336d:	e8 eb f8 ff ff       	call   802c5d <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803372:	ba 40 02 00 00       	mov    $0x240,%edx
  803377:	89 d8                	mov    %ebx,%eax
  803379:	e8 53 fa ff ff       	call   802dd1 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80337e:	89 d8                	mov    %ebx,%eax
  803380:	e8 88 f9 ff ff       	call   802d0d <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803385:	8b 43 24             	mov    0x24(%ebx),%eax
  803388:	05 f0 00 00 00       	add    $0xf0,%eax
  80338d:	0f b7 c0             	movzwl %ax,%eax
  803390:	89 44 24 04          	mov    %eax,0x4(%esp)
  803394:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803397:	89 04 24             	mov    %eax,(%esp)
  80339a:	e8 84 1a 00 00       	call   804e23 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80339f:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8033a6:	00 
  8033a7:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  8033ae:	00 
  8033af:	8b 43 08             	mov    0x8(%ebx),%eax
  8033b2:	89 04 24             	mov    %eax,(%esp)
  8033b5:	e8 24 62 00 00       	call   8095de <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8033ba:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8033be:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8033c5:	00 
  8033c6:	c7 44 24 08 34 2a 81 	movl   $0x812a34,0x8(%esp)
  8033cd:	00 
  8033ce:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8033d1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033d5:	8b 43 08             	mov    0x8(%ebx),%eax
  8033d8:	89 04 24             	mov    %eax,(%esp)
  8033db:	e8 d9 5f 00 00       	call   8093b9 <udp_sendto_if>
    dhcp_delete_request(netif);
  8033e0:	89 f8                	mov    %edi,%eax
  8033e2:	e8 00 fb ff ff       	call   802ee7 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8033e7:	8a 43 01             	mov    0x1(%ebx),%al
  8033ea:	40                   	inc    %eax
  8033eb:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  8033ee:	3c 09                	cmp    $0x9,%al
  8033f0:	77 11                	ja     803403 <dhcp_rebind+0xea>
  8033f2:	0f b6 d0             	movzbl %al,%edx
  8033f5:	8d 14 92             	lea    (%edx,%edx,4),%edx
  8033f8:	8d 14 92             	lea    (%edx,%edx,4),%edx
  8033fb:	8d 14 92             	lea    (%edx,%edx,4),%edx
  8033fe:	c1 e2 03             	shl    $0x3,%edx
  803401:	eb 05                	jmp    803408 <dhcp_rebind+0xef>
  803403:	ba 10 27 00 00       	mov    $0x2710,%edx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803408:	0f b7 d2             	movzwl %dx,%edx
  80340b:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803411:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  803416:	f7 ea                	imul   %edx
  803418:	89 d0                	mov    %edx,%eax
  80341a:	c1 f8 05             	sar    $0x5,%eax
  80341d:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803421:	89 f0                	mov    %esi,%eax
  803423:	83 c4 2c             	add    $0x2c,%esp
  803426:	5b                   	pop    %ebx
  803427:	5e                   	pop    %esi
  803428:	5f                   	pop    %edi
  803429:	5d                   	pop    %ebp
  80342a:	c3                   	ret    

0080342b <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  80342b:	55                   	push   %ebp
  80342c:	89 e5                	mov    %esp,%ebp
  80342e:	57                   	push   %edi
  80342f:	56                   	push   %esi
  803430:	53                   	push   %ebx
  803431:	83 ec 2c             	sub    $0x2c,%esp
  803434:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803436:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803439:	e8 95 fb ff ff       	call   802fd3 <dhcp_create_request>
  80343e:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803440:	84 c0                	test   %al,%al
  803442:	0f 85 3a 01 00 00    	jne    803582 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803448:	b9 01 00 00 00       	mov    $0x1,%ecx
  80344d:	ba 35 00 00 00       	mov    $0x35,%edx
  803452:	89 d8                	mov    %ebx,%eax
  803454:	e8 04 f8 ff ff       	call   802c5d <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803459:	ba 03 00 00 00       	mov    $0x3,%edx
  80345e:	89 d8                	mov    %ebx,%eax
  803460:	e8 62 f8 ff ff       	call   802cc7 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803465:	b9 02 00 00 00       	mov    $0x2,%ecx
  80346a:	ba 39 00 00 00       	mov    $0x39,%edx
  80346f:	89 d8                	mov    %ebx,%eax
  803471:	e8 e7 f7 ff ff       	call   802c5d <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803476:	ba 40 02 00 00       	mov    $0x240,%edx
  80347b:	89 d8                	mov    %ebx,%eax
  80347d:	e8 4f f9 ff ff       	call   802dd1 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803482:	b9 04 00 00 00       	mov    $0x4,%ecx
  803487:	ba 32 00 00 00       	mov    $0x32,%edx
  80348c:	89 d8                	mov    %ebx,%eax
  80348e:	e8 ca f7 ff ff       	call   802c5d <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803493:	8b 43 30             	mov    0x30(%ebx),%eax
  803496:	89 04 24             	mov    %eax,(%esp)
  803499:	e8 31 4a 00 00       	call   807ecf <ntohl>
  80349e:	89 c2                	mov    %eax,%edx
  8034a0:	89 d8                	mov    %ebx,%eax
  8034a2:	e8 9c f9 ff ff       	call   802e43 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8034a7:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034ac:	ba 36 00 00 00       	mov    $0x36,%edx
  8034b1:	89 d8                	mov    %ebx,%eax
  8034b3:	e8 a5 f7 ff ff       	call   802c5d <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8034b8:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8034bb:	89 04 24             	mov    %eax,(%esp)
  8034be:	e8 0c 4a 00 00       	call   807ecf <ntohl>
  8034c3:	89 c2                	mov    %eax,%edx
  8034c5:	89 d8                	mov    %ebx,%eax
  8034c7:	e8 77 f9 ff ff       	call   802e43 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8034cc:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034d1:	ba 37 00 00 00       	mov    $0x37,%edx
  8034d6:	89 d8                	mov    %ebx,%eax
  8034d8:	e8 80 f7 ff ff       	call   802c5d <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8034dd:	ba 01 00 00 00       	mov    $0x1,%edx
  8034e2:	89 d8                	mov    %ebx,%eax
  8034e4:	e8 de f7 ff ff       	call   802cc7 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8034e9:	ba 03 00 00 00       	mov    $0x3,%edx
  8034ee:	89 d8                	mov    %ebx,%eax
  8034f0:	e8 d2 f7 ff ff       	call   802cc7 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8034f5:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8034fa:	89 d8                	mov    %ebx,%eax
  8034fc:	e8 c6 f7 ff ff       	call   802cc7 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803501:	ba 06 00 00 00       	mov    $0x6,%edx
  803506:	89 d8                	mov    %ebx,%eax
  803508:	e8 ba f7 ff ff       	call   802cc7 <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  80350d:	89 d8                	mov    %ebx,%eax
  80350f:	e8 f9 f7 ff ff       	call   802d0d <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803514:	8b 43 24             	mov    0x24(%ebx),%eax
  803517:	05 f0 00 00 00       	add    $0xf0,%eax
  80351c:	0f b7 c0             	movzwl %ax,%eax
  80351f:	89 44 24 04          	mov    %eax,0x4(%esp)
  803523:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803526:	89 04 24             	mov    %eax,(%esp)
  803529:	e8 f5 18 00 00       	call   804e23 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80352e:	89 7c 24 10          	mov    %edi,0x10(%esp)
  803532:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803539:	00 
  80353a:	c7 44 24 08 34 2a 81 	movl   $0x812a34,0x8(%esp)
  803541:	00 
  803542:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803545:	89 44 24 04          	mov    %eax,0x4(%esp)
  803549:	8b 43 08             	mov    0x8(%ebx),%eax
  80354c:	89 04 24             	mov    %eax,(%esp)
  80354f:	e8 65 5e 00 00       	call   8093b9 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803554:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80355b:	00 
  80355c:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  803563:	00 
  803564:	8b 43 08             	mov    0x8(%ebx),%eax
  803567:	89 04 24             	mov    %eax,(%esp)
  80356a:	e8 6f 60 00 00       	call   8095de <udp_connect>
    dhcp_delete_request(netif);
  80356f:	89 f8                	mov    %edi,%eax
  803571:	e8 71 f9 ff ff       	call   802ee7 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  803576:	ba 01 00 00 00       	mov    $0x1,%edx
  80357b:	89 d8                	mov    %ebx,%eax
  80357d:	e8 a2 f5 ff ff       	call   802b24 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803582:	8a 43 01             	mov    0x1(%ebx),%al
  803585:	40                   	inc    %eax
  803586:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  803589:	3c 03                	cmp    $0x3,%al
  80358b:	77 11                	ja     80359e <dhcp_select+0x173>
  80358d:	0f b6 d0             	movzbl %al,%edx
  803590:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803593:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803596:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803599:	c1 e2 03             	shl    $0x3,%edx
  80359c:	eb 05                	jmp    8035a3 <dhcp_select+0x178>
  80359e:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8035a3:	0f b7 d2             	movzwl %dx,%edx
  8035a6:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8035ac:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  8035b1:	f7 ea                	imul   %edx
  8035b3:	89 d0                	mov    %edx,%eax
  8035b5:	c1 f8 05             	sar    $0x5,%eax
  8035b8:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8035bc:	89 f0                	mov    %esi,%eax
  8035be:	83 c4 2c             	add    $0x2c,%esp
  8035c1:	5b                   	pop    %ebx
  8035c2:	5e                   	pop    %esi
  8035c3:	5f                   	pop    %edi
  8035c4:	5d                   	pop    %ebp
  8035c5:	c3                   	ret    

008035c6 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8035c6:	55                   	push   %ebp
  8035c7:	89 e5                	mov    %esp,%ebp
  8035c9:	53                   	push   %ebx
  8035ca:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  8035cd:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8035d0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8035d7:	00 
  8035d8:	8d 53 30             	lea    0x30(%ebx),%edx
  8035db:	89 54 24 04          	mov    %edx,0x4(%esp)
  8035df:	89 04 24             	mov    %eax,(%esp)
  8035e2:	e8 c4 69 00 00       	call   809fab <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  8035e7:	fe 43 01             	incb   0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8035ea:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8035f0:	ba 08 00 00 00       	mov    $0x8,%edx
  8035f5:	89 d8                	mov    %ebx,%eax
  8035f7:	e8 28 f5 ff ff       	call   802b24 <dhcp_set_state>
}
  8035fc:	83 c4 14             	add    $0x14,%esp
  8035ff:	5b                   	pop    %ebx
  803600:	5d                   	pop    %ebp
  803601:	c3                   	ret    

00803602 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  803602:	55                   	push   %ebp
  803603:	89 e5                	mov    %esp,%ebp
  803605:	57                   	push   %edi
  803606:	56                   	push   %esi
  803607:	53                   	push   %ebx
  803608:	83 ec 2c             	sub    $0x2c,%esp
  80360b:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80360d:	85 c0                	test   %eax,%eax
  80360f:	75 1c                	jne    80362d <dhcp_bind+0x2b>
  803611:	c7 44 24 08 77 21 81 	movl   $0x812177,0x8(%esp)
  803618:	00 
  803619:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  803620:	00 
  803621:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  803628:	e8 53 b8 00 00       	call   80ee80 <_panic>
  dhcp = netif->dhcp;
  80362d:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803630:	85 db                	test   %ebx,%ebx
  803632:	75 1c                	jne    803650 <dhcp_bind+0x4e>
  803634:	c7 44 24 08 90 21 81 	movl   $0x812190,0x8(%esp)
  80363b:	00 
  80363c:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  803643:	00 
  803644:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  80364b:	e8 30 b8 00 00       	call   80ee80 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803650:	8b 53 50             	mov    0x50(%ebx),%edx
  803653:	83 fa ff             	cmp    $0xffffffff,%edx
  803656:	74 2d                	je     803685 <dhcp_bind+0x83>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803658:	83 c2 1e             	add    $0x1e,%edx
  80365b:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803660:	89 d0                	mov    %edx,%eax
  803662:	f7 e1                	mul    %ecx
  803664:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  803667:	89 d0                	mov    %edx,%eax
  803669:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  80366f:	76 05                	jbe    803676 <dhcp_bind+0x74>
  803671:	b8 ff ff 00 00       	mov    $0xffff,%eax
  803676:	66 89 43 28          	mov    %ax,0x28(%ebx)
    if (dhcp->t1_timeout == 0) {
  80367a:	66 85 c0             	test   %ax,%ax
  80367d:	75 06                	jne    803685 <dhcp_bind+0x83>
      dhcp->t1_timeout = 1;
  80367f:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  803685:	8b 53 54             	mov    0x54(%ebx),%edx
  803688:	83 fa ff             	cmp    $0xffffffff,%edx
  80368b:	74 2d                	je     8036ba <dhcp_bind+0xb8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80368d:	83 c2 1e             	add    $0x1e,%edx
  803690:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803695:	89 d0                	mov    %edx,%eax
  803697:	f7 e1                	mul    %ecx
  803699:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  80369c:	89 d0                	mov    %edx,%eax
  80369e:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  8036a4:	76 05                	jbe    8036ab <dhcp_bind+0xa9>
  8036a6:	b8 ff ff 00 00       	mov    $0xffff,%eax
  8036ab:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
    if (dhcp->t2_timeout == 0) {
  8036af:	66 85 c0             	test   %ax,%ax
  8036b2:	75 06                	jne    8036ba <dhcp_bind+0xb8>
      dhcp->t2_timeout = 1;
  8036b4:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8036ba:	83 fb cc             	cmp    $0xffffffcc,%ebx
  8036bd:	0f 84 c4 00 00 00    	je     803787 <dhcp_bind+0x185>
  8036c3:	8b 43 34             	mov    0x34(%ebx),%eax
  8036c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  8036c9:	85 c0                	test   %eax,%eax
  8036cb:	75 48                	jne    803715 <dhcp_bind+0x113>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  8036cd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8036d4:	e8 f6 47 00 00       	call   807ecf <ntohl>
  8036d9:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  8036dc:	84 c0                	test   %al,%al
  8036de:	78 11                	js     8036f1 <dhcp_bind+0xef>
      sn_mask.addr = htonl(0xff000000);
  8036e0:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  8036e7:	e8 8d 45 00 00       	call   807c79 <htonl>
  8036ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8036ef:	eb 24                	jmp    803715 <dhcp_bind+0x113>
    } else if (first_octet >= 192) {
  8036f1:	3c bf                	cmp    $0xbf,%al
  8036f3:	76 11                	jbe    803706 <dhcp_bind+0x104>
      sn_mask.addr = htonl(0xffffff00);
  8036f5:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  8036fc:	e8 78 45 00 00       	call   807c79 <htonl>
  803701:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803704:	eb 0f                	jmp    803715 <dhcp_bind+0x113>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  803706:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  80370d:	e8 67 45 00 00       	call   807c79 <htonl>
  803712:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  803715:	83 fb c8             	cmp    $0xffffffc8,%ebx
  803718:	74 0a                	je     803724 <dhcp_bind+0x122>
  80371a:	8b 43 38             	mov    0x38(%ebx),%eax
  80371d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  803720:	85 c0                	test   %eax,%eax
  803722:	75 1a                	jne    80373e <dhcp_bind+0x13c>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  803724:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  803727:	23 7b 30             	and    0x30(%ebx),%edi
  80372a:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  80372d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803734:	e8 40 45 00 00       	call   807c79 <htonl>
  803739:	09 c7                	or     %eax,%edi
  80373b:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  80373e:	8d 43 30             	lea    0x30(%ebx),%eax
  803741:	89 44 24 04          	mov    %eax,0x4(%esp)
  803745:	89 34 24             	mov    %esi,(%esp)
  803748:	e8 f7 12 00 00       	call   804a44 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80374d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803750:	89 44 24 04          	mov    %eax,0x4(%esp)
  803754:	89 34 24             	mov    %esi,(%esp)
  803757:	e8 81 13 00 00       	call   804add <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80375c:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80375f:	89 44 24 04          	mov    %eax,0x4(%esp)
  803763:	89 34 24             	mov    %esi,(%esp)
  803766:	e8 57 13 00 00       	call   804ac2 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  80376b:	89 34 24             	mov    %esi,(%esp)
  80376e:	e8 9f 14 00 00       	call   804c12 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  803773:	ba 0a 00 00 00       	mov    $0xa,%edx
  803778:	89 d8                	mov    %ebx,%eax
  80377a:	e8 a5 f3 ff ff       	call   802b24 <dhcp_set_state>
}
  80377f:	83 c4 2c             	add    $0x2c,%esp
  803782:	5b                   	pop    %ebx
  803783:	5e                   	pop    %esi
  803784:	5f                   	pop    %edi
  803785:	5d                   	pop    %ebp
  803786:	c3                   	ret    
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  803787:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80378e:	e9 3a ff ff ff       	jmp    8036cd <dhcp_bind+0xcb>

00803793 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  803793:	55                   	push   %ebp
  803794:	89 e5                	mov    %esp,%ebp
  803796:	57                   	push   %edi
  803797:	56                   	push   %esi
  803798:	53                   	push   %ebx
  803799:	83 ec 2c             	sub    $0x2c,%esp
  80379c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80379f:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  8037a2:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  8037a5:	8b 4f 04             	mov    0x4(%edi),%ecx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  8037a8:	89 7e 0c             	mov    %edi,0xc(%esi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  8037ab:	80 39 02             	cmpb   $0x2,(%ecx)
  8037ae:	0f 85 09 04 00 00    	jne    803bbd <dhcp_recv+0x42a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8037b4:	8a 43 24             	mov    0x24(%ebx),%al
  8037b7:	88 45 e4             	mov    %al,-0x1c(%ebp)
  8037ba:	b8 00 00 00 00       	mov    $0x0,%eax
  8037bf:	eb 0f                	jmp    8037d0 <dhcp_recv+0x3d>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  8037c1:	8a 54 03 25          	mov    0x25(%ebx,%eax,1),%dl
  8037c5:	40                   	inc    %eax
  8037c6:	3a 54 01 1b          	cmp    0x1b(%ecx,%eax,1),%dl
  8037ca:	0f 85 ed 03 00 00    	jne    803bbd <dhcp_recv+0x42a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8037d0:	38 45 e4             	cmp    %al,-0x1c(%ebp)
  8037d3:	77 ec                	ja     8037c1 <dhcp_recv+0x2e>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8037d5:	8b 41 04             	mov    0x4(%ecx),%eax
  8037d8:	89 04 24             	mov    %eax,(%esp)
  8037db:	e8 ef 46 00 00       	call   807ecf <ntohl>
  8037e0:	3b 46 04             	cmp    0x4(%esi),%eax
  8037e3:	0f 85 d4 03 00 00    	jne    803bbd <dhcp_recv+0x42a>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  8037e9:	85 f6                	test   %esi,%esi
  8037eb:	75 1c                	jne    803809 <dhcp_recv+0x76>
  8037ed:	c7 44 24 08 9b 21 81 	movl   $0x81219b,0x8(%esp)
  8037f4:	00 
  8037f5:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  8037fc:	00 
  8037fd:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  803804:	e8 77 b6 00 00       	call   80ee80 <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  803809:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  80380d:	75 1c                	jne    80382b <dhcp_recv+0x98>
  80380f:	c7 44 24 08 a8 21 81 	movl   $0x8121a8,0x8(%esp)
  803816:	00 
  803817:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  80381e:	00 
  80381f:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  803826:	e8 55 b6 00 00       	call   80ee80 <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80382b:	89 f0                	mov    %esi,%eax
  80382d:	e8 60 f7 ff ff       	call   802f92 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  803832:	8b 46 0c             	mov    0xc(%esi),%eax
  803835:	8b 40 08             	mov    0x8(%eax),%eax
  803838:	66 3d f0 00          	cmp    $0xf0,%ax
  80383c:	76 1f                	jbe    80385d <dhcp_recv+0xca>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80383e:	2d f0 00 00 00       	sub    $0xf0,%eax
  803843:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  803847:	0f b7 c0             	movzwl %ax,%eax
  80384a:	89 04 24             	mov    %eax,(%esp)
  80384d:	e8 c6 0e 00 00       	call   804718 <mem_malloc>
  803852:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  803855:	85 c0                	test   %eax,%eax
  803857:	0f 84 60 03 00 00    	je     803bbd <dhcp_recv+0x42a>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80385d:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  803864:	e8 af 0e 00 00       	call   804718 <mem_malloc>
  803869:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  80386c:	85 c0                	test   %eax,%eax
  80386e:	75 17                	jne    803887 <dhcp_recv+0xf4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  803870:	8b 46 14             	mov    0x14(%esi),%eax
  803873:	89 04 24             	mov    %eax,(%esp)
  803876:	e8 c9 0b 00 00       	call   804444 <mem_free>
    dhcp->options_in = NULL;
  80387b:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  803882:	e9 36 03 00 00       	jmp    803bbd <dhcp_recv+0x42a>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  803887:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80388e:	00 
  80388f:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  803896:	00 
  803897:	89 44 24 04          	mov    %eax,0x4(%esp)
  80389b:	8b 46 0c             	mov    0xc(%esi),%eax
  80389e:	89 04 24             	mov    %eax,(%esp)
  8038a1:	e8 41 1c 00 00       	call   8054e7 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8038a6:	66 3d f0 00          	cmp    $0xf0,%ax
  8038aa:	74 1c                	je     8038c8 <dhcp_recv+0x135>
  8038ac:	c7 44 24 08 30 21 81 	movl   $0x812130,0x8(%esp)
  8038b3:	00 
  8038b4:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  8038bb:	00 
  8038bc:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  8038c3:	e8 b8 b5 00 00       	call   80ee80 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  8038c8:	8b 46 14             	mov    0x14(%esi),%eax
  8038cb:	85 c0                	test   %eax,%eax
  8038cd:	0f 84 01 03 00 00    	je     803bd4 <dhcp_recv+0x441>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8038d3:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  8038da:	00 
  8038db:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  8038df:	89 54 24 08          	mov    %edx,0x8(%esp)
  8038e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8038e7:	8b 46 0c             	mov    0xc(%esi),%eax
  8038ea:	89 04 24             	mov    %eax,(%esp)
  8038ed:	e8 f5 1b 00 00       	call   8054e7 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8038f2:	66 3b 46 18          	cmp    0x18(%esi),%ax
  8038f6:	0f 84 d8 02 00 00    	je     803bd4 <dhcp_recv+0x441>
  8038fc:	c7 44 24 08 b8 21 81 	movl   $0x8121b8,0x8(%esp)
  803903:	00 
  803904:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  80390b:	00 
  80390c:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  803913:	e8 68 b5 00 00       	call   80ee80 <_panic>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  803918:	83 c0 02             	add    $0x2,%eax
  80391b:	e8 11 f3 ff ff       	call   802c31 <dhcp_get_option_byte>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  803920:	3c 05                	cmp    $0x5,%al
  803922:	0f 85 c8 01 00 00    	jne    803af0 <dhcp_recv+0x35d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  803928:	8a 06                	mov    (%esi),%al
  80392a:	3c 01                	cmp    $0x1,%al
  80392c:	0f 85 a1 01 00 00    	jne    803ad3 <dhcp_recv+0x340>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803932:	8b 53 20             	mov    0x20(%ebx),%edx
  803935:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  803938:	c7 42 34 00 00 00 00 	movl   $0x0,0x34(%edx)
  dhcp->offered_gw_addr.addr = 0;
  80393f:	c7 42 38 00 00 00 00 	movl   $0x0,0x38(%edx)
  dhcp->offered_bc_addr.addr = 0;
  803946:	c7 42 3c 00 00 00 00 	movl   $0x0,0x3c(%edx)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  80394d:	ba 33 00 00 00       	mov    $0x33,%edx
  803952:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803955:	e8 d9 f1 ff ff       	call   802b33 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80395a:	85 c0                	test   %eax,%eax
  80395c:	74 0e                	je     80396c <dhcp_recv+0x1d9>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  80395e:	83 c0 02             	add    $0x2,%eax
  803961:	e8 d2 f2 ff ff       	call   802c38 <dhcp_get_option_long>
  803966:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803969:	89 41 4c             	mov    %eax,0x4c(%ecx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80396c:	ba 3a 00 00 00       	mov    $0x3a,%edx
  803971:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803974:	e8 ba f1 ff ff       	call   802b33 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803979:	85 c0                	test   %eax,%eax
  80397b:	74 10                	je     80398d <dhcp_recv+0x1fa>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  80397d:	83 c0 02             	add    $0x2,%eax
  803980:	e8 b3 f2 ff ff       	call   802c38 <dhcp_get_option_long>
  803985:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803988:	89 42 50             	mov    %eax,0x50(%edx)
  80398b:	eb 0b                	jmp    803998 <dhcp_recv+0x205>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  80398d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803990:	8b 41 4c             	mov    0x4c(%ecx),%eax
  803993:	d1 e8                	shr    %eax
  803995:	89 41 50             	mov    %eax,0x50(%ecx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  803998:	ba 3b 00 00 00       	mov    $0x3b,%edx
  80399d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8039a0:	e8 8e f1 ff ff       	call   802b33 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8039a5:	85 c0                	test   %eax,%eax
  8039a7:	74 10                	je     8039b9 <dhcp_recv+0x226>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8039a9:	83 c0 02             	add    $0x2,%eax
  8039ac:	e8 87 f2 ff ff       	call   802c38 <dhcp_get_option_long>
  8039b1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8039b4:	89 42 54             	mov    %eax,0x54(%edx)
  8039b7:	eb 09                	jmp    8039c2 <dhcp_recv+0x22f>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  8039b9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8039bc:	8b 41 4c             	mov    0x4c(%ecx),%eax
  8039bf:	89 41 54             	mov    %eax,0x54(%ecx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8039c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8039c5:	8b 50 10             	mov    0x10(%eax),%edx
  8039c8:	b8 00 00 00 00       	mov    $0x0,%eax
  8039cd:	83 fa f0             	cmp    $0xfffffff0,%edx
  8039d0:	74 03                	je     8039d5 <dhcp_recv+0x242>
  8039d2:	8b 42 10             	mov    0x10(%edx),%eax
  8039d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8039d8:	89 42 30             	mov    %eax,0x30(%edx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8039db:	ba 01 00 00 00       	mov    $0x1,%edx
  8039e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8039e3:	e8 4b f1 ff ff       	call   802b33 <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  8039e8:	85 c0                	test   %eax,%eax
  8039ea:	74 16                	je     803a02 <dhcp_recv+0x26f>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8039ec:	83 c0 02             	add    $0x2,%eax
  8039ef:	e8 44 f2 ff ff       	call   802c38 <dhcp_get_option_long>
  8039f4:	89 04 24             	mov    %eax,(%esp)
  8039f7:	e8 7d 42 00 00       	call   807c79 <htonl>
  8039fc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8039ff:	89 41 34             	mov    %eax,0x34(%ecx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803a02:	ba 03 00 00 00       	mov    $0x3,%edx
  803a07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a0a:	e8 24 f1 ff ff       	call   802b33 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a0f:	85 c0                	test   %eax,%eax
  803a11:	74 16                	je     803a29 <dhcp_recv+0x296>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803a13:	83 c0 02             	add    $0x2,%eax
  803a16:	e8 1d f2 ff ff       	call   802c38 <dhcp_get_option_long>
  803a1b:	89 04 24             	mov    %eax,(%esp)
  803a1e:	e8 56 42 00 00       	call   807c79 <htonl>
  803a23:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803a26:	89 42 38             	mov    %eax,0x38(%edx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803a29:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803a2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a31:	e8 fd f0 ff ff       	call   802b33 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a36:	85 c0                	test   %eax,%eax
  803a38:	74 16                	je     803a50 <dhcp_recv+0x2bd>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803a3a:	83 c0 02             	add    $0x2,%eax
  803a3d:	e8 f6 f1 ff ff       	call   802c38 <dhcp_get_option_long>
  803a42:	89 04 24             	mov    %eax,(%esp)
  803a45:	e8 2f 42 00 00       	call   807c79 <htonl>
  803a4a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a4d:	89 41 3c             	mov    %eax,0x3c(%ecx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803a50:	ba 06 00 00 00       	mov    $0x6,%edx
  803a55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a58:	e8 d6 f0 ff ff       	call   802b33 <dhcp_get_option_ptr>
  803a5d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (option_ptr != NULL) {
  803a60:	85 c0                	test   %eax,%eax
  803a62:	74 5d                	je     803ac1 <dhcp_recv+0x32e>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803a64:	40                   	inc    %eax
  803a65:	e8 c7 f1 ff ff       	call   802c31 <dhcp_get_option_byte>
  803a6a:	c0 e8 02             	shr    $0x2,%al
  803a6d:	0f b6 c0             	movzbl %al,%eax
  803a70:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803a73:	89 42 40             	mov    %eax,0x40(%edx)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  803a76:	83 f8 02             	cmp    $0x2,%eax
  803a79:	77 06                	ja     803a81 <dhcp_recv+0x2ee>
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803a7b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  803a7f:	eb 34                	jmp    803ab5 <dhcp_recv+0x322>
  if (option_ptr != NULL) {
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  803a81:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a84:	c7 41 40 02 00 00 00 	movl   $0x2,0x40(%ecx)
  803a8b:	eb ee                	jmp    803a7b <dhcp_recv+0x2e8>
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803a8d:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  803a91:	89 45 d8             	mov    %eax,-0x28(%ebp)
  803a94:	8b 55 dc             	mov    -0x24(%ebp),%edx
  803a97:	8d 44 82 02          	lea    0x2(%edx,%eax,4),%eax
  803a9b:	e8 98 f1 ff ff       	call   802c38 <dhcp_get_option_long>
  803aa0:	89 04 24             	mov    %eax,(%esp)
  803aa3:	e8 d1 41 00 00       	call   807c79 <htonl>
  803aa8:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  803aab:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803aae:	89 44 8a 44          	mov    %eax,0x44(%edx,%ecx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  803ab2:	fe 45 e3             	incb   -0x1d(%ebp)
  803ab5:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  803ab9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803abc:	3b 41 40             	cmp    0x40(%ecx),%eax
  803abf:	72 cc                	jb     803a8d <dhcp_recv+0x2fa>
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  803ac1:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  803ac7:	89 d8                	mov    %ebx,%eax
  803ac9:	e8 f8 fa ff ff       	call   8035c6 <dhcp_check>
  803ace:	e9 ea 00 00 00       	jmp    803bbd <dhcp_recv+0x42a>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803ad3:	83 e8 03             	sub    $0x3,%eax
  803ad6:	3c 02                	cmp    $0x2,%al
  803ad8:	0f 87 df 00 00 00    	ja     803bbd <dhcp_recv+0x42a>
      dhcp->request_timeout = 0;
  803ade:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  803ae4:	89 d8                	mov    %ebx,%eax
  803ae6:	e8 17 fb ff ff       	call   803602 <dhcp_bind>
  803aeb:	e9 cd 00 00 00       	jmp    803bbd <dhcp_recv+0x42a>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803af0:	3c 06                	cmp    $0x6,%al
  803af2:	75 70                	jne    803b64 <dhcp_recv+0x3d1>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  803af4:	8a 06                	mov    (%esi),%al
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803af6:	3c 03                	cmp    $0x3,%al
  803af8:	74 10                	je     803b0a <dhcp_recv+0x377>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  803afa:	3c 01                	cmp    $0x1,%al
  803afc:	74 0c                	je     803b0a <dhcp_recv+0x377>
  803afe:	3c 04                	cmp    $0x4,%al
  803b00:	74 08                	je     803b0a <dhcp_recv+0x377>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  803b02:	3c 05                	cmp    $0x5,%al
  803b04:	0f 85 b3 00 00 00    	jne    803bbd <dhcp_recv+0x42a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  803b0a:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803b10:	8b 43 20             	mov    0x20(%ebx),%eax
  803b13:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  803b16:	89 1c 24             	mov    %ebx,(%esp)
  803b19:	e8 29 11 00 00       	call   804c47 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803b1e:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  803b25:	00 
  803b26:	89 1c 24             	mov    %ebx,(%esp)
  803b29:	e8 16 0f 00 00       	call   804a44 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803b2e:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  803b35:	00 
  803b36:	89 1c 24             	mov    %ebx,(%esp)
  803b39:	e8 84 0f 00 00       	call   804ac2 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803b3e:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  803b45:	00 
  803b46:	89 1c 24             	mov    %ebx,(%esp)
  803b49:	e8 8f 0f 00 00       	call   804add <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803b4e:	ba 0c 00 00 00       	mov    $0xc,%edx
  803b53:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803b56:	e8 c9 ef ff ff       	call   802b24 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  803b5b:	89 d8                	mov    %ebx,%eax
  803b5d:	e8 5b f6 ff ff       	call   8031bd <dhcp_discover>
  803b62:	eb 59                	jmp    803bbd <dhcp_recv+0x42a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803b64:	3c 02                	cmp    $0x2,%al
  803b66:	75 55                	jne    803bbd <dhcp_recv+0x42a>
  803b68:	80 3e 06             	cmpb   $0x6,(%esi)
  803b6b:	75 50                	jne    803bbd <dhcp_recv+0x42a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  803b6d:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803b73:	8b 53 20             	mov    0x20(%ebx),%edx
  803b76:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803b79:	ba 36 00 00 00       	mov    $0x36,%edx
  803b7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803b81:	e8 ad ef ff ff       	call   802b33 <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  803b86:	85 c0                	test   %eax,%eax
  803b88:	74 33                	je     803bbd <dhcp_recv+0x42a>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803b8a:	83 c0 02             	add    $0x2,%eax
  803b8d:	e8 a6 f0 ff ff       	call   802c38 <dhcp_get_option_long>
  803b92:	89 04 24             	mov    %eax,(%esp)
  803b95:	e8 df 40 00 00       	call   807c79 <htonl>
  803b9a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803b9d:	89 41 2c             	mov    %eax,0x2c(%ecx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803ba0:	8b 51 10             	mov    0x10(%ecx),%edx
  803ba3:	b8 00 00 00 00       	mov    $0x0,%eax
  803ba8:	83 fa f0             	cmp    $0xfffffff0,%edx
  803bab:	74 03                	je     803bb0 <dhcp_recv+0x41d>
  803bad:	8b 42 10             	mov    0x10(%edx),%eax
  803bb0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803bb3:	89 42 30             	mov    %eax,0x30(%edx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  803bb6:	89 d8                	mov    %ebx,%eax
  803bb8:	e8 6e f8 ff ff       	call   80342b <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  803bbd:	89 3c 24             	mov    %edi,(%esp)
  803bc0:	e8 8c 11 00 00       	call   804d51 <pbuf_free>
  dhcp->p = NULL;
  803bc5:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
}
  803bcc:	83 c4 2c             	add    $0x2c,%esp
  803bcf:	5b                   	pop    %ebx
  803bd0:	5e                   	pop    %esi
  803bd1:	5f                   	pop    %edi
  803bd2:	5d                   	pop    %ebp
  803bd3:	c3                   	ret    
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803bd4:	ba 35 00 00 00       	mov    $0x35,%edx
  803bd9:	89 f0                	mov    %esi,%eax
  803bdb:	e8 53 ef ff ff       	call   802b33 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  803be0:	85 c0                	test   %eax,%eax
  803be2:	0f 85 30 fd ff ff    	jne    803918 <dhcp_recv+0x185>
  803be8:	eb d3                	jmp    803bbd <dhcp_recv+0x42a>

00803bea <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  803bea:	55                   	push   %ebp
  803beb:	89 e5                	mov    %esp,%ebp
  803bed:	57                   	push   %edi
  803bee:	56                   	push   %esi
  803bef:	53                   	push   %ebx
  803bf0:	83 ec 2c             	sub    $0x2c,%esp
  803bf3:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803bf6:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  803bf9:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  803c00:	e8 13 0b 00 00       	call   804718 <mem_malloc>
  803c05:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  803c07:	85 c0                	test   %eax,%eax
  803c09:	0f 84 3d 01 00 00    	je     803d4c <dhcp_inform+0x162>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  803c0f:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803c12:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  803c19:	00 
  803c1a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c21:	00 
  803c22:	89 04 24             	mov    %eax,(%esp)
  803c25:	e8 28 ba 00 00       	call   80f652 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  803c2a:	e8 97 5a 00 00       	call   8096c6 <udp_new>
  803c2f:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803c32:	85 c0                	test   %eax,%eax
  803c34:	75 0d                	jne    803c43 <dhcp_inform+0x59>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  803c36:	89 1c 24             	mov    %ebx,(%esp)
  803c39:	e8 06 08 00 00       	call   804444 <mem_free>
    return;
  803c3e:	e9 09 01 00 00       	jmp    803d4c <dhcp_inform+0x162>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803c43:	89 f0                	mov    %esi,%eax
  803c45:	e8 89 f3 ff ff       	call   802fd3 <dhcp_create_request>
  if (result == ERR_OK) {
  803c4a:	84 c0                	test   %al,%al
  803c4c:	0f 85 d9 00 00 00    	jne    803d2b <dhcp_inform+0x141>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803c52:	b9 01 00 00 00       	mov    $0x1,%ecx
  803c57:	ba 35 00 00 00       	mov    $0x35,%edx
  803c5c:	89 d8                	mov    %ebx,%eax
  803c5e:	e8 fa ef ff ff       	call   802c5d <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803c63:	ba 08 00 00 00       	mov    $0x8,%edx
  803c68:	89 d8                	mov    %ebx,%eax
  803c6a:	e8 58 f0 ff ff       	call   802cc7 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803c6f:	b9 02 00 00 00       	mov    $0x2,%ecx
  803c74:	ba 39 00 00 00       	mov    $0x39,%edx
  803c79:	89 d8                	mov    %ebx,%eax
  803c7b:	e8 dd ef ff ff       	call   802c5d <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  803c80:	ba 40 02 00 00       	mov    $0x240,%edx
  803c85:	89 d8                	mov    %ebx,%eax
  803c87:	e8 45 f1 ff ff       	call   802dd1 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  803c8c:	89 d8                	mov    %ebx,%eax
  803c8e:	e8 7a f0 ff ff       	call   802d0d <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803c93:	8b 43 24             	mov    0x24(%ebx),%eax
  803c96:	05 f0 00 00 00       	add    $0xf0,%eax
  803c9b:	0f b7 c0             	movzwl %ax,%eax
  803c9e:	89 44 24 04          	mov    %eax,0x4(%esp)
  803ca2:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803ca5:	89 04 24             	mov    %eax,(%esp)
  803ca8:	e8 76 11 00 00       	call   804e23 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803cad:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  803cb4:	00 
  803cb5:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  803cbc:	00 
  803cbd:	8b 43 08             	mov    0x8(%ebx),%eax
  803cc0:	89 04 24             	mov    %eax,(%esp)
  803cc3:	e8 36 56 00 00       	call   8092fe <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803cc8:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803ccf:	00 
  803cd0:	c7 44 24 04 34 2a 81 	movl   $0x812a34,0x4(%esp)
  803cd7:	00 
  803cd8:	8b 43 08             	mov    0x8(%ebx),%eax
  803cdb:	89 04 24             	mov    %eax,(%esp)
  803cde:	e8 fb 58 00 00       	call   8095de <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803ce3:	89 74 24 10          	mov    %esi,0x10(%esp)
  803ce7:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803cee:	00 
  803cef:	c7 44 24 08 34 2a 81 	movl   $0x812a34,0x8(%esp)
  803cf6:	00 
  803cf7:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803cfa:	89 44 24 04          	mov    %eax,0x4(%esp)
  803cfe:	8b 43 08             	mov    0x8(%ebx),%eax
  803d01:	89 04 24             	mov    %eax,(%esp)
  803d04:	e8 b0 56 00 00       	call   8093b9 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803d09:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803d10:	00 
  803d11:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  803d18:	00 
  803d19:	8b 43 08             	mov    0x8(%ebx),%eax
  803d1c:	89 04 24             	mov    %eax,(%esp)
  803d1f:	e8 ba 58 00 00       	call   8095de <udp_connect>
    dhcp_delete_request(netif);
  803d24:	89 f0                	mov    %esi,%eax
  803d26:	e8 bc f1 ff ff       	call   802ee7 <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  803d2b:	8b 43 08             	mov    0x8(%ebx),%eax
  803d2e:	85 c0                	test   %eax,%eax
  803d30:	74 08                	je     803d3a <dhcp_inform+0x150>
      udp_remove(dhcp->pcb);
  803d32:	89 04 24             	mov    %eax,(%esp)
  803d35:	e8 46 59 00 00       	call   809680 <udp_remove>
    }
    dhcp->pcb = NULL;
  803d3a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803d41:	89 1c 24             	mov    %ebx,(%esp)
  803d44:	e8 fb 06 00 00       	call   804444 <mem_free>
    netif->dhcp = old_dhcp;
  803d49:	89 7e 20             	mov    %edi,0x20(%esi)
  }
}
  803d4c:	83 c4 2c             	add    $0x2c,%esp
  803d4f:	5b                   	pop    %ebx
  803d50:	5e                   	pop    %esi
  803d51:	5f                   	pop    %edi
  803d52:	5d                   	pop    %ebp
  803d53:	c3                   	ret    

00803d54 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  803d54:	55                   	push   %ebp
  803d55:	89 e5                	mov    %esp,%ebp
  803d57:	56                   	push   %esi
  803d58:	53                   	push   %ebx
  803d59:	83 ec 20             	sub    $0x20,%esp
  803d5c:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803d5f:	85 f6                	test   %esi,%esi
  803d61:	75 1c                	jne    803d7f <dhcp_arp_reply+0x2b>
  803d63:	c7 44 24 08 82 21 81 	movl   $0x812182,0x8(%esp)
  803d6a:	00 
  803d6b:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  803d72:	00 
  803d73:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  803d7a:	e8 01 b1 00 00       	call   80ee80 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803d7f:	8b 5e 20             	mov    0x20(%esi),%ebx
  803d82:	85 db                	test   %ebx,%ebx
  803d84:	0f 84 03 01 00 00    	je     803e8d <dhcp_arp_reply+0x139>
  803d8a:	80 3b 08             	cmpb   $0x8,(%ebx)
  803d8d:	0f 85 fa 00 00 00    	jne    803e8d <dhcp_arp_reply+0x139>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803d93:	8b 45 0c             	mov    0xc(%ebp),%eax
  803d96:	8b 53 30             	mov    0x30(%ebx),%edx
  803d99:	39 10                	cmp    %edx,(%eax)
  803d9b:	0f 85 ec 00 00 00    	jne    803e8d <dhcp_arp_reply+0x139>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803da1:	ba 0c 00 00 00       	mov    $0xc,%edx
  803da6:	89 d8                	mov    %ebx,%eax
  803da8:	e8 77 ed ff ff       	call   802b24 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803dad:	89 f0                	mov    %esi,%eax
  803daf:	e8 1f f2 ff ff       	call   802fd3 <dhcp_create_request>
  if (result == ERR_OK) {
  803db4:	84 c0                	test   %al,%al
  803db6:	0f 85 c8 00 00 00    	jne    803e84 <dhcp_arp_reply+0x130>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803dbc:	b9 01 00 00 00       	mov    $0x1,%ecx
  803dc1:	ba 35 00 00 00       	mov    $0x35,%edx
  803dc6:	89 d8                	mov    %ebx,%eax
  803dc8:	e8 90 ee ff ff       	call   802c5d <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803dcd:	ba 04 00 00 00       	mov    $0x4,%edx
  803dd2:	89 d8                	mov    %ebx,%eax
  803dd4:	e8 ee ee ff ff       	call   802cc7 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803dd9:	b9 02 00 00 00       	mov    $0x2,%ecx
  803dde:	ba 39 00 00 00       	mov    $0x39,%edx
  803de3:	89 d8                	mov    %ebx,%eax
  803de5:	e8 73 ee ff ff       	call   802c5d <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803dea:	ba 40 02 00 00       	mov    $0x240,%edx
  803def:	89 d8                	mov    %ebx,%eax
  803df1:	e8 db ef ff ff       	call   802dd1 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803df6:	b9 04 00 00 00       	mov    $0x4,%ecx
  803dfb:	ba 32 00 00 00       	mov    $0x32,%edx
  803e00:	89 d8                	mov    %ebx,%eax
  803e02:	e8 56 ee ff ff       	call   802c5d <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803e07:	8b 43 30             	mov    0x30(%ebx),%eax
  803e0a:	89 04 24             	mov    %eax,(%esp)
  803e0d:	e8 bd 40 00 00       	call   807ecf <ntohl>
  803e12:	89 c2                	mov    %eax,%edx
  803e14:	89 d8                	mov    %ebx,%eax
  803e16:	e8 28 f0 ff ff       	call   802e43 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  803e1b:	89 d8                	mov    %ebx,%eax
  803e1d:	e8 eb ee ff ff       	call   802d0d <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803e22:	8b 43 24             	mov    0x24(%ebx),%eax
  803e25:	05 f0 00 00 00       	add    $0xf0,%eax
  803e2a:	0f b7 c0             	movzwl %ax,%eax
  803e2d:	89 44 24 04          	mov    %eax,0x4(%esp)
  803e31:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803e34:	89 04 24             	mov    %eax,(%esp)
  803e37:	e8 e7 0f 00 00       	call   804e23 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803e3c:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803e43:	00 
  803e44:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  803e4b:	00 
  803e4c:	8b 43 08             	mov    0x8(%ebx),%eax
  803e4f:	89 04 24             	mov    %eax,(%esp)
  803e52:	e8 87 57 00 00       	call   8095de <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803e57:	89 74 24 10          	mov    %esi,0x10(%esp)
  803e5b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803e62:	00 
  803e63:	c7 44 24 08 34 2a 81 	movl   $0x812a34,0x8(%esp)
  803e6a:	00 
  803e6b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803e6e:	89 44 24 04          	mov    %eax,0x4(%esp)
  803e72:	8b 43 08             	mov    0x8(%ebx),%eax
  803e75:	89 04 24             	mov    %eax,(%esp)
  803e78:	e8 3c 55 00 00       	call   8093b9 <udp_sendto_if>
    dhcp_delete_request(netif);
  803e7d:	89 f0                	mov    %esi,%eax
  803e7f:	e8 63 f0 ff ff       	call   802ee7 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803e84:	fe 43 01             	incb   0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803e87:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  803e8d:	83 c4 20             	add    $0x20,%esp
  803e90:	5b                   	pop    %ebx
  803e91:	5e                   	pop    %esi
  803e92:	5d                   	pop    %ebp
  803e93:	c3                   	ret    

00803e94 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  803e94:	55                   	push   %ebp
  803e95:	89 e5                	mov    %esp,%ebp
  803e97:	57                   	push   %edi
  803e98:	56                   	push   %esi
  803e99:	53                   	push   %ebx
  803e9a:	83 ec 3c             	sub    $0x3c,%esp
  803e9d:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803ea0:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803ea3:	ba 05 00 00 00       	mov    $0x5,%edx
  803ea8:	89 d8                	mov    %ebx,%eax
  803eaa:	e8 75 ec ff ff       	call   802b24 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803eaf:	89 f8                	mov    %edi,%eax
  803eb1:	e8 1d f1 ff ff       	call   802fd3 <dhcp_create_request>
  803eb6:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803eb8:	84 c0                	test   %al,%al
  803eba:	0f 85 a4 00 00 00    	jne    803f64 <dhcp_renew+0xd0>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803ec0:	b9 01 00 00 00       	mov    $0x1,%ecx
  803ec5:	ba 35 00 00 00       	mov    $0x35,%edx
  803eca:	89 d8                	mov    %ebx,%eax
  803ecc:	e8 8c ed ff ff       	call   802c5d <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803ed1:	ba 03 00 00 00       	mov    $0x3,%edx
  803ed6:	89 d8                	mov    %ebx,%eax
  803ed8:	e8 ea ed ff ff       	call   802cc7 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803edd:	b9 02 00 00 00       	mov    $0x2,%ecx
  803ee2:	ba 39 00 00 00       	mov    $0x39,%edx
  803ee7:	89 d8                	mov    %ebx,%eax
  803ee9:	e8 6f ed ff ff       	call   802c5d <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  803eee:	ba 40 02 00 00       	mov    $0x240,%edx
  803ef3:	89 d8                	mov    %ebx,%eax
  803ef5:	e8 d7 ee ff ff       	call   802dd1 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  803efa:	89 d8                	mov    %ebx,%eax
  803efc:	e8 0c ee ff ff       	call   802d0d <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803f01:	8b 43 24             	mov    0x24(%ebx),%eax
  803f04:	05 f0 00 00 00       	add    $0xf0,%eax
  803f09:	0f b7 c0             	movzwl %ax,%eax
  803f0c:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f10:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803f13:	89 04 24             	mov    %eax,(%esp)
  803f16:	e8 08 0f 00 00       	call   804e23 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803f1b:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803f1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803f21:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803f28:	00 
  803f29:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f2d:	8b 43 08             	mov    0x8(%ebx),%eax
  803f30:	89 04 24             	mov    %eax,(%esp)
  803f33:	e8 a6 56 00 00       	call   8095de <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803f38:	89 7c 24 10          	mov    %edi,0x10(%esp)
  803f3c:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803f43:	00 
  803f44:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803f47:	89 44 24 08          	mov    %eax,0x8(%esp)
  803f4b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803f4e:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f52:	8b 43 08             	mov    0x8(%ebx),%eax
  803f55:	89 04 24             	mov    %eax,(%esp)
  803f58:	e8 5c 54 00 00       	call   8093b9 <udp_sendto_if>
    dhcp_delete_request(netif);
  803f5d:	89 f8                	mov    %edi,%eax
  803f5f:	e8 83 ef ff ff       	call   802ee7 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803f64:	8a 43 01             	mov    0x1(%ebx),%al
  803f67:	40                   	inc    %eax
  803f68:	88 43 01             	mov    %al,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803f6b:	3c 09                	cmp    $0x9,%al
  803f6d:	77 11                	ja     803f80 <dhcp_renew+0xec>
  803f6f:	0f b6 d0             	movzbl %al,%edx
  803f72:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803f75:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803f78:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803f7b:	c1 e2 04             	shl    $0x4,%edx
  803f7e:	eb 05                	jmp    803f85 <dhcp_renew+0xf1>
  803f80:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803f85:	0f b7 d2             	movzwl %dx,%edx
  803f88:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803f8e:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  803f93:	f7 ea                	imul   %edx
  803f95:	89 d0                	mov    %edx,%eax
  803f97:	c1 f8 05             	sar    $0x5,%eax
  803f9a:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803f9e:	89 f0                	mov    %esi,%eax
  803fa0:	83 c4 3c             	add    $0x3c,%esp
  803fa3:	5b                   	pop    %ebx
  803fa4:	5e                   	pop    %esi
  803fa5:	5f                   	pop    %edi
  803fa6:	5d                   	pop    %ebp
  803fa7:	c3                   	ret    

00803fa8 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  803fa8:	55                   	push   %ebp
  803fa9:	89 e5                	mov    %esp,%ebp
  803fab:	53                   	push   %ebx
  803fac:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  803faf:	8b 1d 74 c2 b3 00    	mov    0xb3c274,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803fb5:	eb 60                	jmp    804017 <dhcp_coarse_tmr+0x6f>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803fb7:	8b 43 20             	mov    0x20(%ebx),%eax
  803fba:	85 c0                	test   %eax,%eax
  803fbc:	74 57                	je     804015 <dhcp_coarse_tmr+0x6d>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  803fbe:	66 8b 50 2a          	mov    0x2a(%eax),%dx
  803fc2:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803fc5:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803fc9:	66 83 fa 01          	cmp    $0x1,%dx
  803fcd:	75 1a                	jne    803fe9 <dhcp_coarse_tmr+0x41>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803fcf:	8b 43 20             	mov    0x20(%ebx),%eax
  803fd2:	8a 00                	mov    (%eax),%al
  803fd4:	3c 01                	cmp    $0x1,%al
  803fd6:	74 08                	je     803fe0 <dhcp_coarse_tmr+0x38>
  803fd8:	3c 0a                	cmp    $0xa,%al
  803fda:	74 04                	je     803fe0 <dhcp_coarse_tmr+0x38>
  803fdc:	3c 05                	cmp    $0x5,%al
  803fde:	75 35                	jne    804015 <dhcp_coarse_tmr+0x6d>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  803fe0:	89 d8                	mov    %ebx,%eax
  803fe2:	e8 32 f3 ff ff       	call   803319 <dhcp_rebind>
  803fe7:	eb 2c                	jmp    804015 <dhcp_coarse_tmr+0x6d>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803fe9:	8b 53 20             	mov    0x20(%ebx),%edx
  803fec:	8b 42 28             	mov    0x28(%edx),%eax
  803fef:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803ff2:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803ff6:	66 83 f8 01          	cmp    $0x1,%ax
  803ffa:	75 19                	jne    804015 <dhcp_coarse_tmr+0x6d>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803ffc:	8b 43 20             	mov    0x20(%ebx),%eax
  803fff:	8a 00                	mov    (%eax),%al
  804001:	3c 01                	cmp    $0x1,%al
  804003:	74 08                	je     80400d <dhcp_coarse_tmr+0x65>
  804005:	3c 0a                	cmp    $0xa,%al
  804007:	74 04                	je     80400d <dhcp_coarse_tmr+0x65>
  804009:	3c 05                	cmp    $0x5,%al
  80400b:	75 08                	jne    804015 <dhcp_coarse_tmr+0x6d>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  80400d:	89 1c 24             	mov    %ebx,(%esp)
  804010:	e8 7f fe ff ff       	call   803e94 <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  804015:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  804017:	85 db                	test   %ebx,%ebx
  804019:	75 9c                	jne    803fb7 <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  80401b:	83 c4 14             	add    $0x14,%esp
  80401e:	5b                   	pop    %ebx
  80401f:	5d                   	pop    %ebp
  804020:	c3                   	ret    

00804021 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  804021:	55                   	push   %ebp
  804022:	89 e5                	mov    %esp,%ebp
  804024:	57                   	push   %edi
  804025:	56                   	push   %esi
  804026:	53                   	push   %ebx
  804027:	83 ec 3c             	sub    $0x3c,%esp
  80402a:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  80402d:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  804030:	ba 0d 00 00 00       	mov    $0xd,%edx
  804035:	89 d8                	mov    %ebx,%eax
  804037:	e8 e8 ea ff ff       	call   802b24 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  80403c:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  804043:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  80404a:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  804051:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  804058:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80405f:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  804066:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  80406d:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  804074:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80407b:	89 f0                	mov    %esi,%eax
  80407d:	e8 51 ef ff ff       	call   802fd3 <dhcp_create_request>
  804082:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  804084:	84 c0                	test   %al,%al
  804086:	0f 85 87 00 00 00    	jne    804113 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80408c:	b9 01 00 00 00       	mov    $0x1,%ecx
  804091:	ba 35 00 00 00       	mov    $0x35,%edx
  804096:	89 d8                	mov    %ebx,%eax
  804098:	e8 c0 eb ff ff       	call   802c5d <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80409d:	ba 07 00 00 00       	mov    $0x7,%edx
  8040a2:	89 d8                	mov    %ebx,%eax
  8040a4:	e8 1e ec ff ff       	call   802cc7 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  8040a9:	89 d8                	mov    %ebx,%eax
  8040ab:	e8 5d ec ff ff       	call   802d0d <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8040b0:	8b 43 24             	mov    0x24(%ebx),%eax
  8040b3:	05 f0 00 00 00       	add    $0xf0,%eax
  8040b8:	0f b7 c0             	movzwl %ax,%eax
  8040bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8040bf:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8040c2:	89 04 24             	mov    %eax,(%esp)
  8040c5:	e8 59 0d 00 00       	call   804e23 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  8040ca:	8d 43 2c             	lea    0x2c(%ebx),%eax
  8040cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8040d0:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8040d7:	00 
  8040d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8040dc:	8b 43 08             	mov    0x8(%ebx),%eax
  8040df:	89 04 24             	mov    %eax,(%esp)
  8040e2:	e8 f7 54 00 00       	call   8095de <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  8040e7:	89 74 24 10          	mov    %esi,0x10(%esp)
  8040eb:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8040f2:	00 
  8040f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8040f6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8040fa:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8040fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  804101:	8b 43 08             	mov    0x8(%ebx),%eax
  804104:	89 04 24             	mov    %eax,(%esp)
  804107:	e8 ad 52 00 00       	call   8093b9 <udp_sendto_if>
    dhcp_delete_request(netif);
  80410c:	89 f0                	mov    %esi,%eax
  80410e:	e8 d4 ed ff ff       	call   802ee7 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  804113:	8a 43 01             	mov    0x1(%ebx),%al
  804116:	40                   	inc    %eax
  804117:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80411a:	3c 09                	cmp    $0x9,%al
  80411c:	77 11                	ja     80412f <dhcp_release+0x10e>
  80411e:	0f b6 d0             	movzbl %al,%edx
  804121:	8d 14 92             	lea    (%edx,%edx,4),%edx
  804124:	8d 14 92             	lea    (%edx,%edx,4),%edx
  804127:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80412a:	c1 e2 03             	shl    $0x3,%edx
  80412d:	eb 05                	jmp    804134 <dhcp_release+0x113>
  80412f:	ba 10 27 00 00       	mov    $0x2710,%edx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  804134:	0f b7 d2             	movzwl %dx,%edx
  804137:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80413d:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  804142:	f7 ea                	imul   %edx
  804144:	89 d0                	mov    %edx,%eax
  804146:	c1 f8 05             	sar    $0x5,%eax
  804149:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80414d:	89 34 24             	mov    %esi,(%esp)
  804150:	e8 f2 0a 00 00       	call   804c47 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  804155:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  80415c:	00 
  80415d:	89 34 24             	mov    %esi,(%esp)
  804160:	e8 df 08 00 00       	call   804a44 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  804165:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  80416c:	00 
  80416d:	89 34 24             	mov    %esi,(%esp)
  804170:	e8 4d 09 00 00       	call   804ac2 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  804175:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  80417c:	00 
  80417d:	89 34 24             	mov    %esi,(%esp)
  804180:	e8 58 09 00 00       	call   804add <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  804185:	89 f8                	mov    %edi,%eax
  804187:	83 c4 3c             	add    $0x3c,%esp
  80418a:	5b                   	pop    %ebx
  80418b:	5e                   	pop    %esi
  80418c:	5f                   	pop    %edi
  80418d:	5d                   	pop    %ebp
  80418e:	c3                   	ret    

0080418f <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  80418f:	55                   	push   %ebp
  804190:	89 e5                	mov    %esp,%ebp
  804192:	53                   	push   %ebx
  804193:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  804196:	8b 1d 74 c2 b3 00    	mov    0xb3c274,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  80419c:	e9 b7 00 00 00       	jmp    804258 <dhcp_fine_tmr+0xc9>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8041a1:	8b 43 20             	mov    0x20(%ebx),%eax
  8041a4:	85 c0                	test   %eax,%eax
  8041a6:	0f 84 aa 00 00 00    	je     804256 <dhcp_fine_tmr+0xc7>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  8041ac:	66 8b 50 26          	mov    0x26(%eax),%dx
  8041b0:	66 83 fa 01          	cmp    $0x1,%dx
  8041b4:	76 0a                	jbe    8041c0 <dhcp_fine_tmr+0x31>
        netif->dhcp->request_timeout--;
  8041b6:	4a                   	dec    %edx
  8041b7:	66 89 50 26          	mov    %dx,0x26(%eax)
  8041bb:	e9 96 00 00 00       	jmp    804256 <dhcp_fine_tmr+0xc7>
      }
      else if (netif->dhcp->request_timeout == 1) {
  8041c0:	66 83 fa 01          	cmp    $0x1,%dx
  8041c4:	0f 85 8c 00 00 00    	jne    804256 <dhcp_fine_tmr+0xc7>
        netif->dhcp->request_timeout--;
  8041ca:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  8041d0:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  8041d3:	8a 02                	mov    (%edx),%al
  8041d5:	3c 0c                	cmp    $0xc,%al
  8041d7:	74 04                	je     8041dd <dhcp_fine_tmr+0x4e>
  8041d9:	3c 06                	cmp    $0x6,%al
  8041db:	75 09                	jne    8041e6 <dhcp_fine_tmr+0x57>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  8041dd:	89 d8                	mov    %ebx,%eax
  8041df:	e8 d9 ef ff ff       	call   8031bd <dhcp_discover>
  8041e4:	eb 70                	jmp    804256 <dhcp_fine_tmr+0xc7>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  8041e6:	3c 01                	cmp    $0x1,%al
  8041e8:	75 20                	jne    80420a <dhcp_fine_tmr+0x7b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  8041ea:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  8041ee:	77 09                	ja     8041f9 <dhcp_fine_tmr+0x6a>
      dhcp_select(netif);
  8041f0:	89 d8                	mov    %ebx,%eax
  8041f2:	e8 34 f2 ff ff       	call   80342b <dhcp_select>
  8041f7:	eb 5d                	jmp    804256 <dhcp_fine_tmr+0xc7>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  8041f9:	89 1c 24             	mov    %ebx,(%esp)
  8041fc:	e8 20 fe ff ff       	call   804021 <dhcp_release>
      dhcp_discover(netif);
  804201:	89 d8                	mov    %ebx,%eax
  804203:	e8 b5 ef ff ff       	call   8031bd <dhcp_discover>
  804208:	eb 4c                	jmp    804256 <dhcp_fine_tmr+0xc7>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  80420a:	3c 08                	cmp    $0x8,%al
  80420c:	75 18                	jne    804226 <dhcp_fine_tmr+0x97>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  80420e:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  804212:	77 09                	ja     80421d <dhcp_fine_tmr+0x8e>
      dhcp_check(netif);
  804214:	89 d8                	mov    %ebx,%eax
  804216:	e8 ab f3 ff ff       	call   8035c6 <dhcp_check>
  80421b:	eb 39                	jmp    804256 <dhcp_fine_tmr+0xc7>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  80421d:	89 d8                	mov    %ebx,%eax
  80421f:	e8 de f3 ff ff       	call   803602 <dhcp_bind>
  804224:	eb 30                	jmp    804256 <dhcp_fine_tmr+0xc7>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  804226:	3c 05                	cmp    $0x5,%al
  804228:	75 0a                	jne    804234 <dhcp_fine_tmr+0xa5>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  80422a:	89 1c 24             	mov    %ebx,(%esp)
  80422d:	e8 62 fc ff ff       	call   803e94 <dhcp_renew>
  804232:	eb 22                	jmp    804256 <dhcp_fine_tmr+0xc7>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  804234:	3c 04                	cmp    $0x4,%al
  804236:	75 1e                	jne    804256 <dhcp_fine_tmr+0xc7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  804238:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  80423c:	77 09                	ja     804247 <dhcp_fine_tmr+0xb8>
      dhcp_rebind(netif);
  80423e:	89 d8                	mov    %ebx,%eax
  804240:	e8 d4 f0 ff ff       	call   803319 <dhcp_rebind>
  804245:	eb 0f                	jmp    804256 <dhcp_fine_tmr+0xc7>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  804247:	89 1c 24             	mov    %ebx,(%esp)
  80424a:	e8 d2 fd ff ff       	call   804021 <dhcp_release>
      dhcp_discover(netif);
  80424f:	89 d8                	mov    %ebx,%eax
  804251:	e8 67 ef ff ff       	call   8031bd <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  804256:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  804258:	85 db                	test   %ebx,%ebx
  80425a:	0f 85 41 ff ff ff    	jne    8041a1 <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  804260:	83 c4 14             	add    $0x14,%esp
  804263:	5b                   	pop    %ebx
  804264:	5d                   	pop    %ebp
  804265:	c3                   	ret    

00804266 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  804266:	55                   	push   %ebp
  804267:	89 e5                	mov    %esp,%ebp
  804269:	56                   	push   %esi
  80426a:	53                   	push   %ebx
  80426b:	83 ec 10             	sub    $0x10,%esp
  80426e:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  804271:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  804274:	85 f6                	test   %esi,%esi
  804276:	75 1c                	jne    804294 <dhcp_stop+0x2e>
  804278:	c7 44 24 08 d4 21 81 	movl   $0x8121d4,0x8(%esp)
  80427f:	00 
  804280:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  804287:	00 
  804288:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  80428f:	e8 ec ab 00 00       	call   80ee80 <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  804294:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  804298:	85 db                	test   %ebx,%ebx
  80429a:	74 42                	je     8042de <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  80429c:	8b 43 08             	mov    0x8(%ebx),%eax
  80429f:	85 c0                	test   %eax,%eax
  8042a1:	74 0f                	je     8042b2 <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  8042a3:	89 04 24             	mov    %eax,(%esp)
  8042a6:	e8 d5 53 00 00       	call   809680 <udp_remove>
      dhcp->pcb = NULL;
  8042ab:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  8042b2:	8b 43 0c             	mov    0xc(%ebx),%eax
  8042b5:	85 c0                	test   %eax,%eax
  8042b7:	74 0f                	je     8042c8 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  8042b9:	89 04 24             	mov    %eax,(%esp)
  8042bc:	e8 90 0a 00 00       	call   804d51 <pbuf_free>
      dhcp->p = NULL;
  8042c1:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  8042c8:	89 d8                	mov    %ebx,%eax
  8042ca:	e8 c3 ec ff ff       	call   802f92 <dhcp_free_reply>
    mem_free((void *)dhcp);
  8042cf:	89 1c 24             	mov    %ebx,(%esp)
  8042d2:	e8 6d 01 00 00       	call   804444 <mem_free>
    netif->dhcp = NULL;
  8042d7:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  8042de:	83 c4 10             	add    $0x10,%esp
  8042e1:	5b                   	pop    %ebx
  8042e2:	5e                   	pop    %esi
  8042e3:	5d                   	pop    %ebp
  8042e4:	c3                   	ret    

008042e5 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  8042e5:	55                   	push   %ebp
  8042e6:	89 e5                	mov    %esp,%ebp
  8042e8:	56                   	push   %esi
  8042e9:	53                   	push   %ebx
  8042ea:	83 ec 10             	sub    $0x10,%esp
  8042ed:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  8042f0:	85 f6                	test   %esi,%esi
  8042f2:	75 1c                	jne    804310 <dhcp_start+0x2b>
  8042f4:	c7 44 24 08 82 21 81 	movl   $0x812182,0x8(%esp)
  8042fb:	00 
  8042fc:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  804303:	00 
  804304:	c7 04 24 62 21 81 00 	movl   $0x812162,(%esp)
  80430b:	e8 70 ab 00 00       	call   80ee80 <_panic>
  dhcp = netif->dhcp;
  804310:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  804313:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  804317:	85 db                	test   %ebx,%ebx
  804319:	75 19                	jne    804334 <dhcp_start+0x4f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  80431b:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  804322:	e8 f1 03 00 00       	call   804718 <mem_malloc>
  804327:	89 c3                	mov    %eax,%ebx
    if (dhcp == NULL) {
  804329:	85 c0                	test   %eax,%eax
  80432b:	0f 84 a1 00 00 00    	je     8043d2 <dhcp_start+0xed>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  804331:	89 46 20             	mov    %eax,0x20(%esi)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  804334:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  80433b:	00 
  80433c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804343:	00 
  804344:	89 1c 24             	mov    %ebx,(%esp)
  804347:	e8 06 b3 00 00       	call   80f652 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  80434c:	e8 75 53 00 00       	call   8096c6 <udp_new>
  804351:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  804354:	85 c0                	test   %eax,%eax
  804356:	75 13                	jne    80436b <dhcp_start+0x86>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  804358:	89 1c 24             	mov    %ebx,(%esp)
  80435b:	e8 e4 00 00 00       	call   804444 <mem_free>
    netif->dhcp = dhcp = NULL;
  804360:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
    return ERR_MEM;
  804367:	b0 ff                	mov    $0xff,%al
  804369:	eb 69                	jmp    8043d4 <dhcp_start+0xef>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80436b:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  804372:	00 
  804373:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  80437a:	00 
  80437b:	89 04 24             	mov    %eax,(%esp)
  80437e:	e8 7b 4f 00 00       	call   8092fe <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  804383:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80438a:	00 
  80438b:	c7 44 24 04 38 2a 81 	movl   $0x812a38,0x4(%esp)
  804392:	00 
  804393:	8b 43 08             	mov    0x8(%ebx),%eax
  804396:	89 04 24             	mov    %eax,(%esp)
  804399:	e8 40 52 00 00       	call   8095de <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  80439e:	89 74 24 08          	mov    %esi,0x8(%esp)
  8043a2:	c7 44 24 04 93 37 80 	movl   $0x803793,0x4(%esp)
  8043a9:	00 
  8043aa:	8b 43 08             	mov    0x8(%ebx),%eax
  8043ad:	89 04 24             	mov    %eax,(%esp)
  8043b0:	e8 b7 52 00 00       	call   80966c <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  8043b5:	89 f0                	mov    %esi,%eax
  8043b7:	e8 01 ee ff ff       	call   8031bd <dhcp_discover>
  if (result != ERR_OK) {
  8043bc:	84 c0                	test   %al,%al
  8043be:	74 0c                	je     8043cc <dhcp_start+0xe7>
    /* free resources allocated above */
    dhcp_stop(netif);
  8043c0:	89 34 24             	mov    %esi,(%esp)
  8043c3:	e8 9e fe ff ff       	call   804266 <dhcp_stop>
    return ERR_MEM;
  8043c8:	b0 ff                	mov    $0xff,%al
  8043ca:	eb 08                	jmp    8043d4 <dhcp_start+0xef>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  8043cc:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  return result;
  8043d0:	eb 02                	jmp    8043d4 <dhcp_start+0xef>
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  8043d2:	b0 ff                	mov    $0xff,%al
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
  8043d4:	83 c4 10             	add    $0x10,%esp
  8043d7:	5b                   	pop    %ebx
  8043d8:	5e                   	pop    %esi
  8043d9:	5d                   	pop    %ebp
  8043da:	c3                   	ret    
	...

008043dc <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  8043dc:	55                   	push   %ebp
  8043dd:	89 e5                	mov    %esp,%ebp
  8043df:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  8043e2:	b8 23 63 81 00       	mov    $0x816323,%eax
  8043e7:	83 e0 fc             	and    $0xfffffffc,%eax
  8043ea:	a3 3c 63 a3 00       	mov    %eax,0xa3633c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  8043ef:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  8043f5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  8043fc:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  804400:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  804406:	89 15 40 63 a3 00    	mov    %edx,0xa36340
  ram_end->used = 1;
  80440c:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  804413:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  80441a:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  80441d:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  804424:	00 22 00 

  mem_sem = sys_sem_new(1);
  804427:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80442e:	e8 80 60 00 00       	call   80a4b3 <sys_sem_new>
  804433:	a3 44 63 a3 00       	mov    %eax,0xa36344

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  804438:	a1 3c 63 a3 00       	mov    0xa3633c,%eax
  80443d:	a3 48 63 a3 00       	mov    %eax,0xa36348

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  804442:	c9                   	leave  
  804443:	c3                   	ret    

00804444 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  804444:	55                   	push   %ebp
  804445:	89 e5                	mov    %esp,%ebp
  804447:	56                   	push   %esi
  804448:	53                   	push   %ebx
  804449:	83 ec 10             	sub    $0x10,%esp
  80444c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80444f:	85 db                	test   %ebx,%ebx
  804451:	0f 84 75 01 00 00    	je     8045cc <mem_free+0x188>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  804457:	f6 c3 03             	test   $0x3,%bl
  80445a:	74 1c                	je     804478 <mem_free+0x34>
  80445c:	c7 44 24 08 f0 21 81 	movl   $0x8121f0,0x8(%esp)
  804463:	00 
  804464:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80446b:	00 
  80446c:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  804473:	e8 08 aa 00 00       	call   80ee80 <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804478:	3b 1d 3c 63 a3 00    	cmp    0xa3633c,%ebx
  80447e:	72 08                	jb     804488 <mem_free+0x44>
  804480:	3b 1d 40 63 a3 00    	cmp    0xa36340,%ebx
  804486:	72 1c                	jb     8044a4 <mem_free+0x60>
  804488:	c7 44 24 08 fb 22 81 	movl   $0x8122fb,0x8(%esp)
  80448f:	00 
  804490:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  804497:	00 
  804498:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  80449f:	e8 dc a9 00 00       	call   80ee80 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8044a4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8044ab:	00 
  8044ac:	a1 44 63 a3 00       	mov    0xa36344,%eax
  8044b1:	89 04 24             	mov    %eax,(%esp)
  8044b4:	e8 6c 63 00 00       	call   80a825 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  8044b9:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  8044bd:	75 1c                	jne    8044db <mem_free+0x97>
  8044bf:	c7 44 24 08 12 23 81 	movl   $0x812312,0x8(%esp)
  8044c6:	00 
  8044c7:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  8044ce:	00 
  8044cf:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  8044d6:	e8 a5 a9 00 00       	call   80ee80 <_panic>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8044db:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
  8044de:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  8044e2:	3b 05 48 63 a3 00    	cmp    0xa36348,%eax
  8044e8:	73 05                	jae    8044ef <mem_free+0xab>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  8044ea:	a3 48 63 a3 00       	mov    %eax,0xa36348
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  8044ef:	8b 0d 3c 63 a3 00    	mov    0xa3633c,%ecx
  8044f5:	39 c8                	cmp    %ecx,%eax
  8044f7:	73 1c                	jae    804515 <mem_free+0xd1>
  8044f9:	c7 44 24 08 26 23 81 	movl   $0x812326,0x8(%esp)
  804500:	00 
  804501:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  804508:	00 
  804509:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  804510:	e8 6b a9 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804515:	8b 35 40 63 a3 00    	mov    0xa36340,%esi
  80451b:	39 f0                	cmp    %esi,%eax
  80451d:	72 1c                	jb     80453b <mem_free+0xf7>
  80451f:	c7 44 24 08 3d 23 81 	movl   $0x81233d,0x8(%esp)
  804526:	00 
  804527:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  80452e:	00 
  80452f:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  804536:	e8 45 a9 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80453b:	8b 53 f4             	mov    -0xc(%ebx),%edx
  80453e:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804544:	76 1c                	jbe    804562 <mem_free+0x11e>
  804546:	c7 44 24 08 14 22 81 	movl   $0x812214,0x8(%esp)
  80454d:	00 
  80454e:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  804555:	00 
  804556:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  80455d:	e8 1e a9 00 00       	call   80ee80 <_panic>

  nmem = (struct mem *)&ram[mem->next];
  804562:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  804564:	39 d0                	cmp    %edx,%eax
  804566:	74 26                	je     80458e <mem_free+0x14a>
  804568:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80456c:	75 20                	jne    80458e <mem_free+0x14a>
  80456e:	39 d6                	cmp    %edx,%esi
  804570:	74 1c                	je     80458e <mem_free+0x14a>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  804572:	3b 15 48 63 a3 00    	cmp    0xa36348,%edx
  804578:	75 05                	jne    80457f <mem_free+0x13b>
      lfree = mem;
  80457a:	a3 48 63 a3 00       	mov    %eax,0xa36348
    }
    mem->next = nmem->next;
  80457f:	8b 32                	mov    (%edx),%esi
  804581:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  804584:	8b 12                	mov    (%edx),%edx
  804586:	89 c6                	mov    %eax,%esi
  804588:	29 ce                	sub    %ecx,%esi
  80458a:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80458e:	8b 0d 3c 63 a3 00    	mov    0xa3633c,%ecx
  804594:	89 ca                	mov    %ecx,%edx
  804596:	03 53 f8             	add    -0x8(%ebx),%edx
  if (pmem != mem && pmem->used == 0) {
  804599:	39 d0                	cmp    %edx,%eax
  80459b:	74 22                	je     8045bf <mem_free+0x17b>
  80459d:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8045a1:	75 1c                	jne    8045bf <mem_free+0x17b>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  8045a3:	3b 05 48 63 a3 00    	cmp    0xa36348,%eax
  8045a9:	75 06                	jne    8045b1 <mem_free+0x16d>
      lfree = pmem;
  8045ab:	89 15 48 63 a3 00    	mov    %edx,0xa36348
    }
    pmem->next = mem->next;
  8045b1:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8045b4:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8045b6:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8045b9:	29 ca                	sub    %ecx,%edx
  8045bb:	89 54 01 04          	mov    %edx,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8045bf:	a1 44 63 a3 00       	mov    0xa36344,%eax
  8045c4:	89 04 24             	mov    %eax,(%esp)
  8045c7:	e8 f5 61 00 00       	call   80a7c1 <sys_sem_signal>
}
  8045cc:	83 c4 10             	add    $0x10,%esp
  8045cf:	5b                   	pop    %ebx
  8045d0:	5e                   	pop    %esi
  8045d1:	5d                   	pop    %ebp
  8045d2:	c3                   	ret    

008045d3 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8045d3:	55                   	push   %ebp
  8045d4:	89 e5                	mov    %esp,%ebp
  8045d6:	57                   	push   %edi
  8045d7:	56                   	push   %esi
  8045d8:	53                   	push   %ebx
  8045d9:	83 ec 2c             	sub    $0x2c,%esp
  8045dc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8045df:	8b 75 0c             	mov    0xc(%ebp),%esi
  8045e2:	83 c6 03             	add    $0x3,%esi
  8045e5:	83 e6 fc             	and    $0xfffffffc,%esi

  if(newsize < MIN_SIZE_ALIGNED) {
  8045e8:	83 fe 0b             	cmp    $0xb,%esi
  8045eb:	76 0d                	jbe    8045fa <mem_realloc+0x27>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8045ed:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  8045f3:	76 0a                	jbe    8045ff <mem_realloc+0x2c>
  8045f5:	e9 0f 01 00 00       	jmp    804709 <mem_realloc+0x136>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  8045fa:	be 0c 00 00 00       	mov    $0xc,%esi

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8045ff:	a1 3c 63 a3 00       	mov    0xa3633c,%eax
  804604:	39 d8                	cmp    %ebx,%eax
  804606:	77 08                	ja     804610 <mem_realloc+0x3d>
  804608:	3b 1d 40 63 a3 00    	cmp    0xa36340,%ebx
  80460e:	72 1c                	jb     80462c <mem_realloc+0x59>
  804610:	c7 44 24 08 57 23 81 	movl   $0x812357,0x8(%esp)
  804617:	00 
  804618:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  80461f:	00 
  804620:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  804627:	e8 54 a8 00 00       	call   80ee80 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80462c:	8d 7b f4             	lea    -0xc(%ebx),%edi
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80462f:	29 c7                	sub    %eax,%edi

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  804631:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804634:	83 e8 0c             	sub    $0xc,%eax
  804637:	29 f8                	sub    %edi,%eax
  804639:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80463c:	39 f0                	cmp    %esi,%eax
  80463e:	73 1c                	jae    80465c <mem_realloc+0x89>
  804640:	c7 44 24 08 40 22 81 	movl   $0x812240,0x8(%esp)
  804647:	00 
  804648:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80464f:	00 
  804650:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  804657:	e8 24 a8 00 00       	call   80ee80 <_panic>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  80465c:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  80465f:	0f 84 a9 00 00 00    	je     80470e <mem_realloc+0x13b>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804665:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80466c:	00 
  80466d:	a1 44 63 a3 00       	mov    0xa36344,%eax
  804672:	89 04 24             	mov    %eax,(%esp)
  804675:	e8 ab 61 00 00       	call   80a825 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80467a:	a1 3c 63 a3 00       	mov    0xa3633c,%eax
  80467f:	89 c2                	mov    %eax,%edx
  804681:	03 53 f4             	add    -0xc(%ebx),%edx
  if(mem2->used == 0) {
  804684:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804688:	75 36                	jne    8046c0 <mem_realloc+0xed>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80468a:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80468c:	8d 74 3e 0c          	lea    0xc(%esi,%edi,1),%esi
    if (lfree == mem2) {
  804690:	39 15 48 63 a3 00    	cmp    %edx,0xa36348
  804696:	75 09                	jne    8046a1 <mem_realloc+0xce>
      lfree = (struct mem *)&ram[ptr2];
  804698:	8d 14 30             	lea    (%eax,%esi,1),%edx
  80469b:	89 15 48 63 a3 00    	mov    %edx,0xa36348
    }
    mem2 = (struct mem *)&ram[ptr2];
  8046a1:	8d 14 30             	lea    (%eax,%esi,1),%edx
    mem2->used = 0;
  8046a4:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  8046a8:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  8046aa:	89 7a 04             	mov    %edi,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  8046ad:	89 73 f4             	mov    %esi,-0xc(%ebx)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8046b0:	8b 12                	mov    (%edx),%edx
  8046b2:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8046b8:	74 40                	je     8046fa <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8046ba:	89 74 10 04          	mov    %esi,0x4(%eax,%edx,1)
  8046be:	eb 3a                	jmp    8046fa <mem_realloc+0x127>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8046c0:	8d 56 18             	lea    0x18(%esi),%edx
  8046c3:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8046c6:	72 32                	jb     8046fa <mem_realloc+0x127>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8046c8:	8d 4c 3e 0c          	lea    0xc(%esi,%edi,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8046cc:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8046cf:	3b 15 48 63 a3 00    	cmp    0xa36348,%edx
  8046d5:	73 06                	jae    8046dd <mem_realloc+0x10a>
      lfree = mem2;
  8046d7:	89 15 48 63 a3 00    	mov    %edx,0xa36348
    }
    mem2->used = 0;
  8046dd:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8046e1:	8b 73 f4             	mov    -0xc(%ebx),%esi
  8046e4:	89 32                	mov    %esi,(%edx)
    mem2->prev = ptr;
  8046e6:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  8046e9:	89 4b f4             	mov    %ecx,-0xc(%ebx)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8046ec:	8b 12                	mov    (%edx),%edx
  8046ee:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8046f4:	74 04                	je     8046fa <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8046f6:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8046fa:	a1 44 63 a3 00       	mov    0xa36344,%eax
  8046ff:	89 04 24             	mov    %eax,(%esp)
  804702:	e8 ba 60 00 00       	call   80a7c1 <sys_sem_signal>
  return rmem;
  804707:	eb 05                	jmp    80470e <mem_realloc+0x13b>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  804709:	bb 00 00 00 00       	mov    $0x0,%ebx
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  80470e:	89 d8                	mov    %ebx,%eax
  804710:	83 c4 2c             	add    $0x2c,%esp
  804713:	5b                   	pop    %ebx
  804714:	5e                   	pop    %esi
  804715:	5f                   	pop    %edi
  804716:	5d                   	pop    %ebp
  804717:	c3                   	ret    

00804718 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  804718:	55                   	push   %ebp
  804719:	89 e5                	mov    %esp,%ebp
  80471b:	57                   	push   %edi
  80471c:	56                   	push   %esi
  80471d:	53                   	push   %ebx
  80471e:	83 ec 2c             	sub    $0x2c,%esp
  804721:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  804724:	85 f6                	test   %esi,%esi
  804726:	0f 84 93 01 00 00    	je     8048bf <mem_malloc+0x1a7>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80472c:	83 c6 03             	add    $0x3,%esi
  80472f:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  804732:	83 fe 0b             	cmp    $0xb,%esi
  804735:	76 0d                	jbe    804744 <mem_malloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  804737:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  80473d:	76 0a                	jbe    804749 <mem_malloc+0x31>
  80473f:	e9 82 01 00 00       	jmp    8048c6 <mem_malloc+0x1ae>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  804744:	be 0c 00 00 00       	mov    $0xc,%esi
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  804749:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804750:	00 
  804751:	a1 44 63 a3 00       	mov    0xa36344,%eax
  804756:	89 04 24             	mov    %eax,(%esp)
  804759:	e8 c7 60 00 00       	call   80a825 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80475e:	8b 15 3c 63 a3 00    	mov    0xa3633c,%edx
  804764:	a1 48 63 a3 00       	mov    0xa36348,%eax
  804769:	29 d0                	sub    %edx,%eax
  80476b:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804770:	29 f1                	sub    %esi,%ecx
  804772:	e9 2c 01 00 00       	jmp    8048a3 <mem_malloc+0x18b>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  804777:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80477a:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  80477e:	0f 85 1d 01 00 00    	jne    8048a1 <mem_malloc+0x189>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  804784:	8b 3b                	mov    (%ebx),%edi
  804786:	83 ef 0c             	sub    $0xc,%edi
  804789:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80478b:	39 f7                	cmp    %esi,%edi
  80478d:	0f 82 0e 01 00 00    	jb     8048a1 <mem_malloc+0x189>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  804793:	8d 4e 18             	lea    0x18(%esi),%ecx
  804796:	39 f9                	cmp    %edi,%ecx
  804798:	77 2f                	ja     8047c9 <mem_malloc+0xb1>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80479a:	8d 4c 30 0c          	lea    0xc(%eax,%esi,1),%ecx
  80479e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  8047a1:	01 d1                	add    %edx,%ecx
          mem2->used = 0;
  8047a3:	c6 41 08 00          	movb   $0x0,0x8(%ecx)
          mem2->next = mem->next;
  8047a7:	8b 3b                	mov    (%ebx),%edi
  8047a9:	89 39                	mov    %edi,(%ecx)
          mem2->prev = ptr;
  8047ab:	89 41 04             	mov    %eax,0x4(%ecx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  8047ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8047b1:	89 03                	mov    %eax,(%ebx)
          mem->used = 1;
  8047b3:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  8047b7:	8b 01                	mov    (%ecx),%eax
  8047b9:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8047be:	74 0d                	je     8047cd <mem_malloc+0xb5>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8047c0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8047c3:	89 4c 02 04          	mov    %ecx,0x4(%edx,%eax,1)
  8047c7:	eb 04                	jmp    8047cd <mem_malloc+0xb5>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  8047c9:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8047cd:	3b 1d 48 63 a3 00    	cmp    0xa36348,%ebx
  8047d3:	75 53                	jne    804828 <mem_malloc+0x110>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8047d5:	8b 0d 40 63 a3 00    	mov    0xa36340,%ecx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  8047db:	8b 3d 3c 63 a3 00    	mov    0xa3633c,%edi
  8047e1:	89 d8                	mov    %ebx,%eax
  8047e3:	eb 04                	jmp    8047e9 <mem_malloc+0xd1>
  8047e5:	8b 00                	mov    (%eax),%eax
  8047e7:	01 f8                	add    %edi,%eax
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8047e9:	8a 50 08             	mov    0x8(%eax),%dl
  8047ec:	84 d2                	test   %dl,%dl
  8047ee:	74 0b                	je     8047fb <mem_malloc+0xe3>
  8047f0:	39 c1                	cmp    %eax,%ecx
  8047f2:	75 f1                	jne    8047e5 <mem_malloc+0xcd>
  8047f4:	a3 48 63 a3 00       	mov    %eax,0xa36348
  8047f9:	eb 2d                	jmp    804828 <mem_malloc+0x110>
  8047fb:	a3 48 63 a3 00       	mov    %eax,0xa36348
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  804800:	3b 05 40 63 a3 00    	cmp    0xa36340,%eax
  804806:	74 20                	je     804828 <mem_malloc+0x110>
  804808:	84 d2                	test   %dl,%dl
  80480a:	74 1c                	je     804828 <mem_malloc+0x110>
  80480c:	c7 44 24 08 71 23 81 	movl   $0x812371,0x8(%esp)
  804813:	00 
  804814:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
  80481b:	00 
  80481c:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  804823:	e8 58 a6 00 00       	call   80ee80 <_panic>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  804828:	a1 44 63 a3 00       	mov    0xa36344,%eax
  80482d:	89 04 24             	mov    %eax,(%esp)
  804830:	e8 8c 5f 00 00       	call   80a7c1 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804835:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  804839:	39 05 40 63 a3 00    	cmp    %eax,0xa36340
  80483f:	73 1c                	jae    80485d <mem_malloc+0x145>
  804841:	c7 44 24 08 64 22 81 	movl   $0x812264,0x8(%esp)
  804848:	00 
  804849:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  804850:	00 
  804851:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  804858:	e8 23 a6 00 00       	call   80ee80 <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80485d:	8d 43 0c             	lea    0xc(%ebx),%eax
  804860:	a8 03                	test   $0x3,%al
  804862:	74 1c                	je     804880 <mem_malloc+0x168>
  804864:	c7 44 24 08 94 22 81 	movl   $0x812294,0x8(%esp)
  80486b:	00 
  80486c:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  804873:	00 
  804874:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  80487b:	e8 00 a6 00 00       	call   80ee80 <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  804880:	f6 c3 03             	test   $0x3,%bl
  804883:	74 46                	je     8048cb <mem_malloc+0x1b3>
  804885:	c7 44 24 08 c4 22 81 	movl   $0x8122c4,0x8(%esp)
  80488c:	00 
  80488d:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  804894:	00 
  804895:	c7 04 24 e7 22 81 00 	movl   $0x8122e7,(%esp)
  80489c:	e8 df a5 00 00       	call   80ee80 <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  8048a1:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  8048a3:	39 c8                	cmp    %ecx,%eax
  8048a5:	0f 82 cc fe ff ff    	jb     804777 <mem_malloc+0x5f>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8048ab:	a1 44 63 a3 00       	mov    0xa36344,%eax
  8048b0:	89 04 24             	mov    %eax,(%esp)
  8048b3:	e8 09 5f 00 00       	call   80a7c1 <sys_sem_signal>
  return NULL;
  8048b8:	b8 00 00 00 00       	mov    $0x0,%eax
  8048bd:	eb 0c                	jmp    8048cb <mem_malloc+0x1b3>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  8048bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8048c4:	eb 05                	jmp    8048cb <mem_malloc+0x1b3>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  8048c6:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  8048cb:	83 c4 2c             	add    $0x2c,%esp
  8048ce:	5b                   	pop    %ebx
  8048cf:	5e                   	pop    %esi
  8048d0:	5f                   	pop    %edi
  8048d1:	5d                   	pop    %ebp
  8048d2:	c3                   	ret    

008048d3 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8048d3:	55                   	push   %ebp
  8048d4:	89 e5                	mov    %esp,%ebp
  8048d6:	56                   	push   %esi
  8048d7:	53                   	push   %ebx
  8048d8:	83 ec 10             	sub    $0x10,%esp
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8048db:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8048de:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  8048e2:	89 1c 24             	mov    %ebx,(%esp)
  8048e5:	e8 2e fe ff ff       	call   804718 <mem_malloc>
  8048ea:	89 c6                	mov    %eax,%esi
  if (p) {
  8048ec:	85 c0                	test   %eax,%eax
  8048ee:	74 14                	je     804904 <mem_calloc+0x31>
    /* zero the memory */
    memset(p, 0, count * size);
  8048f0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8048f4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8048fb:	00 
  8048fc:	89 04 24             	mov    %eax,(%esp)
  8048ff:	e8 4e ad 00 00       	call   80f652 <memset>
  }
  return p;
}
  804904:	89 f0                	mov    %esi,%eax
  804906:	83 c4 10             	add    $0x10,%esp
  804909:	5b                   	pop    %ebx
  80490a:	5e                   	pop    %esi
  80490b:	5d                   	pop    %ebp
  80490c:	c3                   	ret    
  80490d:	00 00                	add    %al,(%eax)
	...

00804910 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  804910:	55                   	push   %ebp
  804911:	89 e5                	mov    %esp,%ebp
  804913:	56                   	push   %esi
  804914:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  804915:	b8 63 63 a3 00       	mov    $0xa36363,%eax
  80491a:	83 e0 fc             	and    $0xfffffffc,%eax
  80491d:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  804922:	c7 84 12 e0 53 b3 00 	movl   $0x0,0xb353e0(%edx,%edx,1)
  804929:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80492d:	66 8b b2 1c 24 81 00 	mov    0x81241c(%edx),%si
  804934:	b9 00 00 00 00       	mov    $0x0,%ecx
  804939:	eb 1a                	jmp    804955 <memp_init+0x45>
      memp->next = memp_tab[i];
  80493b:	8b 9c 12 e0 53 b3 00 	mov    0xb353e0(%edx,%edx,1),%ebx
  804942:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  804944:	89 84 12 e0 53 b3 00 	mov    %eax,0xb353e0(%edx,%edx,1)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80494b:	0f b7 9a 00 24 81 00 	movzwl 0x812400(%edx),%ebx
  804952:	01 d8                	add    %ebx,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804954:	41                   	inc    %ecx
  804955:	66 39 f1             	cmp    %si,%cx
  804958:	75 e1                	jne    80493b <memp_init+0x2b>
  80495a:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80495d:	83 fa 1c             	cmp    $0x1c,%edx
  804960:	75 c0                	jne    804922 <memp_init+0x12>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804962:	5b                   	pop    %ebx
  804963:	5e                   	pop    %esi
  804964:	5d                   	pop    %ebp
  804965:	c3                   	ret    

00804966 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  804966:	55                   	push   %ebp
  804967:	89 e5                	mov    %esp,%ebp
  804969:	83 ec 18             	sub    $0x18,%esp
  80496c:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80496f:	83 fa 0d             	cmp    $0xd,%edx
  804972:	76 1c                	jbe    804990 <memp_malloc+0x2a>
  804974:	c7 44 24 08 8a 23 81 	movl   $0x81238a,0x8(%esp)
  80497b:	00 
  80497c:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  804983:	00 
  804984:	c7 04 24 a7 23 81 00 	movl   $0x8123a7,(%esp)
  80498b:	e8 f0 a4 00 00       	call   80ee80 <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  804990:	8b 04 95 e0 53 b3 00 	mov    0xb353e0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804997:	85 c0                	test   %eax,%eax
  804999:	74 29                	je     8049c4 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  80499b:	8b 08                	mov    (%eax),%ecx
  80499d:	89 0c 95 e0 53 b3 00 	mov    %ecx,0xb353e0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  8049a4:	a8 03                	test   $0x3,%al
  8049a6:	74 1c                	je     8049c4 <memp_malloc+0x5e>
  8049a8:	c7 44 24 08 bc 23 81 	movl   $0x8123bc,0x8(%esp)
  8049af:	00 
  8049b0:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  8049b7:	00 
  8049b8:	c7 04 24 a7 23 81 00 	movl   $0x8123a7,(%esp)
  8049bf:	e8 bc a4 00 00       	call   80ee80 <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8049c4:	c9                   	leave  
  8049c5:	c3                   	ret    

008049c6 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8049c6:	55                   	push   %ebp
  8049c7:	89 e5                	mov    %esp,%ebp
  8049c9:	83 ec 18             	sub    $0x18,%esp
  8049cc:	8b 55 08             	mov    0x8(%ebp),%edx
  8049cf:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8049d2:	85 c0                	test   %eax,%eax
  8049d4:	74 30                	je     804a06 <memp_free+0x40>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8049d6:	a8 03                	test   $0x3,%al
  8049d8:	74 1c                	je     8049f6 <memp_free+0x30>
  8049da:	c7 44 24 08 e0 23 81 	movl   $0x8123e0,0x8(%esp)
  8049e1:	00 
  8049e2:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  8049e9:	00 
  8049ea:	c7 04 24 a7 23 81 00 	movl   $0x8123a7,(%esp)
  8049f1:	e8 8a a4 00 00       	call   80ee80 <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8049f6:	8b 0c 95 e0 53 b3 00 	mov    0xb353e0(,%edx,4),%ecx
  8049fd:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8049ff:	89 04 95 e0 53 b3 00 	mov    %eax,0xb353e0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  804a06:	c9                   	leave  
  804a07:	c3                   	ret    

00804a08 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  804a08:	55                   	push   %ebp
  804a09:	89 e5                	mov    %esp,%ebp
  804a0b:	53                   	push   %ebx
  804a0c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  804a0f:	85 c9                	test   %ecx,%ecx
  804a11:	74 29                	je     804a3c <netif_find+0x34>
    return NULL;
  }

  num = name[2] - '0';
  804a13:	8a 51 02             	mov    0x2(%ecx),%dl
  804a16:	83 ea 30             	sub    $0x30,%edx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804a19:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  804a1e:	eb 16                	jmp    804a36 <netif_find+0x2e>
    if (num == netif->num &&
  804a20:	38 50 31             	cmp    %dl,0x31(%eax)
  804a23:	75 0f                	jne    804a34 <netif_find+0x2c>
  804a25:	8a 58 2f             	mov    0x2f(%eax),%bl
  804a28:	38 19                	cmp    %bl,(%ecx)
  804a2a:	75 08                	jne    804a34 <netif_find+0x2c>
       name[0] == netif->name[0] &&
  804a2c:	8a 58 30             	mov    0x30(%eax),%bl
  804a2f:	38 59 01             	cmp    %bl,0x1(%ecx)
  804a32:	74 0d                	je     804a41 <netif_find+0x39>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804a34:	8b 00                	mov    (%eax),%eax
  804a36:	85 c0                	test   %eax,%eax
  804a38:	75 e6                	jne    804a20 <netif_find+0x18>
  804a3a:	eb 05                	jmp    804a41 <netif_find+0x39>
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  804a3c:	b8 00 00 00 00       	mov    $0x0,%eax
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  804a41:	5b                   	pop    %ebx
  804a42:	5d                   	pop    %ebp
  804a43:	c3                   	ret    

00804a44 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  804a44:	55                   	push   %ebp
  804a45:	89 e5                	mov    %esp,%ebp
  804a47:	57                   	push   %edi
  804a48:	56                   	push   %esi
  804a49:	53                   	push   %ebx
  804a4a:	83 ec 1c             	sub    $0x1c,%esp
  804a4d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804a50:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804a53:	8b 43 04             	mov    0x4(%ebx),%eax
  804a56:	39 06                	cmp    %eax,(%esi)
  804a58:	74 50                	je     804aaa <netif_set_ipaddr+0x66>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  804a5a:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
    while (pcb != NULL) {
  804a5f:	eb 19                	jmp    804a7a <netif_set_ipaddr+0x36>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804a61:	8b 53 04             	mov    0x4(%ebx),%edx
  804a64:	39 10                	cmp    %edx,(%eax)
  804a66:	75 0f                	jne    804a77 <netif_set_ipaddr+0x33>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  804a68:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  804a6b:	89 04 24             	mov    %eax,(%esp)
  804a6e:	e8 ef 14 00 00       	call   805f62 <tcp_abort>
        pcb = next;
  804a73:	89 f8                	mov    %edi,%eax
  804a75:	eb 03                	jmp    804a7a <netif_set_ipaddr+0x36>
      } else {
        pcb = pcb->next;
  804a77:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  804a7a:	85 c0                	test   %eax,%eax
  804a7c:	75 e3                	jne    804a61 <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804a7e:	a1 84 c2 b3 00       	mov    0xb3c284,%eax
  804a83:	eb 21                	jmp    804aa6 <netif_set_ipaddr+0x62>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  804a85:	85 c0                	test   %eax,%eax
  804a87:	74 1a                	je     804aa3 <netif_set_ipaddr+0x5f>
  804a89:	8b 10                	mov    (%eax),%edx
  804a8b:	85 d2                	test   %edx,%edx
  804a8d:	74 14                	je     804aa3 <netif_set_ipaddr+0x5f>
  804a8f:	3b 53 04             	cmp    0x4(%ebx),%edx
  804a92:	75 0f                	jne    804aa3 <netif_set_ipaddr+0x5f>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804a94:	85 f6                	test   %esi,%esi
  804a96:	74 04                	je     804a9c <netif_set_ipaddr+0x58>
  804a98:	8b 16                	mov    (%esi),%edx
  804a9a:	eb 05                	jmp    804aa1 <netif_set_ipaddr+0x5d>
  804a9c:	ba 00 00 00 00       	mov    $0x0,%edx
  804aa1:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804aa3:	8b 40 0c             	mov    0xc(%eax),%eax
  804aa6:	85 c0                	test   %eax,%eax
  804aa8:	75 db                	jne    804a85 <netif_set_ipaddr+0x41>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  804aaa:	85 f6                	test   %esi,%esi
  804aac:	74 04                	je     804ab2 <netif_set_ipaddr+0x6e>
  804aae:	8b 06                	mov    (%esi),%eax
  804ab0:	eb 05                	jmp    804ab7 <netif_set_ipaddr+0x73>
  804ab2:	b8 00 00 00 00       	mov    $0x0,%eax
  804ab7:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  804aba:	83 c4 1c             	add    $0x1c,%esp
  804abd:	5b                   	pop    %ebx
  804abe:	5e                   	pop    %esi
  804abf:	5f                   	pop    %edi
  804ac0:	5d                   	pop    %ebp
  804ac1:	c3                   	ret    

00804ac2 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  804ac2:	55                   	push   %ebp
  804ac3:	89 e5                	mov    %esp,%ebp
  804ac5:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  804ac8:	85 c0                	test   %eax,%eax
  804aca:	74 04                	je     804ad0 <netif_set_gw+0xe>
  804acc:	8b 10                	mov    (%eax),%edx
  804ace:	eb 05                	jmp    804ad5 <netif_set_gw+0x13>
  804ad0:	ba 00 00 00 00       	mov    $0x0,%edx
  804ad5:	8b 45 08             	mov    0x8(%ebp),%eax
  804ad8:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  804adb:	5d                   	pop    %ebp
  804adc:	c3                   	ret    

00804add <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  804add:	55                   	push   %ebp
  804ade:	89 e5                	mov    %esp,%ebp
  804ae0:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804ae3:	85 c0                	test   %eax,%eax
  804ae5:	74 04                	je     804aeb <netif_set_netmask+0xe>
  804ae7:	8b 10                	mov    (%eax),%edx
  804ae9:	eb 05                	jmp    804af0 <netif_set_netmask+0x13>
  804aeb:	ba 00 00 00 00       	mov    $0x0,%edx
  804af0:	8b 45 08             	mov    0x8(%ebp),%eax
  804af3:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  804af6:	5d                   	pop    %ebp
  804af7:	c3                   	ret    

00804af8 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  804af8:	55                   	push   %ebp
  804af9:	89 e5                	mov    %esp,%ebp
  804afb:	53                   	push   %ebx
  804afc:	83 ec 14             	sub    $0x14,%esp
  804aff:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  804b02:	8b 45 0c             	mov    0xc(%ebp),%eax
  804b05:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b09:	89 1c 24             	mov    %ebx,(%esp)
  804b0c:	e8 33 ff ff ff       	call   804a44 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  804b11:	8b 45 10             	mov    0x10(%ebp),%eax
  804b14:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b18:	89 1c 24             	mov    %ebx,(%esp)
  804b1b:	e8 bd ff ff ff       	call   804add <netif_set_netmask>
  netif_set_gw(netif, gw);
  804b20:	8b 45 14             	mov    0x14(%ebp),%eax
  804b23:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b27:	89 1c 24             	mov    %ebx,(%esp)
  804b2a:	e8 93 ff ff ff       	call   804ac2 <netif_set_gw>
}
  804b2f:	83 c4 14             	add    $0x14,%esp
  804b32:	5b                   	pop    %ebx
  804b33:	5d                   	pop    %ebp
  804b34:	c3                   	ret    

00804b35 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  804b35:	55                   	push   %ebp
  804b36:	89 e5                	mov    %esp,%ebp
  804b38:	53                   	push   %ebx
  804b39:	83 ec 14             	sub    $0x14,%esp
  804b3c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  804b3f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804b46:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804b4d:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804b54:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  804b58:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  804b5f:	8b 45 18             	mov    0x18(%ebp),%eax
  804b62:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804b65:	a0 18 54 b3 00       	mov    0xb35418,%al
  804b6a:	88 43 31             	mov    %al,0x31(%ebx)
  804b6d:	40                   	inc    %eax
  804b6e:	a2 18 54 b3 00       	mov    %al,0xb35418
  netif->input = input;
  804b73:	8b 45 20             	mov    0x20(%ebp),%eax
  804b76:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  804b79:	8b 45 14             	mov    0x14(%ebp),%eax
  804b7c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804b80:	8b 45 10             	mov    0x10(%ebp),%eax
  804b83:	89 44 24 08          	mov    %eax,0x8(%esp)
  804b87:	8b 45 0c             	mov    0xc(%ebp),%eax
  804b8a:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b8e:	89 1c 24             	mov    %ebx,(%esp)
  804b91:	e8 62 ff ff ff       	call   804af8 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  804b96:	89 1c 24             	mov    %ebx,(%esp)
  804b99:	ff 55 1c             	call   *0x1c(%ebp)
  804b9c:	84 c0                	test   %al,%al
  804b9e:	75 0f                	jne    804baf <netif_add+0x7a>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  804ba0:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  804ba5:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  804ba7:	89 1d 74 c2 b3 00    	mov    %ebx,0xb3c274
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  804bad:	eb 05                	jmp    804bb4 <netif_add+0x7f>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  804baf:	bb 00 00 00 00       	mov    $0x0,%ebx
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  804bb4:	89 d8                	mov    %ebx,%eax
  804bb6:	83 c4 14             	add    $0x14,%esp
  804bb9:	5b                   	pop    %ebx
  804bba:	5d                   	pop    %ebp
  804bbb:	c3                   	ret    

00804bbc <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  804bbc:	55                   	push   %ebp
  804bbd:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804bbf:	8b 45 08             	mov    0x8(%ebp),%eax
  804bc2:	a3 78 c2 b3 00       	mov    %eax,0xb3c278
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  804bc7:	5d                   	pop    %ebp
  804bc8:	c3                   	ret    

00804bc9 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  804bc9:	55                   	push   %ebp
  804bca:	89 e5                	mov    %esp,%ebp
  804bcc:	83 ec 04             	sub    $0x4,%esp
  804bcf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  804bd2:	85 c9                	test   %ecx,%ecx
  804bd4:	74 3a                	je     804c10 <netif_remove+0x47>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  804bd6:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  804bdb:	39 c8                	cmp    %ecx,%eax
  804bdd:	75 17                	jne    804bf6 <netif_remove+0x2d>
    netif_list = netif->next;
  804bdf:	8b 00                	mov    (%eax),%eax
  804be1:	a3 74 c2 b3 00       	mov    %eax,0xb3c274
  804be6:	eb 14                	jmp    804bfc <netif_remove+0x33>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  804be8:	8b 10                	mov    (%eax),%edx
  804bea:	39 ca                	cmp    %ecx,%edx
  804bec:	75 06                	jne    804bf4 <netif_remove+0x2b>
        tmpNetif->next = netif->next;
  804bee:	8b 11                	mov    (%ecx),%edx
  804bf0:	89 10                	mov    %edx,(%eax)
  804bf2:	eb 08                	jmp    804bfc <netif_remove+0x33>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804bf4:	89 d0                	mov    %edx,%eax
  804bf6:	85 c0                	test   %eax,%eax
  804bf8:	75 ee                	jne    804be8 <netif_remove+0x1f>
  804bfa:	eb 14                	jmp    804c10 <netif_remove+0x47>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804bfc:	39 0d 78 c2 b3 00    	cmp    %ecx,0xb3c278
  804c02:	75 0c                	jne    804c10 <netif_remove+0x47>
    /* reset default netif */
    netif_set_default(NULL);
  804c04:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804c0b:	e8 ac ff ff ff       	call   804bbc <netif_set_default>
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804c10:	c9                   	leave  
  804c11:	c3                   	ret    

00804c12 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  804c12:	55                   	push   %ebp
  804c13:	89 e5                	mov    %esp,%ebp
  804c15:	83 ec 18             	sub    $0x18,%esp
  804c18:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  804c1b:	8a 50 2e             	mov    0x2e(%eax),%dl
  804c1e:	f6 c2 01             	test   $0x1,%dl
  804c21:	75 22                	jne    804c45 <netif_set_up+0x33>
    netif->flags |= NETIF_FLAG_UP;
  804c23:	83 ca 01             	or     $0x1,%edx
  804c26:	88 50 2e             	mov    %dl,0x2e(%eax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804c29:	f6 c2 20             	test   $0x20,%dl
  804c2c:	74 17                	je     804c45 <netif_set_up+0x33>
      etharp_query(netif, &(netif->ip_addr), NULL);
  804c2e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804c35:	00 
  804c36:	8d 50 04             	lea    0x4(%eax),%edx
  804c39:	89 54 24 04          	mov    %edx,0x4(%esp)
  804c3d:	89 04 24             	mov    %eax,(%esp)
  804c40:	e8 66 53 00 00       	call   809fab <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  804c45:	c9                   	leave  
  804c46:	c3                   	ret    

00804c47 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804c47:	55                   	push   %ebp
  804c48:	89 e5                	mov    %esp,%ebp
  804c4a:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  804c4d:	8a 50 2e             	mov    0x2e(%eax),%dl
  804c50:	f6 c2 01             	test   $0x1,%dl
  804c53:	74 06                	je     804c5b <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804c55:	83 e2 fe             	and    $0xfffffffe,%edx
  804c58:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804c5b:	5d                   	pop    %ebp
  804c5c:	c3                   	ret    

00804c5d <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804c5d:	55                   	push   %ebp
  804c5e:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804c60:	8b 45 08             	mov    0x8(%ebp),%eax
  804c63:	8a 40 2e             	mov    0x2e(%eax),%al
  804c66:	83 e0 01             	and    $0x1,%eax
}
  804c69:	5d                   	pop    %ebp
  804c6a:	c3                   	ret    
	...

00804c6c <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804c6c:	55                   	push   %ebp
  804c6d:	89 e5                	mov    %esp,%ebp
  804c6f:	56                   	push   %esi
  804c70:	53                   	push   %ebx
  804c71:	83 ec 10             	sub    $0x10,%esp
  804c74:	8b 45 08             	mov    0x8(%ebp),%eax
  804c77:	8b 55 0c             	mov    0xc(%ebp),%edx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804c7a:	85 c0                	test   %eax,%eax
  804c7c:	75 1c                	jne    804c9a <pbuf_header+0x2e>
  804c7e:	c7 44 24 08 b2 24 81 	movl   $0x8124b2,0x8(%esp)
  804c85:	00 
  804c86:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  804c8d:	00 
  804c8e:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804c95:	e8 e6 a1 00 00       	call   80ee80 <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  804c9a:	66 85 d2             	test   %dx,%dx
  804c9d:	0f 84 9d 00 00 00    	je     804d40 <pbuf_header+0xd4>
    return 0;
 
  if (header_size_increment < 0){
  804ca3:	66 85 d2             	test   %dx,%dx
  804ca6:	79 26                	jns    804cce <pbuf_header+0x62>
    increment_magnitude = -header_size_increment;
  804ca8:	89 d6                	mov    %edx,%esi
  804caa:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804cac:	66 3b 70 0a          	cmp    0xa(%eax),%si
  804cb0:	76 1e                	jbe    804cd0 <pbuf_header+0x64>
  804cb2:	c7 44 24 08 4d 24 81 	movl   $0x81244d,0x8(%esp)
  804cb9:	00 
  804cba:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  804cc1:	00 
  804cc2:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804cc9:	e8 b2 a1 00 00       	call   80ee80 <_panic>
  } else {
    increment_magnitude = header_size_increment;
  804cce:	89 d6                	mov    %edx,%esi
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804cd0:	0f b6 48 0c          	movzbl 0xc(%eax),%ecx
  /* remember current payload pointer */
  payload = p->payload;
  804cd4:	8b 58 04             	mov    0x4(%eax),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  804cd7:	66 85 c9             	test   %cx,%cx
  804cda:	74 06                	je     804ce2 <pbuf_header+0x76>
  804cdc:	66 83 f9 03          	cmp    $0x3,%cx
  804ce0:	75 1a                	jne    804cfc <pbuf_header+0x90>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804ce2:	0f bf ca             	movswl %dx,%ecx
  804ce5:	89 de                	mov    %ebx,%esi
  804ce7:	29 ce                	sub    %ecx,%esi
  804ce9:	89 f1                	mov    %esi,%ecx
  804ceb:	89 70 04             	mov    %esi,0x4(%eax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804cee:	8d 70 10             	lea    0x10(%eax),%esi
  804cf1:	39 f1                	cmp    %esi,%ecx
  804cf3:	73 3f                	jae    804d34 <pbuf_header+0xc8>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  804cf5:	89 58 04             	mov    %ebx,0x4(%eax)
      /* bail out unsuccesfully */
      return 1;
  804cf8:	b0 01                	mov    $0x1,%al
  804cfa:	eb 4e                	jmp    804d4a <pbuf_header+0xde>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804cfc:	49                   	dec    %ecx
  804cfd:	66 83 f9 01          	cmp    $0x1,%cx
  804d01:	77 15                	ja     804d18 <pbuf_header+0xac>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804d03:	66 85 d2             	test   %dx,%dx
  804d06:	79 3c                	jns    804d44 <pbuf_header+0xd8>
  804d08:	66 3b 70 0a          	cmp    0xa(%eax),%si
  804d0c:	77 3a                	ja     804d48 <pbuf_header+0xdc>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  804d0e:	0f bf ca             	movswl %dx,%ecx
  804d11:	29 cb                	sub    %ecx,%ebx
  804d13:	89 58 04             	mov    %ebx,0x4(%eax)
  804d16:	eb 1c                	jmp    804d34 <pbuf_header+0xc8>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  804d18:	c7 44 24 08 6b 24 81 	movl   $0x81246b,0x8(%esp)
  804d1f:	00 
  804d20:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  804d27:	00 
  804d28:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804d2f:	e8 4c a1 00 00       	call   80ee80 <_panic>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  804d34:	66 01 50 0a          	add    %dx,0xa(%eax)
  p->tot_len += header_size_increment;
  804d38:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804d3c:	b0 00                	mov    $0x0,%al
  804d3e:	eb 0a                	jmp    804d4a <pbuf_header+0xde>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  804d40:	b0 00                	mov    $0x0,%al
  804d42:	eb 06                	jmp    804d4a <pbuf_header+0xde>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  804d44:	b0 01                	mov    $0x1,%al
  804d46:	eb 02                	jmp    804d4a <pbuf_header+0xde>
  804d48:	b0 01                	mov    $0x1,%al

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  804d4a:	83 c4 10             	add    $0x10,%esp
  804d4d:	5b                   	pop    %ebx
  804d4e:	5e                   	pop    %esi
  804d4f:	5d                   	pop    %ebp
  804d50:	c3                   	ret    

00804d51 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804d51:	55                   	push   %ebp
  804d52:	89 e5                	mov    %esp,%ebp
  804d54:	56                   	push   %esi
  804d55:	53                   	push   %ebx
  804d56:	83 ec 10             	sub    $0x10,%esp
  804d59:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804d5c:	85 d2                	test   %edx,%edx
  804d5e:	75 1c                	jne    804d7c <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  804d60:	c7 44 24 08 b2 24 81 	movl   $0x8124b2,0x8(%esp)
  804d67:	00 
  804d68:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  804d6f:	00 
  804d70:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804d77:	e8 04 a1 00 00       	call   80ee80 <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804d7c:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  804d80:	76 1c                	jbe    804d9e <pbuf_free+0x4d>
  804d82:	c7 44 24 08 79 24 81 	movl   $0x812479,0x8(%esp)
  804d89:	00 
  804d8a:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  804d91:	00 
  804d92:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804d99:	e8 e2 a0 00 00       	call   80ee80 <_panic>
  804d9e:	be 00 00 00 00       	mov    $0x0,%esi
  804da3:	eb 02                	jmp    804da7 <pbuf_free+0x56>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  804da5:	89 da                	mov    %ebx,%edx
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804da7:	66 8b 42 0e          	mov    0xe(%edx),%ax
  804dab:	66 85 c0             	test   %ax,%ax
  804dae:	75 1c                	jne    804dcc <pbuf_free+0x7b>
  804db0:	c7 44 24 08 8e 24 81 	movl   $0x81248e,0x8(%esp)
  804db7:	00 
  804db8:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  804dbf:	00 
  804dc0:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804dc7:	e8 b4 a0 00 00       	call   80ee80 <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  804dcc:	48                   	dec    %eax
  804dcd:	66 89 42 0e          	mov    %ax,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  804dd1:	66 85 c0             	test   %ax,%ax
  804dd4:	75 44                	jne    804e1a <pbuf_free+0xc9>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  804dd6:	8b 1a                	mov    (%edx),%ebx
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  804dd8:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  804ddc:	66 83 f8 03          	cmp    $0x3,%ax
  804de0:	75 12                	jne    804df4 <pbuf_free+0xa3>
        memp_free(MEMP_PBUF_POOL, p);
  804de2:	89 54 24 04          	mov    %edx,0x4(%esp)
  804de6:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804ded:	e8 d4 fb ff ff       	call   8049c6 <memp_free>
  804df2:	eb 21                	jmp    804e15 <pbuf_free+0xc4>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804df4:	48                   	dec    %eax
  804df5:	66 83 f8 01          	cmp    $0x1,%ax
  804df9:	77 12                	ja     804e0d <pbuf_free+0xbc>
        memp_free(MEMP_PBUF, p);
  804dfb:	89 54 24 04          	mov    %edx,0x4(%esp)
  804dff:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  804e06:	e8 bb fb ff ff       	call   8049c6 <memp_free>
  804e0b:	eb 08                	jmp    804e15 <pbuf_free+0xc4>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  804e0d:	89 14 24             	mov    %edx,(%esp)
  804e10:	e8 2f f6 ff ff       	call   804444 <mem_free>
      }
      count++;
  804e15:	46                   	inc    %esi
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  804e16:	85 db                	test   %ebx,%ebx
  804e18:	75 8b                	jne    804da5 <pbuf_free+0x54>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804e1a:	89 f0                	mov    %esi,%eax
  804e1c:	83 c4 10             	add    $0x10,%esp
  804e1f:	5b                   	pop    %ebx
  804e20:	5e                   	pop    %esi
  804e21:	5d                   	pop    %ebp
  804e22:	c3                   	ret    

00804e23 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  804e23:	55                   	push   %ebp
  804e24:	89 e5                	mov    %esp,%ebp
  804e26:	56                   	push   %esi
  804e27:	53                   	push   %ebx
  804e28:	83 ec 10             	sub    $0x10,%esp
  804e2b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804e2e:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804e31:	85 db                	test   %ebx,%ebx
  804e33:	75 1c                	jne    804e51 <pbuf_realloc+0x2e>
  804e35:	c7 44 24 08 a4 24 81 	movl   $0x8124a4,0x8(%esp)
  804e3c:	00 
  804e3d:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  804e44:	00 
  804e45:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804e4c:	e8 2f a0 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804e51:	8a 43 0c             	mov    0xc(%ebx),%al
  804e54:	3c 03                	cmp    $0x3,%al
  804e56:	74 28                	je     804e80 <pbuf_realloc+0x5d>
  804e58:	3c 01                	cmp    $0x1,%al
  804e5a:	74 24                	je     804e80 <pbuf_realloc+0x5d>
  804e5c:	84 c0                	test   %al,%al
  804e5e:	74 20                	je     804e80 <pbuf_realloc+0x5d>
  804e60:	3c 02                	cmp    $0x2,%al
  804e62:	74 1c                	je     804e80 <pbuf_realloc+0x5d>
  804e64:	c7 44 24 08 bc 24 81 	movl   $0x8124bc,0x8(%esp)
  804e6b:	00 
  804e6c:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  804e73:	00 
  804e74:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804e7b:	e8 00 a0 00 00       	call   80ee80 <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  804e80:	8b 43 08             	mov    0x8(%ebx),%eax
  804e83:	66 39 f0             	cmp    %si,%ax
  804e86:	0f 86 bf 00 00 00    	jbe    804f4b <pbuf_realloc+0x128>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  804e8c:	0f b7 d6             	movzwl %si,%edx
  804e8f:	0f b7 c0             	movzwl %ax,%eax
  804e92:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804e94:	eb 4d                	jmp    804ee3 <pbuf_realloc+0xc0>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  804e96:	66 29 c6             	sub    %ax,%si
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804e99:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  804e9f:	7e 1c                	jle    804ebd <pbuf_realloc+0x9a>
  804ea1:	c7 44 24 08 d7 24 81 	movl   $0x8124d7,0x8(%esp)
  804ea8:	00 
  804ea9:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  804eb0:	00 
  804eb1:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804eb8:	e8 c3 9f 00 00       	call   80ee80 <_panic>
    q->tot_len += (u16_t)grow;
  804ebd:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  804ec1:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804ec3:	85 db                	test   %ebx,%ebx
  804ec5:	75 1c                	jne    804ee3 <pbuf_realloc+0xc0>
  804ec7:	c7 44 24 08 e8 24 81 	movl   $0x8124e8,0x8(%esp)
  804ece:	00 
  804ecf:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  804ed6:	00 
  804ed7:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804ede:	e8 9d 9f 00 00       	call   80ee80 <_panic>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804ee3:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  804ee7:	66 39 c6             	cmp    %ax,%si
  804eea:	77 aa                	ja     804e96 <pbuf_realloc+0x73>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804eec:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804ef0:	75 3d                	jne    804f2f <pbuf_realloc+0x10c>
  804ef2:	66 39 f0             	cmp    %si,%ax
  804ef5:	74 38                	je     804f2f <pbuf_realloc+0x10c>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804ef7:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804efa:	29 d9                	sub    %ebx,%ecx
  804efc:	0f b7 c6             	movzwl %si,%eax
  804eff:	01 c8                	add    %ecx,%eax
  804f01:	89 44 24 04          	mov    %eax,0x4(%esp)
  804f05:	89 1c 24             	mov    %ebx,(%esp)
  804f08:	e8 c6 f6 ff ff       	call   8045d3 <mem_realloc>
  804f0d:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804f0f:	85 c0                	test   %eax,%eax
  804f11:	75 1c                	jne    804f2f <pbuf_realloc+0x10c>
  804f13:	c7 44 24 08 00 25 81 	movl   $0x812500,0x8(%esp)
  804f1a:	00 
  804f1b:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  804f22:	00 
  804f23:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804f2a:	e8 51 9f 00 00       	call   80ee80 <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  804f2f:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804f33:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  804f37:	8b 03                	mov    (%ebx),%eax
  804f39:	85 c0                	test   %eax,%eax
  804f3b:	74 08                	je     804f45 <pbuf_realloc+0x122>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  804f3d:	89 04 24             	mov    %eax,(%esp)
  804f40:	e8 0c fe ff ff       	call   804d51 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  804f45:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  804f4b:	83 c4 10             	add    $0x10,%esp
  804f4e:	5b                   	pop    %ebx
  804f4f:	5e                   	pop    %esi
  804f50:	5d                   	pop    %ebp
  804f51:	c3                   	ret    

00804f52 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  804f52:	55                   	push   %ebp
  804f53:	89 e5                	mov    %esp,%ebp
  804f55:	57                   	push   %edi
  804f56:	56                   	push   %esi
  804f57:	53                   	push   %ebx
  804f58:	83 ec 2c             	sub    $0x2c,%esp
  804f5b:	8b 45 08             	mov    0x8(%ebp),%eax
  804f5e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  804f61:	83 f8 01             	cmp    $0x1,%eax
  804f64:	74 11                	je     804f77 <pbuf_alloc+0x25>
  804f66:	83 f8 01             	cmp    $0x1,%eax
  804f69:	72 13                	jb     804f7e <pbuf_alloc+0x2c>
  804f6b:	83 f8 02             	cmp    $0x2,%eax
  804f6e:	74 18                	je     804f88 <pbuf_alloc+0x36>
  804f70:	83 f8 03             	cmp    $0x3,%eax
  804f73:	75 1d                	jne    804f92 <pbuf_alloc+0x40>
  804f75:	eb 37                	jmp    804fae <pbuf_alloc+0x5c>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804f77:	bf 00 00 00 00       	mov    $0x0,%edi
  804f7c:	eb 05                	jmp    804f83 <pbuf_alloc+0x31>
  switch (layer) {
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  804f7e:	bf 14 00 00 00       	mov    $0x14,%edi
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  804f83:	83 c7 14             	add    $0x14,%edi
  804f86:	eb 05                	jmp    804f8d <pbuf_alloc+0x3b>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804f88:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  804f8d:	83 c7 0e             	add    $0xe,%edi
    break;
  804f90:	eb 21                	jmp    804fb3 <pbuf_alloc+0x61>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804f92:	c7 44 24 08 1b 25 81 	movl   $0x81251b,0x8(%esp)
  804f99:	00 
  804f9a:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  804fa1:	00 
  804fa2:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  804fa9:	e8 d2 9e 00 00       	call   80ee80 <_panic>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804fae:	bf 00 00 00 00       	mov    $0x0,%edi
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  804fb3:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  804fb7:	77 0f                	ja     804fc8 <pbuf_alloc+0x76>
  804fb9:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  804fbd:	0f 83 b6 01 00 00    	jae    805179 <pbuf_alloc+0x227>
  804fc3:	e9 71 01 00 00       	jmp    805139 <pbuf_alloc+0x1e7>
  804fc8:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  804fcc:	0f 85 d6 01 00 00    	jne    8051a8 <pbuf_alloc+0x256>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  804fd2:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804fd9:	e8 88 f9 ff ff       	call   804966 <memp_malloc>
  804fde:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  804fe0:	85 c0                	test   %eax,%eax
  804fe2:	0f 84 e6 01 00 00    	je     8051ce <pbuf_alloc+0x27c>
      return NULL;
    }
    p->type = type;
  804fe8:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804fec:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804ff2:	0f b7 ff             	movzwl %di,%edi
  804ff5:	8d 54 38 13          	lea    0x13(%eax,%edi,1),%edx
  804ff9:	83 e2 fc             	and    $0xfffffffc,%edx
  804ffc:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  804fff:	66 89 58 08          	mov    %bx,0x8(%eax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  805003:	0f b7 db             	movzwl %bx,%ebx
  805006:	83 c7 03             	add    $0x3,%edi
  805009:	83 e7 fc             	and    $0xfffffffc,%edi
  80500c:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
  805011:	29 f9                	sub    %edi,%ecx
  805013:	89 c8                	mov    %ecx,%eax
  805015:	39 d9                	cmp    %ebx,%ecx
  805017:	7e 02                	jle    80501b <pbuf_alloc+0xc9>
  805019:	89 d8                	mov    %ebx,%eax
  80501b:	89 c1                	mov    %eax,%ecx
  80501d:	66 89 46 0a          	mov    %ax,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  805021:	8d 86 e0 07 00 00    	lea    0x7e0(%esi),%eax
  805027:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80502a:	0f b7 c1             	movzwl %cx,%eax
  80502d:	01 c2                	add    %eax,%edx
  80502f:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805032:	73 1c                	jae    805050 <pbuf_alloc+0xfe>
  805034:	c7 44 24 08 bc 25 81 	movl   $0x8125bc,0x8(%esp)
  80503b:	00 
  80503c:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  805043:	00 
  805044:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  80504b:	e8 30 9e 00 00       	call   80ee80 <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  805050:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  805056:	0f b7 c9             	movzwl %cx,%ecx
  805059:	29 cb                	sub    %ecx,%ebx
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80505b:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80505d:	e9 ca 00 00 00       	jmp    80512c <pbuf_alloc+0x1da>
      q = memp_malloc(MEMP_PBUF_POOL);
  805062:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  805069:	e8 f8 f8 ff ff       	call   804966 <memp_malloc>
      if (q == NULL) {
  80506e:	85 c0                	test   %eax,%eax
  805070:	75 12                	jne    805084 <pbuf_alloc+0x132>
        /* free chain so far allocated */
        pbuf_free(p);
  805072:	89 34 24             	mov    %esi,(%esp)
  805075:	e8 d7 fc ff ff       	call   804d51 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  80507a:	be 00 00 00 00       	mov    $0x0,%esi
  80507f:	e9 4a 01 00 00       	jmp    8051ce <pbuf_alloc+0x27c>
      }
      q->type = type;
  805084:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  805088:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  80508c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  805092:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  805094:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  80509a:	7e 1c                	jle    8050b8 <pbuf_alloc+0x166>
  80509c:	c7 44 24 08 36 25 81 	movl   $0x812536,0x8(%esp)
  8050a3:	00 
  8050a4:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  8050ab:	00 
  8050ac:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  8050b3:	e8 c8 9d 00 00       	call   80ee80 <_panic>
      q->tot_len = (u16_t)rem_len;
  8050b8:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  8050bc:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  8050c1:	77 04                	ja     8050c7 <pbuf_alloc+0x175>
  8050c3:	89 d9                	mov    %ebx,%ecx
  8050c5:	eb 05                	jmp    8050cc <pbuf_alloc+0x17a>
  8050c7:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
  8050cc:	66 89 48 0a          	mov    %cx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  8050d0:	8d 50 10             	lea    0x10(%eax),%edx
  8050d3:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  8050d6:	f6 c2 03             	test   $0x3,%dl
  8050d9:	74 1c                	je     8050f7 <pbuf_alloc+0x1a5>
  8050db:	c7 44 24 08 f0 25 81 	movl   $0x8125f0,0x8(%esp)
  8050e2:	00 
  8050e3:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  8050ea:	00 
  8050eb:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  8050f2:	e8 89 9d 00 00       	call   80ee80 <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8050f7:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8050fb:	03 56 04             	add    0x4(%esi),%edx
  8050fe:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805101:	73 1c                	jae    80511f <pbuf_alloc+0x1cd>
  805103:	c7 44 24 08 bc 25 81 	movl   $0x8125bc,0x8(%esp)
  80510a:	00 
  80510b:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  805112:	00 
  805113:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  80511a:	e8 61 9d 00 00       	call   80ee80 <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  80511f:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  805125:	0f b7 c9             	movzwl %cx,%ecx
  805128:	29 cb                	sub    %ecx,%ebx
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80512a:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80512c:	85 db                	test   %ebx,%ebx
  80512e:	0f 8f 2e ff ff ff    	jg     805062 <pbuf_alloc+0x110>
  805134:	e9 8b 00 00 00       	jmp    8051c4 <pbuf_alloc+0x272>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  805139:	0f b7 ff             	movzwl %di,%edi
  80513c:	8d 57 13             	lea    0x13(%edi),%edx
  80513f:	83 e2 fc             	and    $0xfffffffc,%edx
  805142:	0f b7 c3             	movzwl %bx,%eax
  805145:	83 c0 03             	add    $0x3,%eax
  805148:	83 e0 fc             	and    $0xfffffffc,%eax
  80514b:	01 d0                	add    %edx,%eax
  80514d:	89 04 24             	mov    %eax,(%esp)
  805150:	e8 c3 f5 ff ff       	call   804718 <mem_malloc>
  805155:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  805157:	85 c0                	test   %eax,%eax
  805159:	74 73                	je     8051ce <pbuf_alloc+0x27c>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80515b:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  80515f:	83 e0 fc             	and    $0xfffffffc,%eax
  805162:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  805165:	66 89 5e 08          	mov    %bx,0x8(%esi)
  805169:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  80516d:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  805173:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  805177:	eb 4b                	jmp    8051c4 <pbuf_alloc+0x272>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  805179:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  805180:	e8 e1 f7 ff ff       	call   804966 <memp_malloc>
  805185:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  805187:	85 c0                	test   %eax,%eax
  805189:	74 43                	je     8051ce <pbuf_alloc+0x27c>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  80518b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  805192:	66 89 58 08          	mov    %bx,0x8(%eax)
  805196:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  80519a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  8051a0:	8a 55 10             	mov    0x10(%ebp),%dl
  8051a3:	88 50 0c             	mov    %dl,0xc(%eax)
    break;
  8051a6:	eb 1c                	jmp    8051c4 <pbuf_alloc+0x272>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  8051a8:	c7 44 24 08 4a 25 81 	movl   $0x81254a,0x8(%esp)
  8051af:	00 
  8051b0:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  8051b7:	00 
  8051b8:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  8051bf:	e8 bc 9c 00 00       	call   80ee80 <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  8051c4:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  8051ca:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  8051ce:	89 f0                	mov    %esi,%eax
  8051d0:	83 c4 2c             	add    $0x2c,%esp
  8051d3:	5b                   	pop    %ebx
  8051d4:	5e                   	pop    %esi
  8051d5:	5f                   	pop    %edi
  8051d6:	5d                   	pop    %ebp
  8051d7:	c3                   	ret    

008051d8 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  8051d8:	55                   	push   %ebp
  8051d9:	89 e5                	mov    %esp,%ebp
  8051db:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  8051de:	b0 00                	mov    $0x0,%al
  while (p != NULL) {
  8051e0:	eb 03                	jmp    8051e5 <pbuf_clen+0xd>
    ++len;
  8051e2:	40                   	inc    %eax
    p = p->next;
  8051e3:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  8051e5:	85 d2                	test   %edx,%edx
  8051e7:	75 f9                	jne    8051e2 <pbuf_clen+0xa>
    ++len;
    p = p->next;
  }
  return len;
}
  8051e9:	5d                   	pop    %ebp
  8051ea:	c3                   	ret    

008051eb <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  8051eb:	55                   	push   %ebp
  8051ec:	89 e5                	mov    %esp,%ebp
  8051ee:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  8051f1:	85 c0                	test   %eax,%eax
  8051f3:	74 04                	je     8051f9 <pbuf_ref+0xe>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  8051f5:	66 ff 40 0e          	incw   0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  8051f9:	5d                   	pop    %ebp
  8051fa:	c3                   	ret    

008051fb <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  8051fb:	55                   	push   %ebp
  8051fc:	89 e5                	mov    %esp,%ebp
  8051fe:	53                   	push   %ebx
  8051ff:	83 ec 14             	sub    $0x14,%esp
  805202:	8b 45 08             	mov    0x8(%ebp),%eax
  805205:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  805208:	85 c0                	test   %eax,%eax
  80520a:	74 04                	je     805210 <pbuf_cat+0x15>
  80520c:	85 db                	test   %ebx,%ebx
  80520e:	75 25                	jne    805235 <pbuf_cat+0x3a>
  805210:	c7 44 24 08 20 26 81 	movl   $0x812620,0x8(%esp)
  805217:	00 
  805218:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  80521f:	00 
  805220:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  805227:	e8 54 9c 00 00       	call   80ee80 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  80522c:	8b 4b 08             	mov    0x8(%ebx),%ecx
  80522f:	66 01 48 08          	add    %cx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  805233:	89 d0                	mov    %edx,%eax
  805235:	8b 10                	mov    (%eax),%edx
  805237:	85 d2                	test   %edx,%edx
  805239:	75 f1                	jne    80522c <pbuf_cat+0x31>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80523b:	8b 50 08             	mov    0x8(%eax),%edx
  80523e:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  805242:	74 1c                	je     805260 <pbuf_cat+0x65>
  805244:	c7 44 24 08 58 26 81 	movl   $0x812658,0x8(%esp)
  80524b:	00 
  80524c:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  805253:	00 
  805254:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  80525b:	e8 20 9c 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  805260:	03 53 08             	add    0x8(%ebx),%edx
  805263:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  805267:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  805269:	83 c4 14             	add    $0x14,%esp
  80526c:	5b                   	pop    %ebx
  80526d:	5d                   	pop    %ebp
  80526e:	c3                   	ret    

0080526f <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80526f:	55                   	push   %ebp
  805270:	89 e5                	mov    %esp,%ebp
  805272:	53                   	push   %ebx
  805273:	83 ec 14             	sub    $0x14,%esp
  805276:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  805279:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80527d:	8b 45 08             	mov    0x8(%ebp),%eax
  805280:	89 04 24             	mov    %eax,(%esp)
  805283:	e8 73 ff ff ff       	call   8051fb <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  805288:	89 1c 24             	mov    %ebx,(%esp)
  80528b:	e8 5b ff ff ff       	call   8051eb <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  805290:	83 c4 14             	add    $0x14,%esp
  805293:	5b                   	pop    %ebx
  805294:	5d                   	pop    %ebp
  805295:	c3                   	ret    

00805296 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  805296:	55                   	push   %ebp
  805297:	89 e5                	mov    %esp,%ebp
  805299:	57                   	push   %edi
  80529a:	56                   	push   %esi
  80529b:	53                   	push   %ebx
  80529c:	83 ec 2c             	sub    $0x2c,%esp
  80529f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  8052a2:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  8052a4:	85 f6                	test   %esi,%esi
  8052a6:	74 56                	je     8052fe <pbuf_dechain+0x68>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  8052a8:	8b 53 08             	mov    0x8(%ebx),%edx
  8052ab:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  8052af:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  8052b3:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8052b6:	0f b7 fa             	movzwl %dx,%edi
  8052b9:	0f b7 c8             	movzwl %ax,%ecx
  8052bc:	29 cf                	sub    %ecx,%edi
  8052be:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  8052c1:	74 1c                	je     8052df <pbuf_dechain+0x49>
  8052c3:	c7 44 24 08 88 26 81 	movl   $0x812688,0x8(%esp)
  8052ca:	00 
  8052cb:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  8052d2:	00 
  8052d3:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  8052da:	e8 a1 9b 00 00       	call   80ee80 <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  8052df:	66 29 c2             	sub    %ax,%dx
  8052e2:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  8052e6:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  8052ec:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  8052f0:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  8052f4:	89 34 24             	mov    %esi,(%esp)
  8052f7:	e8 55 fa ff ff       	call   804d51 <pbuf_free>
  8052fc:	eb 02                	jmp    805300 <pbuf_dechain+0x6a>
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  struct pbuf *q;
  u8_t tail_gone = 1;
  8052fe:	b0 01                	mov    $0x1,%al
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  805300:	66 8b 53 0a          	mov    0xa(%ebx),%dx
  805304:	66 39 53 08          	cmp    %dx,0x8(%ebx)
  805308:	74 1c                	je     805326 <pbuf_dechain+0x90>
  80530a:	c7 44 24 08 65 25 81 	movl   $0x812565,0x8(%esp)
  805311:	00 
  805312:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  805319:	00 
  80531a:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  805321:	e8 5a 9b 00 00       	call   80ee80 <_panic>
  return ((tail_gone > 0) ? NULL : q);
  805326:	84 c0                	test   %al,%al
  805328:	74 05                	je     80532f <pbuf_dechain+0x99>
  80532a:	be 00 00 00 00       	mov    $0x0,%esi
}
  80532f:	89 f0                	mov    %esi,%eax
  805331:	83 c4 2c             	add    $0x2c,%esp
  805334:	5b                   	pop    %ebx
  805335:	5e                   	pop    %esi
  805336:	5f                   	pop    %edi
  805337:	5d                   	pop    %ebp
  805338:	c3                   	ret    

00805339 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  805339:	55                   	push   %ebp
  80533a:	89 e5                	mov    %esp,%ebp
  80533c:	57                   	push   %edi
  80533d:	56                   	push   %esi
  80533e:	53                   	push   %ebx
  80533f:	83 ec 2c             	sub    $0x2c,%esp
  805342:	8b 7d 0c             	mov    0xc(%ebp),%edi

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  805345:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  805349:	74 10                	je     80535b <pbuf_copy+0x22>
  80534b:	85 ff                	test   %edi,%edi
  80534d:	74 0c                	je     80535b <pbuf_copy+0x22>
  80534f:	8b 57 08             	mov    0x8(%edi),%edx
  805352:	8b 45 08             	mov    0x8(%ebp),%eax
  805355:	66 39 50 08          	cmp    %dx,0x8(%eax)
  805359:	73 3e                	jae    805399 <pbuf_copy+0x60>
  80535b:	c7 44 24 08 ac 26 81 	movl   $0x8126ac,0x8(%esp)
  805362:	00 
  805363:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  80536a:	00 
  80536b:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  805372:	e8 09 9b 00 00       	call   80ee80 <_panic>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  805377:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80537b:	75 26                	jne    8053a3 <pbuf_copy+0x6a>
  80537d:	c7 44 24 08 7a 25 81 	movl   $0x81257a,0x8(%esp)
  805384:	00 
  805385:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  80538c:	00 
  80538d:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  805394:	e8 e7 9a 00 00       	call   80ee80 <_panic>

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  805399:	bb 00 00 00 00       	mov    $0x0,%ebx
  80539e:	be 00 00 00 00       	mov    $0x0,%esi
  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  8053a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8053a6:	66 8b 40 0a          	mov    0xa(%eax),%ax
  8053aa:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  8053ae:	66 8b 4f 0a          	mov    0xa(%edi),%cx
  8053b2:	0f b7 d0             	movzwl %ax,%edx
  8053b5:	0f b7 c6             	movzwl %si,%eax
  8053b8:	29 c2                	sub    %eax,%edx
  8053ba:	89 55 e0             	mov    %edx,-0x20(%ebp)
  8053bd:	0f b7 d1             	movzwl %cx,%edx
  8053c0:	0f b7 c3             	movzwl %bx,%eax
  8053c3:	29 c2                	sub    %eax,%edx
  8053c5:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  8053c8:	7c 09                	jl     8053d3 <pbuf_copy+0x9a>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  8053ca:	66 29 d9             	sub    %bx,%cx
  8053cd:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  8053d1:	eb 0b                	jmp    8053de <pbuf_copy+0xa5>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  8053d3:	66 8b 55 e6          	mov    -0x1a(%ebp),%dx
  8053d7:	66 29 f2             	sub    %si,%dx
  8053da:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  8053de:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8053e2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8053e6:	0f b7 c3             	movzwl %bx,%eax
  8053e9:	03 47 04             	add    0x4(%edi),%eax
  8053ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8053f0:	0f b7 c6             	movzwl %si,%eax
  8053f3:	8b 55 08             	mov    0x8(%ebp),%edx
  8053f6:	03 42 04             	add    0x4(%edx),%eax
  8053f9:	89 04 24             	mov    %eax,(%esp)
  8053fc:	e8 05 a3 00 00       	call   80f706 <memcpy>
    offset_to += len;
  805401:	66 03 75 e6          	add    -0x1a(%ebp),%si
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  805405:	8b 55 08             	mov    0x8(%ebp),%edx
  805408:	66 8b 42 0a          	mov    0xa(%edx),%ax
  80540c:	66 39 c6             	cmp    %ax,%si
  80540f:	76 1c                	jbe    80542d <pbuf_copy+0xf4>
  805411:	c7 44 24 08 87 25 81 	movl   $0x812587,0x8(%esp)
  805418:	00 
  805419:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  805420:	00 
  805421:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  805428:	e8 53 9a 00 00       	call   80ee80 <_panic>
    if (offset_to == p_to->len) {
  80542d:	66 39 c6             	cmp    %ax,%si
  805430:	75 0d                	jne    80543f <pbuf_copy+0x106>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  805432:	8b 45 08             	mov    0x8(%ebp),%eax
  805435:	8b 00                	mov    (%eax),%eax
  805437:	89 45 08             	mov    %eax,0x8(%ebp)
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  80543a:	be 00 00 00 00       	mov    $0x0,%esi
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
  80543f:	66 03 5d e6          	add    -0x1a(%ebp),%bx
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  805443:	66 8b 47 0a          	mov    0xa(%edi),%ax
  805447:	66 39 c3             	cmp    %ax,%bx
  80544a:	76 1c                	jbe    805468 <pbuf_copy+0x12f>
  80544c:	c7 44 24 08 9e 25 81 	movl   $0x81259e,0x8(%esp)
  805453:	00 
  805454:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  80545b:	00 
  80545c:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  805463:	e8 18 9a 00 00       	call   80ee80 <_panic>
    if (offset_from >= p_from->len) {
  805468:	66 39 c3             	cmp    %ax,%bx
  80546b:	72 07                	jb     805474 <pbuf_copy+0x13b>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  80546d:	8b 3f                	mov    (%edi),%edi
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  80546f:	bb 00 00 00 00       	mov    $0x0,%ebx
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  805474:	85 ff                	test   %edi,%edi
  805476:	74 2a                	je     8054a2 <pbuf_copy+0x169>
  805478:	8b 57 08             	mov    0x8(%edi),%edx
  80547b:	66 39 57 0a          	cmp    %dx,0xa(%edi)
  80547f:	75 21                	jne    8054a2 <pbuf_copy+0x169>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  805481:	83 3f 00             	cmpl   $0x0,(%edi)
  805484:	74 1c                	je     8054a2 <pbuf_copy+0x169>
  805486:	c7 44 24 08 dc 26 81 	movl   $0x8126dc,0x8(%esp)
  80548d:	00 
  80548e:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  805495:	00 
  805496:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  80549d:	e8 de 99 00 00       	call   80ee80 <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  8054a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8054a6:	74 2d                	je     8054d5 <pbuf_copy+0x19c>
  8054a8:	8b 45 08             	mov    0x8(%ebp),%eax
  8054ab:	8b 50 08             	mov    0x8(%eax),%edx
  8054ae:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  8054b2:	75 21                	jne    8054d5 <pbuf_copy+0x19c>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  8054b4:	83 38 00             	cmpl   $0x0,(%eax)
  8054b7:	74 1c                	je     8054d5 <pbuf_copy+0x19c>
  8054b9:	c7 44 24 08 dc 26 81 	movl   $0x8126dc,0x8(%esp)
  8054c0:	00 
  8054c1:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  8054c8:	00 
  8054c9:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  8054d0:	e8 ab 99 00 00       	call   80ee80 <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  8054d5:	85 ff                	test   %edi,%edi
  8054d7:	0f 85 9a fe ff ff    	jne    805377 <pbuf_copy+0x3e>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  8054dd:	b0 00                	mov    $0x0,%al
  8054df:	83 c4 2c             	add    $0x2c,%esp
  8054e2:	5b                   	pop    %ebx
  8054e3:	5e                   	pop    %esi
  8054e4:	5f                   	pop    %edi
  8054e5:	5d                   	pop    %ebp
  8054e6:	c3                   	ret    

008054e7 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  8054e7:	55                   	push   %ebp
  8054e8:	89 e5                	mov    %esp,%ebp
  8054ea:	57                   	push   %edi
  8054eb:	56                   	push   %esi
  8054ec:	53                   	push   %ebx
  8054ed:	83 ec 2c             	sub    $0x2c,%esp
  8054f0:	8b 7d 08             	mov    0x8(%ebp),%edi
  8054f3:	8b 75 10             	mov    0x10(%ebp),%esi
  8054f6:	8b 45 14             	mov    0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  8054f9:	85 ff                	test   %edi,%edi
  8054fb:	75 1c                	jne    805519 <pbuf_copy_partial+0x32>
  8054fd:	c7 44 24 08 08 27 81 	movl   $0x812708,0x8(%esp)
  805504:	00 
  805505:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  80550c:	00 
  80550d:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  805514:	e8 67 99 00 00       	call   80ee80 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  805519:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80551d:	75 73                	jne    805592 <pbuf_copy_partial+0xab>
  80551f:	c7 44 24 08 2c 27 81 	movl   $0x81272c,0x8(%esp)
  805526:	00 
  805527:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  80552e:	00 
  80552f:	c7 04 24 38 24 81 00 	movl   $0x812438,(%esp)
  805536:	e8 45 99 00 00       	call   80ee80 <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  80553b:	66 85 c0             	test   %ax,%ax
  80553e:	74 0e                	je     80554e <pbuf_copy_partial+0x67>
  805540:	66 8b 57 0a          	mov    0xa(%edi),%dx
  805544:	66 39 d0             	cmp    %dx,%ax
  805547:	72 05                	jb     80554e <pbuf_copy_partial+0x67>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  805549:	66 29 d0             	sub    %dx,%ax
  80554c:	eb 40                	jmp    80558e <pbuf_copy_partial+0xa7>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80554e:	66 8b 57 0a          	mov    0xa(%edi),%dx
  805552:	66 29 c2             	sub    %ax,%dx
  805555:	89 d3                	mov    %edx,%ebx
  805557:	66 39 f2             	cmp    %si,%dx
  80555a:	76 02                	jbe    80555e <pbuf_copy_partial+0x77>
  80555c:	89 f3                	mov    %esi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80555e:	0f b7 d3             	movzwl %bx,%edx
  805561:	89 54 24 08          	mov    %edx,0x8(%esp)
  805565:	0f b7 c0             	movzwl %ax,%eax
  805568:	03 47 04             	add    0x4(%edi),%eax
  80556b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80556f:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805573:	03 45 0c             	add    0xc(%ebp),%eax
  805576:	89 04 24             	mov    %eax,(%esp)
  805579:	e8 88 a1 00 00       	call   80f706 <memcpy>
      copied_total += buf_copy_len;
  80557e:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  805582:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  805586:	66 29 de             	sub    %bx,%si
      offset = 0;
  805589:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80558e:	8b 3f                	mov    (%edi),%edi
  805590:	eb 0c                	jmp    80559e <pbuf_copy_partial+0xb7>
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  805592:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  805598:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80559e:	66 85 f6             	test   %si,%si
  8055a1:	74 04                	je     8055a7 <pbuf_copy_partial+0xc0>
  8055a3:	85 ff                	test   %edi,%edi
  8055a5:	75 94                	jne    80553b <pbuf_copy_partial+0x54>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  8055a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8055aa:	83 c4 2c             	add    $0x2c,%esp
  8055ad:	5b                   	pop    %ebx
  8055ae:	5e                   	pop    %esi
  8055af:	5f                   	pop    %edi
  8055b0:	5d                   	pop    %ebp
  8055b1:	c3                   	ret    
	...

008055b4 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  8055b4:	55                   	push   %ebp
  8055b5:	89 e5                	mov    %esp,%ebp
  8055b7:	83 ec 18             	sub    $0x18,%esp
  8055ba:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  8055bd:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  8055c2:	8b 40 04             	mov    0x4(%eax),%eax
  8055c5:	8b 00                	mov    (%eax),%eax
  8055c7:	89 04 24             	mov    %eax,(%esp)
  8055ca:	e8 f2 51 00 00       	call   80a7c1 <sys_sem_signal>
}
  8055cf:	c9                   	leave  
  8055d0:	c3                   	ret    

008055d1 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  8055d1:	55                   	push   %ebp
  8055d2:	89 e5                	mov    %esp,%ebp
  8055d4:	57                   	push   %edi
  8055d5:	56                   	push   %esi
  8055d6:	53                   	push   %ebx
  8055d7:	83 ec 1c             	sub    $0x1c,%esp
  8055da:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  8055dd:	e8 74 56 00 00       	call   80ac56 <sys_arch_timeouts>
  8055e2:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8055e4:	85 c0                	test   %eax,%eax
  8055e6:	74 06                	je     8055ee <sys_mbox_fetch+0x1d>
  8055e8:	8b 00                	mov    (%eax),%eax
  8055ea:	85 c0                	test   %eax,%eax
  8055ec:	75 19                	jne    805607 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  8055ee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8055f5:	00 
  8055f6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8055fa:	8b 45 08             	mov    0x8(%ebp),%eax
  8055fd:	89 04 24             	mov    %eax,(%esp)
  805600:	e8 68 54 00 00       	call   80aa6d <sys_arch_mbox_fetch>
  805605:	eb 5d                	jmp    805664 <sys_mbox_fetch+0x93>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  805607:	8b 40 04             	mov    0x4(%eax),%eax
  80560a:	85 c0                	test   %eax,%eax
  80560c:	74 18                	je     805626 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80560e:	89 44 24 08          	mov    %eax,0x8(%esp)
  805612:	89 7c 24 04          	mov    %edi,0x4(%esp)
  805616:	8b 45 08             	mov    0x8(%ebp),%eax
  805619:	89 04 24             	mov    %eax,(%esp)
  80561c:	e8 4c 54 00 00       	call   80aa6d <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  805621:	83 f8 ff             	cmp    $0xffffffff,%eax
  805624:	75 27                	jne    80564d <sys_mbox_fetch+0x7c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  805626:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805628:	8b 10                	mov    (%eax),%edx
  80562a:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  80562c:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80562f:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805632:	89 44 24 04          	mov    %eax,0x4(%esp)
  805636:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80563d:	e8 84 f3 ff ff       	call   8049c6 <memp_free>
      if (h != NULL) {
  805642:	85 db                	test   %ebx,%ebx
  805644:	74 97                	je     8055dd <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  805646:	89 34 24             	mov    %esi,(%esp)
  805649:	ff d3                	call   *%ebx
  80564b:	eb 90                	jmp    8055dd <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80564d:	8b 13                	mov    (%ebx),%edx
  80564f:	8b 4a 04             	mov    0x4(%edx),%ecx
  805652:	39 c8                	cmp    %ecx,%eax
  805654:	73 07                	jae    80565d <sys_mbox_fetch+0x8c>
        timeouts->next->time -= time_needed;
  805656:	29 c1                	sub    %eax,%ecx
  805658:	89 4a 04             	mov    %ecx,0x4(%edx)
  80565b:	eb 07                	jmp    805664 <sys_mbox_fetch+0x93>
      } else {
        timeouts->next->time = 0;
  80565d:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  805664:	83 c4 1c             	add    $0x1c,%esp
  805667:	5b                   	pop    %ebx
  805668:	5e                   	pop    %esi
  805669:	5f                   	pop    %edi
  80566a:	5d                   	pop    %ebp
  80566b:	c3                   	ret    

0080566c <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80566c:	55                   	push   %ebp
  80566d:	89 e5                	mov    %esp,%ebp
  80566f:	57                   	push   %edi
  805670:	56                   	push   %esi
  805671:	53                   	push   %ebx
  805672:	83 ec 1c             	sub    $0x1c,%esp
  805675:	8b 7d 08             	mov    0x8(%ebp),%edi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  805678:	e8 d9 55 00 00       	call   80ac56 <sys_arch_timeouts>
  80567d:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80567f:	85 c0                	test   %eax,%eax
  805681:	74 06                	je     805689 <sys_sem_wait+0x1d>
  805683:	8b 00                	mov    (%eax),%eax
  805685:	85 c0                	test   %eax,%eax
  805687:	75 12                	jne    80569b <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  805689:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805690:	00 
  805691:	89 3c 24             	mov    %edi,(%esp)
  805694:	e8 8c 51 00 00       	call   80a825 <sys_arch_sem_wait>
  805699:	eb 56                	jmp    8056f1 <sys_sem_wait+0x85>
  } else {
    if (timeouts->next->time > 0) {
  80569b:	8b 40 04             	mov    0x4(%eax),%eax
  80569e:	85 c0                	test   %eax,%eax
  8056a0:	74 11                	je     8056b3 <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  8056a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8056a6:	89 3c 24             	mov    %edi,(%esp)
  8056a9:	e8 77 51 00 00       	call   80a825 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8056ae:	83 f8 ff             	cmp    $0xffffffff,%eax
  8056b1:	75 27                	jne    8056da <sys_sem_wait+0x6e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8056b3:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8056b5:	8b 10                	mov    (%eax),%edx
  8056b7:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  8056b9:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8056bc:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8056bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8056c3:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8056ca:	e8 f7 f2 ff ff       	call   8049c6 <memp_free>
      if (h != NULL) {
  8056cf:	85 db                	test   %ebx,%ebx
  8056d1:	74 a5                	je     805678 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  8056d3:	89 34 24             	mov    %esi,(%esp)
  8056d6:	ff d3                	call   *%ebx
  8056d8:	eb 9e                	jmp    805678 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8056da:	8b 13                	mov    (%ebx),%edx
  8056dc:	8b 4a 04             	mov    0x4(%edx),%ecx
  8056df:	39 c8                	cmp    %ecx,%eax
  8056e1:	73 07                	jae    8056ea <sys_sem_wait+0x7e>
        timeouts->next->time -= time_needed;
  8056e3:	29 c1                	sub    %eax,%ecx
  8056e5:	89 4a 04             	mov    %ecx,0x4(%edx)
  8056e8:	eb 07                	jmp    8056f1 <sys_sem_wait+0x85>
      } else {
        timeouts->next->time = 0;
  8056ea:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  8056f1:	83 c4 1c             	add    $0x1c,%esp
  8056f4:	5b                   	pop    %ebx
  8056f5:	5e                   	pop    %esi
  8056f6:	5f                   	pop    %edi
  8056f7:	5d                   	pop    %ebp
  8056f8:	c3                   	ret    

008056f9 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8056f9:	55                   	push   %ebp
  8056fa:	89 e5                	mov    %esp,%ebp
  8056fc:	56                   	push   %esi
  8056fd:	53                   	push   %ebx
  8056fe:	83 ec 10             	sub    $0x10,%esp
  805701:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  805704:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80570b:	e8 56 f2 ff ff       	call   804966 <memp_malloc>
  805710:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  805712:	85 c0                	test   %eax,%eax
  805714:	75 1c                	jne    805732 <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  805716:	c7 44 24 08 51 27 81 	movl   $0x812751,0x8(%esp)
  80571d:	00 
  80571e:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  805725:	00 
  805726:	c7 04 24 6e 27 81 00 	movl   $0x81276e,(%esp)
  80572d:	e8 4e 97 00 00       	call   80ee80 <_panic>
    return;
  }
  timeout->next = NULL;
  805732:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  805738:	8b 45 0c             	mov    0xc(%ebp),%eax
  80573b:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  80573e:	8b 45 10             	mov    0x10(%ebp),%eax
  805741:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  805744:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  805747:	e8 0a 55 00 00       	call   80ac56 <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80574c:	85 c0                	test   %eax,%eax
  80574e:	75 1c                	jne    80576c <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  805750:	c7 44 24 08 82 27 81 	movl   $0x812782,0x8(%esp)
  805757:	00 
  805758:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  80575f:	00 
  805760:	c7 04 24 6e 27 81 00 	movl   $0x81276e,(%esp)
  805767:	e8 14 97 00 00       	call   80ee80 <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  80576c:	8b 10                	mov    (%eax),%edx
  80576e:	85 d2                	test   %edx,%edx
  805770:	75 04                	jne    805776 <sys_timeout+0x7d>
    timeouts->next = timeout;
  805772:	89 18                	mov    %ebx,(%eax)
    return;
  805774:	eb 39                	jmp    8057af <sys_timeout+0xb6>
  }

  if (timeouts->next->time > msecs) {
  805776:	8b 4a 04             	mov    0x4(%edx),%ecx
  805779:	39 ce                	cmp    %ecx,%esi
  80577b:	73 0d                	jae    80578a <sys_timeout+0x91>
    timeouts->next->time -= msecs;
  80577d:	29 f1                	sub    %esi,%ecx
  80577f:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  805782:	8b 10                	mov    (%eax),%edx
  805784:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  805786:	89 18                	mov    %ebx,(%eax)
  805788:	eb 25                	jmp    8057af <sys_timeout+0xb6>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  80578a:	8b 4b 04             	mov    0x4(%ebx),%ecx
  80578d:	2b 4a 04             	sub    0x4(%edx),%ecx
  805790:	89 4b 04             	mov    %ecx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  805793:	8b 02                	mov    (%edx),%eax
  805795:	85 c0                	test   %eax,%eax
  805797:	74 09                	je     8057a2 <sys_timeout+0xa9>
  805799:	3b 48 04             	cmp    0x4(%eax),%ecx
  80579c:	72 0c                	jb     8057aa <sys_timeout+0xb1>
  80579e:	89 c2                	mov    %eax,%edx
  8057a0:	eb e8                	jmp    80578a <sys_timeout+0x91>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
  8057a2:	8b 02                	mov    (%edx),%eax
  8057a4:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  8057a6:	89 1a                	mov    %ebx,(%edx)
        break;
  8057a8:	eb 05                	jmp    8057af <sys_timeout+0xb6>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  8057aa:	29 48 04             	sub    %ecx,0x4(%eax)
  8057ad:	eb f3                	jmp    8057a2 <sys_timeout+0xa9>
        t->next = timeout;
        break;
      }
    }
  }
}
  8057af:	83 c4 10             	add    $0x10,%esp
  8057b2:	5b                   	pop    %ebx
  8057b3:	5e                   	pop    %esi
  8057b4:	5d                   	pop    %ebp
  8057b5:	c3                   	ret    

008057b6 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  8057b6:	55                   	push   %ebp
  8057b7:	89 e5                	mov    %esp,%ebp
  8057b9:	57                   	push   %edi
  8057ba:	56                   	push   %esi
  8057bb:	53                   	push   %ebx
  8057bc:	83 ec 1c             	sub    $0x1c,%esp
  8057bf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8057c2:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  8057c5:	e8 8c 54 00 00       	call   80ac56 <sys_arch_timeouts>

  if (timeouts == NULL) {
  8057ca:	85 c0                	test   %eax,%eax
  8057cc:	75 1c                	jne    8057ea <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  8057ce:	c7 44 24 08 a0 27 81 	movl   $0x8127a0,0x8(%esp)
  8057d5:	00 
  8057d6:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  8057dd:	00 
  8057de:	c7 04 24 6e 27 81 00 	movl   $0x81276e,(%esp)
  8057e5:	e8 96 96 00 00       	call   80ee80 <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  8057ea:	8b 10                	mov    (%eax),%edx
  8057ec:	85 d2                	test   %edx,%edx
  8057ee:	74 47                	je     805837 <sys_untimeout+0x81>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8057f0:	bf 00 00 00 00       	mov    $0x0,%edi
  8057f5:	eb 04                	jmp    8057fb <sys_untimeout+0x45>
  8057f7:	89 d7                	mov    %edx,%edi
  8057f9:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  8057fb:	39 5a 08             	cmp    %ebx,0x8(%edx)
  8057fe:	75 31                	jne    805831 <sys_untimeout+0x7b>
  805800:	39 72 0c             	cmp    %esi,0xc(%edx)
  805803:	75 2c                	jne    805831 <sys_untimeout+0x7b>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  805805:	85 ff                	test   %edi,%edi
  805807:	75 06                	jne    80580f <sys_untimeout+0x59>
        timeouts->next = t->next;
  805809:	8b 0a                	mov    (%edx),%ecx
  80580b:	89 08                	mov    %ecx,(%eax)
  80580d:	eb 04                	jmp    805813 <sys_untimeout+0x5d>
      else
        prev_t->next = t->next;
  80580f:	8b 02                	mov    (%edx),%eax
  805811:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  805813:	8b 02                	mov    (%edx),%eax
  805815:	85 c0                	test   %eax,%eax
  805817:	74 06                	je     80581f <sys_untimeout+0x69>
        t->next->time += t->time;
  805819:	8b 4a 04             	mov    0x4(%edx),%ecx
  80581c:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80581f:	89 54 24 04          	mov    %edx,0x4(%esp)
  805823:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80582a:	e8 97 f1 ff ff       	call   8049c6 <memp_free>
      return;
  80582f:	eb 06                	jmp    805837 <sys_untimeout+0x81>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805831:	8b 0a                	mov    (%edx),%ecx
  805833:	85 c9                	test   %ecx,%ecx
  805835:	75 c0                	jne    8057f7 <sys_untimeout+0x41>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  805837:	83 c4 1c             	add    $0x1c,%esp
  80583a:	5b                   	pop    %ebx
  80583b:	5e                   	pop    %esi
  80583c:	5f                   	pop    %edi
  80583d:	5d                   	pop    %ebp
  80583e:	c3                   	ret    

0080583f <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80583f:	55                   	push   %ebp
  805840:	89 e5                	mov    %esp,%ebp
  805842:	83 ec 28             	sub    $0x28,%esp
  805845:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  805848:	8d 55 08             	lea    0x8(%ebp),%edx
  80584b:	89 55 f4             	mov    %edx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  80584e:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  805854:	85 c0                	test   %eax,%eax
  805856:	74 17                	je     80586f <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  805858:	8d 55 f0             	lea    -0x10(%ebp),%edx
  80585b:	89 54 24 08          	mov    %edx,0x8(%esp)
  80585f:	c7 44 24 04 b4 55 80 	movl   $0x8055b4,0x4(%esp)
  805866:	00 
  805867:	89 04 24             	mov    %eax,(%esp)
  80586a:	e8 8a fe ff ff       	call   8056f9 <sys_timeout>
  }
  sys_sem_wait(sem);
  80586f:	8b 45 08             	mov    0x8(%ebp),%eax
  805872:	89 04 24             	mov    %eax,(%esp)
  805875:	e8 f2 fd ff ff       	call   80566c <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80587a:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80587f:	75 1a                	jne    80589b <sys_sem_wait_timeout+0x5c>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  805881:	8d 45 f0             	lea    -0x10(%ebp),%eax
  805884:	89 44 24 04          	mov    %eax,0x4(%esp)
  805888:	c7 04 24 b4 55 80 00 	movl   $0x8055b4,(%esp)
  80588f:	e8 22 ff ff ff       	call   8057b6 <sys_untimeout>
    return 1;
  805894:	b8 01 00 00 00       	mov    $0x1,%eax
  805899:	eb 05                	jmp    8058a0 <sys_sem_wait_timeout+0x61>
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
    /* timeout */
    return 0;
  80589b:	b8 00 00 00 00       	mov    $0x0,%eax
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  8058a0:	c9                   	leave  
  8058a1:	c3                   	ret    

008058a2 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  8058a2:	55                   	push   %ebp
  8058a3:	89 e5                	mov    %esp,%ebp
  8058a5:	53                   	push   %ebx
  8058a6:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  8058a9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8058b0:	e8 fe 4b 00 00       	call   80a4b3 <sys_sem_new>
  8058b5:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  8058b7:	8b 45 08             	mov    0x8(%ebp),%eax
  8058ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  8058be:	89 1c 24             	mov    %ebx,(%esp)
  8058c1:	e8 79 ff ff ff       	call   80583f <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  8058c6:	89 1c 24             	mov    %ebx,(%esp)
  8058c9:	e8 81 4c 00 00       	call   80a54f <sys_sem_free>
}
  8058ce:	83 c4 14             	add    $0x14,%esp
  8058d1:	5b                   	pop    %ebx
  8058d2:	5d                   	pop    %ebp
  8058d3:	c3                   	ret    

008058d4 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  8058d4:	55                   	push   %ebp
  8058d5:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  8058d7:	b0 fb                	mov    $0xfb,%al
  8058d9:	5d                   	pop    %ebp
  8058da:	c3                   	ret    

008058db <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  8058db:	55                   	push   %ebp
  8058dc:	89 e5                	mov    %esp,%ebp
  8058de:	56                   	push   %esi
  8058df:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8058e0:	8b 0d 7c c2 b3 00    	mov    0xb3c27c,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8058e6:	8b 1d 90 c2 b3 00    	mov    0xb3c290,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8058ec:	8b 35 84 c2 b3 00    	mov    0xb3c284,%esi
  8058f2:	66 a1 08 50 81 00    	mov    0x815008,%ax
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8058f8:	66 40                	inc    %ax
  8058fa:	79 05                	jns    805901 <tcp_new_port+0x26>
    port = TCP_LOCAL_PORT_RANGE_START;
  8058fc:	b8 00 10 00 00       	mov    $0x1000,%eax
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805901:	89 ca                	mov    %ecx,%edx
  805903:	eb 09                	jmp    80590e <tcp_new_port+0x33>
    if (pcb->local_port == port) {
  805905:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805909:	74 ed                	je     8058f8 <tcp_new_port+0x1d>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80590b:	8b 52 0c             	mov    0xc(%edx),%edx
  80590e:	85 d2                	test   %edx,%edx
  805910:	75 f3                	jne    805905 <tcp_new_port+0x2a>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805912:	89 da                	mov    %ebx,%edx
  805914:	eb 09                	jmp    80591f <tcp_new_port+0x44>
    if (pcb->local_port == port) {
  805916:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80591a:	74 dc                	je     8058f8 <tcp_new_port+0x1d>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80591c:	8b 52 0c             	mov    0xc(%edx),%edx
  80591f:	85 d2                	test   %edx,%edx
  805921:	75 f3                	jne    805916 <tcp_new_port+0x3b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805923:	89 f2                	mov    %esi,%edx
  805925:	eb 09                	jmp    805930 <tcp_new_port+0x55>
    if (pcb->local_port == port) {
  805927:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80592b:	74 cb                	je     8058f8 <tcp_new_port+0x1d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80592d:	8b 52 0c             	mov    0xc(%edx),%edx
  805930:	85 d2                	test   %edx,%edx
  805932:	75 f3                	jne    805927 <tcp_new_port+0x4c>
  805934:	66 a3 08 50 81 00    	mov    %ax,0x815008
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  80593a:	5b                   	pop    %ebx
  80593b:	5e                   	pop    %esi
  80593c:	5d                   	pop    %ebp
  80593d:	c3                   	ret    

0080593e <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80593e:	55                   	push   %ebp
  80593f:	89 e5                	mov    %esp,%ebp
  805941:	57                   	push   %edi
  805942:	56                   	push   %esi
  805943:	53                   	push   %ebx
  805944:	83 ec 1c             	sub    $0x1c,%esp
  805947:	8b 75 08             	mov    0x8(%ebp),%esi
  80594a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80594d:	8b 45 10             	mov    0x10(%ebp),%eax
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805950:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  805954:	74 1c                	je     805972 <tcp_bind+0x34>
  805956:	c7 44 24 08 c0 27 81 	movl   $0x8127c0,0x8(%esp)
  80595d:	00 
  80595e:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  805965:	00 
  805966:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  80596d:	e8 0e 95 00 00       	call   80ee80 <_panic>

  if (port == 0) {
  805972:	66 85 c0             	test   %ax,%ax
  805975:	75 05                	jne    80597c <tcp_bind+0x3e>
    port = tcp_new_port();
  805977:	e8 5f ff ff ff       	call   8058db <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80597c:	8b 15 84 c2 b3 00    	mov    0xb3c284,%edx
  805982:	eb 35                	jmp    8059b9 <tcp_bind+0x7b>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  805984:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805988:	75 2c                	jne    8059b6 <tcp_bind+0x78>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80598a:	85 d2                	test   %edx,%edx
  80598c:	0f 84 f0 00 00 00    	je     805a82 <tcp_bind+0x144>
  805992:	8b 0a                	mov    (%edx),%ecx
  805994:	85 c9                	test   %ecx,%ecx
  805996:	0f 84 ea 00 00 00    	je     805a86 <tcp_bind+0x148>
  80599c:	85 db                	test   %ebx,%ebx
  80599e:	0f 84 e6 00 00 00    	je     805a8a <tcp_bind+0x14c>
          ip_addr_isany(ipaddr) ||
  8059a4:	8b 3b                	mov    (%ebx),%edi
  8059a6:	85 ff                	test   %edi,%edi
  8059a8:	0f 84 e0 00 00 00    	je     805a8e <tcp_bind+0x150>
  8059ae:	39 f9                	cmp    %edi,%ecx
  8059b0:	0f 84 dc 00 00 00    	je     805a92 <tcp_bind+0x154>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  8059b6:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8059b9:	85 d2                	test   %edx,%edx
  8059bb:	75 c7                	jne    805984 <tcp_bind+0x46>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  8059bd:	8b 15 7c c2 b3 00    	mov    0xb3c27c,%edx
  8059c3:	eb 35                	jmp    8059fa <tcp_bind+0xbc>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  8059c5:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8059c9:	75 2c                	jne    8059f7 <tcp_bind+0xb9>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8059cb:	85 d2                	test   %edx,%edx
  8059cd:	0f 84 c3 00 00 00    	je     805a96 <tcp_bind+0x158>
  8059d3:	8b 0a                	mov    (%edx),%ecx
  8059d5:	85 c9                	test   %ecx,%ecx
  8059d7:	0f 84 bd 00 00 00    	je     805a9a <tcp_bind+0x15c>
  8059dd:	85 db                	test   %ebx,%ebx
  8059df:	0f 84 b9 00 00 00    	je     805a9e <tcp_bind+0x160>
          ip_addr_isany(ipaddr) ||
  8059e5:	8b 3b                	mov    (%ebx),%edi
  8059e7:	85 ff                	test   %edi,%edi
  8059e9:	0f 84 b3 00 00 00    	je     805aa2 <tcp_bind+0x164>
  8059ef:	39 f9                	cmp    %edi,%ecx
  8059f1:	0f 84 af 00 00 00    	je     805aa6 <tcp_bind+0x168>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  8059f7:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  8059fa:	85 d2                	test   %edx,%edx
  8059fc:	75 c7                	jne    8059c5 <tcp_bind+0x87>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8059fe:	8b 15 8c c2 b3 00    	mov    0xb3c28c,%edx
  805a04:	eb 35                	jmp    805a3b <tcp_bind+0xfd>
    if (cpcb->local_port == port) {
  805a06:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805a0a:	75 2c                	jne    805a38 <tcp_bind+0xfa>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805a0c:	85 d2                	test   %edx,%edx
  805a0e:	0f 84 96 00 00 00    	je     805aaa <tcp_bind+0x16c>
  805a14:	8b 0a                	mov    (%edx),%ecx
  805a16:	85 c9                	test   %ecx,%ecx
  805a18:	0f 84 90 00 00 00    	je     805aae <tcp_bind+0x170>
  805a1e:	85 db                	test   %ebx,%ebx
  805a20:	0f 84 8c 00 00 00    	je     805ab2 <tcp_bind+0x174>
          ip_addr_isany(ipaddr) ||
  805a26:	8b 3b                	mov    (%ebx),%edi
  805a28:	85 ff                	test   %edi,%edi
  805a2a:	0f 84 86 00 00 00    	je     805ab6 <tcp_bind+0x178>
  805a30:	39 f9                	cmp    %edi,%ecx
  805a32:	0f 84 82 00 00 00    	je     805aba <tcp_bind+0x17c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805a38:	8b 52 0c             	mov    0xc(%edx),%edx
  805a3b:	85 d2                	test   %edx,%edx
  805a3d:	75 c7                	jne    805a06 <tcp_bind+0xc8>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805a3f:	8b 15 90 c2 b3 00    	mov    0xb3c290,%edx
  805a45:	eb 0f                	jmp    805a56 <tcp_bind+0x118>
    if (cpcb->local_port == port) {
  805a47:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805a4b:	75 06                	jne    805a53 <tcp_bind+0x115>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805a4d:	8b 0b                	mov    (%ebx),%ecx
  805a4f:	39 0a                	cmp    %ecx,(%edx)
  805a51:	74 6b                	je     805abe <tcp_bind+0x180>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805a53:	8b 52 0c             	mov    0xc(%edx),%edx
  805a56:	85 d2                	test   %edx,%edx
  805a58:	75 ed                	jne    805a47 <tcp_bind+0x109>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  805a5a:	85 db                	test   %ebx,%ebx
  805a5c:	74 09                	je     805a67 <tcp_bind+0x129>
  805a5e:	83 3b 00             	cmpl   $0x0,(%ebx)
  805a61:	74 04                	je     805a67 <tcp_bind+0x129>
    pcb->local_ip = *ipaddr;
  805a63:	8b 13                	mov    (%ebx),%edx
  805a65:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  805a67:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  805a6b:	a1 8c c2 b3 00       	mov    0xb3c28c,%eax
  805a70:	89 46 0c             	mov    %eax,0xc(%esi)
  805a73:	89 35 8c c2 b3 00    	mov    %esi,0xb3c28c
  805a79:	e8 b0 ca ff ff       	call   80252e <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  805a7e:	b0 00                	mov    $0x0,%al
  805a80:	eb 3e                	jmp    805ac0 <tcp_bind+0x182>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805a82:	b0 f5                	mov    $0xf5,%al
  805a84:	eb 3a                	jmp    805ac0 <tcp_bind+0x182>
  805a86:	b0 f5                	mov    $0xf5,%al
  805a88:	eb 36                	jmp    805ac0 <tcp_bind+0x182>
  805a8a:	b0 f5                	mov    $0xf5,%al
  805a8c:	eb 32                	jmp    805ac0 <tcp_bind+0x182>
  805a8e:	b0 f5                	mov    $0xf5,%al
  805a90:	eb 2e                	jmp    805ac0 <tcp_bind+0x182>
  805a92:	b0 f5                	mov    $0xf5,%al
  805a94:	eb 2a                	jmp    805ac0 <tcp_bind+0x182>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805a96:	b0 f5                	mov    $0xf5,%al
  805a98:	eb 26                	jmp    805ac0 <tcp_bind+0x182>
  805a9a:	b0 f5                	mov    $0xf5,%al
  805a9c:	eb 22                	jmp    805ac0 <tcp_bind+0x182>
  805a9e:	b0 f5                	mov    $0xf5,%al
  805aa0:	eb 1e                	jmp    805ac0 <tcp_bind+0x182>
  805aa2:	b0 f5                	mov    $0xf5,%al
  805aa4:	eb 1a                	jmp    805ac0 <tcp_bind+0x182>
  805aa6:	b0 f5                	mov    $0xf5,%al
  805aa8:	eb 16                	jmp    805ac0 <tcp_bind+0x182>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805aaa:	b0 f5                	mov    $0xf5,%al
  805aac:	eb 12                	jmp    805ac0 <tcp_bind+0x182>
  805aae:	b0 f5                	mov    $0xf5,%al
  805ab0:	eb 0e                	jmp    805ac0 <tcp_bind+0x182>
  805ab2:	b0 f5                	mov    $0xf5,%al
  805ab4:	eb 0a                	jmp    805ac0 <tcp_bind+0x182>
  805ab6:	b0 f5                	mov    $0xf5,%al
  805ab8:	eb 06                	jmp    805ac0 <tcp_bind+0x182>
  805aba:	b0 f5                	mov    $0xf5,%al
  805abc:	eb 02                	jmp    805ac0 <tcp_bind+0x182>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805abe:	b0 f5                	mov    $0xf5,%al
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  805ac0:	83 c4 1c             	add    $0x1c,%esp
  805ac3:	5b                   	pop    %ebx
  805ac4:	5e                   	pop    %esi
  805ac5:	5f                   	pop    %edi
  805ac6:	5d                   	pop    %ebp
  805ac7:	c3                   	ret    

00805ac8 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  805ac8:	55                   	push   %ebp
  805ac9:	89 e5                	mov    %esp,%ebp
  805acb:	56                   	push   %esi
  805acc:	53                   	push   %ebx
  805acd:	83 ec 10             	sub    $0x10,%esp
  805ad0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805ad3:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805ad7:	74 1c                	je     805af5 <tcp_listen_with_backlog+0x2d>
  805ad9:	c7 44 24 08 ec 27 81 	movl   $0x8127ec,0x8(%esp)
  805ae0:	00 
  805ae1:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  805ae8:	00 
  805ae9:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  805af0:	e8 8b 93 00 00       	call   80ee80 <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805af5:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  805afc:	e8 65 ee ff ff       	call   804966 <memp_malloc>
  805b01:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805b03:	85 c0                	test   %eax,%eax
  805b05:	0f 84 af 00 00 00    	je     805bba <tcp_listen_with_backlog+0xf2>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  805b0b:	8b 43 18             	mov    0x18(%ebx),%eax
  805b0e:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805b11:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805b14:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805b18:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  805b1f:	8b 43 08             	mov    0x8(%ebx),%eax
  805b22:	83 c8 02             	or     $0x2,%eax
  805b25:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  805b29:	8a 43 0b             	mov    0xb(%ebx),%al
  805b2c:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805b2f:	8a 43 0a             	mov    0xa(%ebx),%al
  805b32:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  805b35:	85 db                	test   %ebx,%ebx
  805b37:	74 04                	je     805b3d <tcp_listen_with_backlog+0x75>
  805b39:	8b 03                	mov    (%ebx),%eax
  805b3b:	eb 05                	jmp    805b42 <tcp_listen_with_backlog+0x7a>
  805b3d:	b8 00 00 00 00       	mov    $0x0,%eax
  805b42:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  805b44:	8b 15 8c c2 b3 00    	mov    0xb3c28c,%edx
  805b4a:	39 da                	cmp    %ebx,%edx
  805b4c:	75 0a                	jne    805b58 <tcp_listen_with_backlog+0x90>
  805b4e:	8b 42 0c             	mov    0xc(%edx),%eax
  805b51:	a3 8c c2 b3 00       	mov    %eax,0xb3c28c
  805b56:	eb 31                	jmp    805b89 <tcp_listen_with_backlog+0xc1>
  805b58:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  805b5e:	eb 1f                	jmp    805b7f <tcp_listen_with_backlog+0xb7>
  805b60:	8b 42 0c             	mov    0xc(%edx),%eax
  805b63:	85 c0                	test   %eax,%eax
  805b65:	74 12                	je     805b79 <tcp_listen_with_backlog+0xb1>
  805b67:	39 c3                	cmp    %eax,%ebx
  805b69:	75 12                	jne    805b7d <tcp_listen_with_backlog+0xb5>
  805b6b:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  805b71:	8b 43 0c             	mov    0xc(%ebx),%eax
  805b74:	89 42 0c             	mov    %eax,0xc(%edx)
  805b77:	eb 10                	jmp    805b89 <tcp_listen_with_backlog+0xc1>
  805b79:	89 c2                	mov    %eax,%edx
  805b7b:	eb 02                	jmp    805b7f <tcp_listen_with_backlog+0xb7>
  805b7d:	89 c2                	mov    %eax,%edx
  805b7f:	85 d2                	test   %edx,%edx
  805b81:	75 dd                	jne    805b60 <tcp_listen_with_backlog+0x98>
  805b83:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  805b89:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805b90:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805b94:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  805b9b:	e8 26 ee ff ff       	call   8049c6 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  805ba0:	c7 46 20 d4 58 80 00 	movl   $0x8058d4,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805ba7:	a1 84 c2 b3 00       	mov    0xb3c284,%eax
  805bac:	89 46 0c             	mov    %eax,0xc(%esi)
  805baf:	89 35 84 c2 b3 00    	mov    %esi,0xb3c284
  805bb5:	e8 74 c9 ff ff       	call   80252e <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
}
  805bba:	89 f0                	mov    %esi,%eax
  805bbc:	83 c4 10             	add    $0x10,%esp
  805bbf:	5b                   	pop    %ebx
  805bc0:	5e                   	pop    %esi
  805bc1:	5d                   	pop    %ebp
  805bc2:	c3                   	ret    

00805bc3 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  805bc3:	55                   	push   %ebp
  805bc4:	89 e5                	mov    %esp,%ebp
  805bc6:	56                   	push   %esi
  805bc7:	53                   	push   %ebx
  805bc8:	83 ec 10             	sub    $0x10,%esp
  805bcb:	8b 45 08             	mov    0x8(%ebp),%eax
  805bce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805bd1:	8b 50 28             	mov    0x28(%eax),%edx
  805bd4:	0f b7 f1             	movzwl %cx,%esi
  805bd7:	0f b7 da             	movzwl %dx,%ebx
  805bda:	01 f3                	add    %esi,%ebx
  805bdc:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  805be2:	76 0e                	jbe    805bf2 <tcp_recved+0x2f>
    pcb->rcv_wnd = TCP_WND;
  805be4:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805bea:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  805bf0:	eb 10                	jmp    805c02 <tcp_recved+0x3f>
  } else {
    pcb->rcv_wnd += len;
  805bf2:	01 ca                	add    %ecx,%edx
  805bf4:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805bf8:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805bfc:	72 04                	jb     805c02 <tcp_recved+0x3f>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805bfe:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  805c02:	8a 50 20             	mov    0x20(%eax),%dl
  805c05:	f6 c2 03             	test   $0x3,%dl
  805c08:	75 20                	jne    805c2a <tcp_recved+0x67>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  805c0a:	f6 c2 01             	test   $0x1,%dl
  805c0d:	74 13                	je     805c22 <tcp_recved+0x5f>
  805c0f:	83 e2 fe             	and    $0xfffffffe,%edx
  805c12:	83 ca 02             	or     $0x2,%edx
  805c15:	88 50 20             	mov    %dl,0x20(%eax)
  805c18:	89 04 24             	mov    %eax,(%esp)
  805c1b:	e8 1e 2a 00 00       	call   80863e <tcp_output>
  805c20:	eb 23                	jmp    805c45 <tcp_recved+0x82>
  805c22:	83 ca 01             	or     $0x1,%edx
  805c25:	88 50 20             	mov    %dl,0x20(%eax)
  805c28:	eb 1b                	jmp    805c45 <tcp_recved+0x82>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805c2a:	f6 c2 01             	test   $0x1,%dl
  805c2d:	74 16                	je     805c45 <tcp_recved+0x82>
  805c2f:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805c35:	76 0e                	jbe    805c45 <tcp_recved+0x82>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  805c37:	83 ca 02             	or     $0x2,%edx
  805c3a:	88 50 20             	mov    %dl,0x20(%eax)
  805c3d:	89 04 24             	mov    %eax,(%esp)
  805c40:	e8 f9 29 00 00       	call   80863e <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  805c45:	83 c4 10             	add    $0x10,%esp
  805c48:	5b                   	pop    %ebx
  805c49:	5e                   	pop    %esi
  805c4a:	5d                   	pop    %ebp
  805c4b:	c3                   	ret    

00805c4c <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805c4c:	55                   	push   %ebp
  805c4d:	89 e5                	mov    %esp,%ebp
  805c4f:	53                   	push   %ebx
  805c50:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805c53:	8b 1d 7c c2 b3 00    	mov    0xb3c27c,%ebx
  805c59:	eb 60                	jmp    805cbb <tcp_fasttmr+0x6f>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  805c5b:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805c61:	85 c0                	test   %eax,%eax
  805c63:	74 3a                	je     805c9f <tcp_fasttmr+0x53>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805c65:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805c6b:	85 d2                	test   %edx,%edx
  805c6d:	74 1e                	je     805c8d <tcp_fasttmr+0x41>
  805c6f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  805c76:	00 
  805c77:	89 44 24 08          	mov    %eax,0x8(%esp)
  805c7b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805c7f:	8b 43 18             	mov    0x18(%ebx),%eax
  805c82:	89 04 24             	mov    %eax,(%esp)
  805c85:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805c87:	84 c0                	test   %al,%al
  805c89:	75 14                	jne    805c9f <tcp_fasttmr+0x53>
  805c8b:	eb 08                	jmp    805c95 <tcp_fasttmr+0x49>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805c8d:	89 04 24             	mov    %eax,(%esp)
  805c90:	e8 bc f0 ff ff       	call   804d51 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805c95:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805c9c:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805c9f:	8a 43 20             	mov    0x20(%ebx),%al
  805ca2:	a8 01                	test   $0x1,%al
  805ca4:	74 12                	je     805cb8 <tcp_fasttmr+0x6c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805ca6:	83 c8 02             	or     $0x2,%eax
  805ca9:	88 43 20             	mov    %al,0x20(%ebx)
  805cac:	89 1c 24             	mov    %ebx,(%esp)
  805caf:	e8 8a 29 00 00       	call   80863e <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805cb4:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805cb8:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805cbb:	85 db                	test   %ebx,%ebx
  805cbd:	75 9c                	jne    805c5b <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  805cbf:	83 c4 14             	add    $0x14,%esp
  805cc2:	5b                   	pop    %ebx
  805cc3:	5d                   	pop    %ebp
  805cc4:	c3                   	ret    

00805cc5 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805cc5:	55                   	push   %ebp
  805cc6:	89 e5                	mov    %esp,%ebp
  805cc8:	56                   	push   %esi
  805cc9:	53                   	push   %ebx
  805cca:	83 ec 10             	sub    $0x10,%esp
  805ccd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  805cd0:	85 db                	test   %ebx,%ebx
  805cd2:	74 2a                	je     805cfe <tcp_seg_free+0x39>
    if (seg->p != NULL) {
  805cd4:	8b 43 04             	mov    0x4(%ebx),%eax
  805cd7:	85 c0                	test   %eax,%eax
  805cd9:	74 0c                	je     805ce7 <tcp_seg_free+0x22>
      count = pbuf_free(seg->p);
  805cdb:	89 04 24             	mov    %eax,(%esp)
  805cde:	e8 6e f0 ff ff       	call   804d51 <pbuf_free>
  805ce3:	89 c6                	mov    %eax,%esi
  805ce5:	eb 05                	jmp    805cec <tcp_seg_free+0x27>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805ce7:	be 00 00 00 00       	mov    $0x0,%esi
      count = pbuf_free(seg->p);
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805cec:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805cf0:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805cf7:	e8 ca ec ff ff       	call   8049c6 <memp_free>
  805cfc:	eb 05                	jmp    805d03 <tcp_seg_free+0x3e>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805cfe:	be 00 00 00 00       	mov    $0x0,%esi
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  }
  return count;
}
  805d03:	89 f0                	mov    %esi,%eax
  805d05:	83 c4 10             	add    $0x10,%esp
  805d08:	5b                   	pop    %ebx
  805d09:	5e                   	pop    %esi
  805d0a:	5d                   	pop    %ebp
  805d0b:	c3                   	ret    

00805d0c <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  805d0c:	55                   	push   %ebp
  805d0d:	89 e5                	mov    %esp,%ebp
  805d0f:	56                   	push   %esi
  805d10:	53                   	push   %ebx
  805d11:	83 ec 10             	sub    $0x10,%esp
  805d14:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  805d17:	be 00 00 00 00       	mov    $0x0,%esi
  struct tcp_seg *next;
  while (seg != NULL) {
  805d1c:	eb 0e                	jmp    805d2c <tcp_segs_free+0x20>
    next = seg->next;
  805d1e:	8b 18                	mov    (%eax),%ebx
    count += tcp_seg_free(seg);
  805d20:	89 04 24             	mov    %eax,(%esp)
  805d23:	e8 9d ff ff ff       	call   805cc5 <tcp_seg_free>
  805d28:	01 c6                	add    %eax,%esi
    seg = next;
  805d2a:	89 d8                	mov    %ebx,%eax
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  805d2c:	85 c0                	test   %eax,%eax
  805d2e:	75 ee                	jne    805d1e <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  805d30:	89 f0                	mov    %esi,%eax
  805d32:	83 c4 10             	add    $0x10,%esp
  805d35:	5b                   	pop    %ebx
  805d36:	5e                   	pop    %esi
  805d37:	5d                   	pop    %ebp
  805d38:	c3                   	ret    

00805d39 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  805d39:	55                   	push   %ebp
  805d3a:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  805d3c:	8b 55 0c             	mov    0xc(%ebp),%edx
  805d3f:	8b 45 08             	mov    0x8(%ebp),%eax
  805d42:	88 50 14             	mov    %dl,0x14(%eax)
}
  805d45:	5d                   	pop    %ebp
  805d46:	c3                   	ret    

00805d47 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805d47:	55                   	push   %ebp
  805d48:	89 e5                	mov    %esp,%ebp
  805d4a:	53                   	push   %ebx
  805d4b:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805d4e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805d55:	e8 0c ec ff ff       	call   804966 <memp_malloc>
  805d5a:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805d5c:	85 c0                	test   %eax,%eax
  805d5e:	74 22                	je     805d82 <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805d60:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  805d67:	00 
  805d68:	8b 45 08             	mov    0x8(%ebp),%eax
  805d6b:	89 44 24 04          	mov    %eax,0x4(%esp)
  805d6f:	89 1c 24             	mov    %ebx,(%esp)
  805d72:	e8 8f 99 00 00       	call   80f706 <memcpy>
  pbuf_ref(cseg->p);
  805d77:	8b 43 04             	mov    0x4(%ebx),%eax
  805d7a:	89 04 24             	mov    %eax,(%esp)
  805d7d:	e8 69 f4 ff ff       	call   8051eb <pbuf_ref>
  return cseg;
}
  805d82:	89 d8                	mov    %ebx,%eax
  805d84:	83 c4 14             	add    $0x14,%esp
  805d87:	5b                   	pop    %ebx
  805d88:	5d                   	pop    %ebp
  805d89:	c3                   	ret    

00805d8a <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805d8a:	55                   	push   %ebp
  805d8b:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805d8d:	8b 55 0c             	mov    0xc(%ebp),%edx
  805d90:	8b 45 08             	mov    0x8(%ebp),%eax
  805d93:	89 50 18             	mov    %edx,0x18(%eax)
}
  805d96:	5d                   	pop    %ebp
  805d97:	c3                   	ret    

00805d98 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805d98:	55                   	push   %ebp
  805d99:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805d9b:	8b 55 0c             	mov    0xc(%ebp),%edx
  805d9e:	8b 45 08             	mov    0x8(%ebp),%eax
  805da1:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805da7:	5d                   	pop    %ebp
  805da8:	c3                   	ret    

00805da9 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805da9:	55                   	push   %ebp
  805daa:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805dac:	8b 55 0c             	mov    0xc(%ebp),%edx
  805daf:	8b 45 08             	mov    0x8(%ebp),%eax
  805db2:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805db8:	5d                   	pop    %ebp
  805db9:	c3                   	ret    

00805dba <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805dba:	55                   	push   %ebp
  805dbb:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805dbd:	8b 55 0c             	mov    0xc(%ebp),%edx
  805dc0:	8b 45 08             	mov    0x8(%ebp),%eax
  805dc3:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805dc9:	5d                   	pop    %ebp
  805dca:	c3                   	ret    

00805dcb <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805dcb:	55                   	push   %ebp
  805dcc:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805dce:	8b 55 0c             	mov    0xc(%ebp),%edx
  805dd1:	8b 45 08             	mov    0x8(%ebp),%eax
  805dd4:	89 50 20             	mov    %edx,0x20(%eax)
}
  805dd7:	5d                   	pop    %ebp
  805dd8:	c3                   	ret    

00805dd9 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805dd9:	55                   	push   %ebp
  805dda:	89 e5                	mov    %esp,%ebp
  805ddc:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805ddf:	8b 55 0c             	mov    0xc(%ebp),%edx
  805de2:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805de8:	8b 55 10             	mov    0x10(%ebp),%edx
  805deb:	88 50 31             	mov    %dl,0x31(%eax)
}
  805dee:	5d                   	pop    %ebp
  805def:	c3                   	ret    

00805df0 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805df0:	55                   	push   %ebp
  805df1:	89 e5                	mov    %esp,%ebp
  805df3:	53                   	push   %ebx
  805df4:	83 ec 14             	sub    $0x14,%esp
  805df7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805dfa:	8b 43 10             	mov    0x10(%ebx),%eax
  805dfd:	85 c0                	test   %eax,%eax
  805dff:	74 62                	je     805e63 <tcp_pcb_purge+0x73>
  805e01:	83 f8 0a             	cmp    $0xa,%eax
  805e04:	74 5d                	je     805e63 <tcp_pcb_purge+0x73>
     pcb->state != TIME_WAIT &&
  805e06:	83 f8 01             	cmp    $0x1,%eax
  805e09:	74 58                	je     805e63 <tcp_pcb_purge+0x73>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  805e0b:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805e11:	85 c0                	test   %eax,%eax
  805e13:	74 12                	je     805e27 <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  805e15:	89 04 24             	mov    %eax,(%esp)
  805e18:	e8 34 ef ff ff       	call   804d51 <pbuf_free>
      pcb->refused_data = NULL;
  805e1d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805e24:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  805e27:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  805e2d:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805e30:	89 04 24             	mov    %eax,(%esp)
  805e33:	e8 d4 fe ff ff       	call   805d0c <tcp_segs_free>
    pcb->ooseq = NULL;
  805e38:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  805e3f:	8b 43 74             	mov    0x74(%ebx),%eax
  805e42:	89 04 24             	mov    %eax,(%esp)
  805e45:	e8 c2 fe ff ff       	call   805d0c <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805e4a:	8b 43 78             	mov    0x78(%ebx),%eax
  805e4d:	89 04 24             	mov    %eax,(%esp)
  805e50:	e8 b7 fe ff ff       	call   805d0c <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805e55:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805e5c:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  805e63:	83 c4 14             	add    $0x14,%esp
  805e66:	5b                   	pop    %ebx
  805e67:	5d                   	pop    %ebp
  805e68:	c3                   	ret    

00805e69 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805e69:	55                   	push   %ebp
  805e6a:	89 e5                	mov    %esp,%ebp
  805e6c:	53                   	push   %ebx
  805e6d:	83 ec 14             	sub    $0x14,%esp
  805e70:	8b 45 08             	mov    0x8(%ebp),%eax
  805e73:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805e76:	8b 10                	mov    (%eax),%edx
  805e78:	39 da                	cmp    %ebx,%edx
  805e7a:	75 07                	jne    805e83 <tcp_pcb_remove+0x1a>
  805e7c:	8b 52 0c             	mov    0xc(%edx),%edx
  805e7f:	89 10                	mov    %edx,(%eax)
  805e81:	eb 31                	jmp    805eb4 <tcp_pcb_remove+0x4b>
  805e83:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  805e89:	eb 1f                	jmp    805eaa <tcp_pcb_remove+0x41>
  805e8b:	8b 42 0c             	mov    0xc(%edx),%eax
  805e8e:	85 c0                	test   %eax,%eax
  805e90:	74 12                	je     805ea4 <tcp_pcb_remove+0x3b>
  805e92:	39 c3                	cmp    %eax,%ebx
  805e94:	75 12                	jne    805ea8 <tcp_pcb_remove+0x3f>
  805e96:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  805e9c:	8b 43 0c             	mov    0xc(%ebx),%eax
  805e9f:	89 42 0c             	mov    %eax,0xc(%edx)
  805ea2:	eb 10                	jmp    805eb4 <tcp_pcb_remove+0x4b>
  805ea4:	89 c2                	mov    %eax,%edx
  805ea6:	eb 02                	jmp    805eaa <tcp_pcb_remove+0x41>
  805ea8:	89 c2                	mov    %eax,%edx
  805eaa:	85 d2                	test   %edx,%edx
  805eac:	75 dd                	jne    805e8b <tcp_pcb_remove+0x22>
  805eae:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  805eb4:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805ebb:	89 1c 24             	mov    %ebx,(%esp)
  805ebe:	e8 2d ff ff ff       	call   805df0 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805ec3:	8b 43 10             	mov    0x10(%ebx),%eax
  805ec6:	83 f8 0a             	cmp    $0xa,%eax
  805ec9:	74 24                	je     805eef <tcp_pcb_remove+0x86>
  805ecb:	83 f8 01             	cmp    $0x1,%eax
  805ece:	0f 84 81 00 00 00    	je     805f55 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805ed4:	8a 43 20             	mov    0x20(%ebx),%al

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  805ed7:	a8 01                	test   $0x1,%al
  805ed9:	74 14                	je     805eef <tcp_pcb_remove+0x86>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  805edb:	83 c8 02             	or     $0x2,%eax
  805ede:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805ee1:	89 1c 24             	mov    %ebx,(%esp)
  805ee4:	e8 55 27 00 00       	call   80863e <tcp_output>
  }

  if (pcb->state != LISTEN) {
  805ee9:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805eed:	74 66                	je     805f55 <tcp_pcb_remove+0xec>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805eef:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805ef3:	74 1c                	je     805f11 <tcp_pcb_remove+0xa8>
  805ef5:	c7 44 24 08 b6 29 81 	movl   $0x8129b6,0x8(%esp)
  805efc:	00 
  805efd:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  805f04:	00 
  805f05:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  805f0c:	e8 6f 8f 00 00       	call   80ee80 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805f11:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805f15:	74 1c                	je     805f33 <tcp_pcb_remove+0xca>
  805f17:	c7 44 24 08 ce 29 81 	movl   $0x8129ce,0x8(%esp)
  805f1e:	00 
  805f1f:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  805f26:	00 
  805f27:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  805f2e:	e8 4d 8f 00 00       	call   80ee80 <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805f33:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  805f37:	74 1c                	je     805f55 <tcp_pcb_remove+0xec>
  805f39:	c7 44 24 08 e7 29 81 	movl   $0x8129e7,0x8(%esp)
  805f40:	00 
  805f41:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  805f48:	00 
  805f49:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  805f50:	e8 2b 8f 00 00       	call   80ee80 <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805f55:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805f5c:	83 c4 14             	add    $0x14,%esp
  805f5f:	5b                   	pop    %ebx
  805f60:	5d                   	pop    %ebp
  805f61:	c3                   	ret    

00805f62 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  805f62:	55                   	push   %ebp
  805f63:	89 e5                	mov    %esp,%ebp
  805f65:	57                   	push   %edi
  805f66:	56                   	push   %esi
  805f67:	53                   	push   %ebx
  805f68:	83 ec 4c             	sub    $0x4c,%esp
  805f6b:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  805f6e:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805f72:	75 25                	jne    805f99 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805f74:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805f78:	c7 04 24 90 c2 b3 00 	movl   $0xb3c290,(%esp)
  805f7f:	e8 e5 fe ff ff       	call   805e69 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805f84:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805f88:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  805f8f:	e8 32 ea ff ff       	call   8049c6 <memp_free>
  805f94:	e9 d6 00 00 00       	jmp    80606f <tcp_abort+0x10d>
  } else {
    seqno = pcb->snd_nxt;
  805f99:	8b 43 54             	mov    0x54(%ebx),%eax
  805f9c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ackno = pcb->rcv_nxt;
  805f9f:	8b 43 24             	mov    0x24(%ebx),%eax
  805fa2:	89 45 cc             	mov    %eax,-0x34(%ebp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805fa5:	85 db                	test   %ebx,%ebx
  805fa7:	74 04                	je     805fad <tcp_abort+0x4b>
  805fa9:	8b 03                	mov    (%ebx),%eax
  805fab:	eb 05                	jmp    805fb2 <tcp_abort+0x50>
  805fad:	b8 00 00 00 00       	mov    $0x0,%eax
  805fb2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805fb5:	83 fb fc             	cmp    $0xfffffffc,%ebx
  805fb8:	74 05                	je     805fbf <tcp_abort+0x5d>
  805fba:	8b 43 04             	mov    0x4(%ebx),%eax
  805fbd:	eb 05                	jmp    805fc4 <tcp_abort+0x62>
  805fbf:	b8 00 00 00 00       	mov    $0x0,%eax
  805fc4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805fc7:	8b 7b 1c             	mov    0x1c(%ebx),%edi
    remote_port = pcb->remote_port;
  805fca:	66 8b 73 1e          	mov    0x1e(%ebx),%si
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  805fce:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805fd4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  805fd7:	8b 43 18             	mov    0x18(%ebx),%eax
  805fda:	89 45 c8             	mov    %eax,-0x38(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805fdd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805fe1:	c7 04 24 7c c2 b3 00 	movl   $0xb3c27c,(%esp)
  805fe8:	e8 7c fe ff ff       	call   805e69 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805fed:	8b 43 78             	mov    0x78(%ebx),%eax
  805ff0:	85 c0                	test   %eax,%eax
  805ff2:	74 08                	je     805ffc <tcp_abort+0x9a>
      tcp_segs_free(pcb->unacked);
  805ff4:	89 04 24             	mov    %eax,(%esp)
  805ff7:	e8 10 fd ff ff       	call   805d0c <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  805ffc:	8b 43 74             	mov    0x74(%ebx),%eax
  805fff:	85 c0                	test   %eax,%eax
  806001:	74 08                	je     80600b <tcp_abort+0xa9>
      tcp_segs_free(pcb->unsent);
  806003:	89 04 24             	mov    %eax,(%esp)
  806006:	e8 01 fd ff ff       	call   805d0c <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80600b:	8b 43 7c             	mov    0x7c(%ebx),%eax
  80600e:	85 c0                	test   %eax,%eax
  806010:	74 08                	je     80601a <tcp_abort+0xb8>
      tcp_segs_free(pcb->ooseq);
  806012:	89 04 24             	mov    %eax,(%esp)
  806015:	e8 f2 fc ff ff       	call   805d0c <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80601a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80601e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806025:	e8 9c e9 ff ff       	call   8049c6 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80602a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80602e:	74 11                	je     806041 <tcp_abort+0xdf>
  806030:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  806037:	ff 
  806038:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80603b:	89 04 24             	mov    %eax,(%esp)
  80603e:	ff 55 d4             	call   *-0x2c(%ebp)
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  806041:	0f b7 f6             	movzwl %si,%esi
  806044:	89 74 24 14          	mov    %esi,0x14(%esp)
  806048:	0f b7 ff             	movzwl %di,%edi
  80604b:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80604f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  806052:	89 44 24 0c          	mov    %eax,0xc(%esp)
  806056:	8d 45 e0             	lea    -0x20(%ebp),%eax
  806059:	89 44 24 08          	mov    %eax,0x8(%esp)
  80605d:	8b 45 cc             	mov    -0x34(%ebp),%eax
  806060:	89 44 24 04          	mov    %eax,0x4(%esp)
  806064:	8b 45 d0             	mov    -0x30(%ebp),%eax
  806067:	89 04 24             	mov    %eax,(%esp)
  80606a:	e8 59 2a 00 00       	call   808ac8 <tcp_rst>
  }
}
  80606f:	83 c4 4c             	add    $0x4c,%esp
  806072:	5b                   	pop    %ebx
  806073:	5e                   	pop    %esi
  806074:	5f                   	pop    %edi
  806075:	5d                   	pop    %ebp
  806076:	c3                   	ret    

00806077 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  806077:	55                   	push   %ebp
  806078:	89 e5                	mov    %esp,%ebp
  80607a:	57                   	push   %edi
  80607b:	56                   	push   %esi
  80607c:	53                   	push   %ebx
  80607d:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  806080:	ff 05 80 c2 b3 00    	incl   0xb3c280

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  806086:	8b 1d 7c c2 b3 00    	mov    0xb3c27c,%ebx
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  80608c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  806090:	bf 00 00 00 00       	mov    $0x0,%edi
  806095:	e9 3b 03 00 00       	jmp    8063d5 <tcp_slowtmr+0x35e>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80609a:	8b 43 10             	mov    0x10(%ebx),%eax
  80609d:	85 c0                	test   %eax,%eax
  80609f:	75 1c                	jne    8060bd <tcp_slowtmr+0x46>
  8060a1:	c7 44 24 08 10 28 81 	movl   $0x812810,0x8(%esp)
  8060a8:	00 
  8060a9:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  8060b0:	00 
  8060b1:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  8060b8:	e8 c3 8d 00 00       	call   80ee80 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  8060bd:	83 f8 01             	cmp    $0x1,%eax
  8060c0:	75 1c                	jne    8060de <tcp_slowtmr+0x67>
  8060c2:	c7 44 24 08 3c 28 81 	movl   $0x81283c,0x8(%esp)
  8060c9:	00 
  8060ca:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  8060d1:	00 
  8060d2:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  8060d9:	e8 a2 8d 00 00       	call   80ee80 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  8060de:	83 f8 0a             	cmp    $0xa,%eax
  8060e1:	75 1c                	jne    8060ff <tcp_slowtmr+0x88>
  8060e3:	c7 44 24 08 68 28 81 	movl   $0x812868,0x8(%esp)
  8060ea:	00 
  8060eb:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  8060f2:	00 
  8060f3:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  8060fa:	e8 81 8d 00 00       	call   80ee80 <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  8060ff:	83 f8 02             	cmp    $0x2,%eax
  806102:	75 0a                	jne    80610e <tcp_slowtmr+0x97>
  806104:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  806108:	0f 84 13 01 00 00    	je     806221 <tcp_slowtmr+0x1aa>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80610e:	8a 53 46             	mov    0x46(%ebx),%dl
  806111:	80 fa 0c             	cmp    $0xc,%dl
  806114:	0f 84 d0 00 00 00    	je     8061ea <tcp_slowtmr+0x173>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80611a:	8a 8b a4 00 00 00    	mov    0xa4(%ebx),%cl
  806120:	84 c9                	test   %cl,%cl
  806122:	74 47                	je     80616b <tcp_slowtmr+0xf4>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  806124:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  80612a:	40                   	inc    %eax
  80612b:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  806131:	0f b6 d1             	movzbl %cl,%edx
  806134:	0f b6 92 1f 2a 81 00 	movzbl 0x812a1f(%edx),%edx
  80613b:	39 d0                	cmp    %edx,%eax
  80613d:	0f 82 ae 00 00 00    	jb     8061f1 <tcp_slowtmr+0x17a>
          pcb->persist_cnt = 0;
  806143:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  80614a:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80614d:	80 f9 06             	cmp    $0x6,%cl
  806150:	77 07                	ja     806159 <tcp_slowtmr+0xe2>
            pcb->persist_backoff++;
  806152:	41                   	inc    %ecx
  806153:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  806159:	89 1c 24             	mov    %ebx,(%esp)
  80615c:	e8 b5 2c 00 00       	call   808e16 <tcp_zero_window_probe>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  806161:	be 00 00 00 00       	mov    $0x0,%esi
  806166:	e9 99 00 00 00       	jmp    806204 <tcp_slowtmr+0x18d>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80616b:	66 8b 4b 32          	mov    0x32(%ebx),%cx
  80616f:	66 85 c9             	test   %cx,%cx
  806172:	78 05                	js     806179 <tcp_slowtmr+0x102>
          ++pcb->rtime;
  806174:	41                   	inc    %ecx
  806175:	66 89 4b 32          	mov    %cx,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  806179:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80617d:	74 79                	je     8061f8 <tcp_slowtmr+0x181>
  80617f:	8b 4b 44             	mov    0x44(%ebx),%ecx
  806182:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  806186:	7c 77                	jl     8061ff <tcp_slowtmr+0x188>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  806188:	83 f8 02             	cmp    $0x2,%eax
  80618b:	74 1e                	je     8061ab <tcp_slowtmr+0x134>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80618d:	8b 43 40             	mov    0x40(%ebx),%eax
  806190:	66 c1 f8 03          	sar    $0x3,%ax
  806194:	98                   	cwtl   
  806195:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  806199:	01 c8                	add    %ecx,%eax
  80619b:	0f b6 d2             	movzbl %dl,%edx
  80619e:	0f b6 8a 27 2a 81 00 	movzbl 0x812a27(%edx),%ecx
  8061a5:	d3 e0                	shl    %cl,%eax
  8061a7:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  8061ab:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  8061b1:	8b 53 5c             	mov    0x5c(%ebx),%edx
  8061b4:	66 8b 43 4e          	mov    0x4e(%ebx),%ax
  8061b8:	66 39 d0             	cmp    %dx,%ax
  8061bb:	76 02                	jbe    8061bf <tcp_slowtmr+0x148>
  8061bd:	89 d0                	mov    %edx,%eax
          pcb->ssthresh = eff_wnd >> 1;
  8061bf:	89 c2                	mov    %eax,%edx
  8061c1:	66 d1 ea             	shr    %dx
  8061c4:	66 89 53 50          	mov    %dx,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  8061c8:	8b 43 34             	mov    0x34(%ebx),%eax
  8061cb:	66 39 c2             	cmp    %ax,%dx
  8061ce:	73 07                	jae    8061d7 <tcp_slowtmr+0x160>
            pcb->ssthresh = pcb->mss * 2;
  8061d0:	8d 14 00             	lea    (%eax,%eax,1),%edx
  8061d3:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  8061d7:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  8061db:	89 1c 24             	mov    %ebx,(%esp)
  8061de:	e8 40 2a 00 00       	call   808c23 <tcp_rexmit_rto>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  8061e3:	be 00 00 00 00       	mov    $0x0,%esi
  8061e8:	eb 1a                	jmp    806204 <tcp_slowtmr+0x18d>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
      ++pcb_remove;
  8061ea:	be 01 00 00 00       	mov    $0x1,%esi
  8061ef:	eb 13                	jmp    806204 <tcp_slowtmr+0x18d>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  8061f1:	be 00 00 00 00       	mov    $0x0,%esi
  8061f6:	eb 0c                	jmp    806204 <tcp_slowtmr+0x18d>
  8061f8:	be 00 00 00 00       	mov    $0x0,%esi
  8061fd:	eb 05                	jmp    806204 <tcp_slowtmr+0x18d>
  8061ff:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  806204:	8b 43 10             	mov    0x10(%ebx),%eax
  806207:	83 f8 06             	cmp    $0x6,%eax
  80620a:	75 1a                	jne    806226 <tcp_slowtmr+0x1af>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80620c:	8b 15 80 c2 b3 00    	mov    0xb3c280,%edx
  806212:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  806215:	83 fa 29             	cmp    $0x29,%edx
  806218:	89 f2                	mov    %esi,%edx
  80621a:	80 da ff             	sbb    $0xff,%dl
  80621d:	89 d6                	mov    %edx,%esi
  80621f:	eb 05                	jmp    806226 <tcp_slowtmr+0x1af>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
  806221:	be 01 00 00 00       	mov    $0x1,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  806226:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  80622a:	74 6f                	je     80629b <tcp_slowtmr+0x224>
  80622c:	83 f8 04             	cmp    $0x4,%eax
  80622f:	74 05                	je     806236 <tcp_slowtmr+0x1bf>
       ((pcb->state == ESTABLISHED) || 
  806231:	83 f8 07             	cmp    $0x7,%eax
  806234:	75 65                	jne    80629b <tcp_slowtmr+0x224>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  806236:	a1 80 c2 b3 00       	mov    0xb3c280,%eax
  80623b:	2b 43 2c             	sub    0x2c(%ebx),%eax
  80623e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  806241:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
  806247:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  80624d:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806252:	f7 e2                	mul    %edx
  806254:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  806257:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80625a:	76 0a                	jbe    806266 <tcp_slowtmr+0x1ef>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80625c:	89 1c 24             	mov    %ebx,(%esp)
  80625f:	e8 fe fc ff ff       	call   805f62 <tcp_abort>
  806264:	eb 35                	jmp    80629b <tcp_slowtmr+0x224>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  806266:	0f b6 83 a5 00 00 00 	movzbl 0xa5(%ebx),%eax
  80626d:	8d 14 c0             	lea    (%eax,%eax,8),%edx
  806270:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  806273:	8d 14 90             	lea    (%eax,%edx,4),%edx
  806276:	c1 e2 05             	shl    $0x5,%edx
  806279:	29 c2                	sub    %eax,%edx
  80627b:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
              / TCP_SLOW_INTERVAL)
  80627e:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806283:	f7 e2                	mul    %edx
  806285:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  806288:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80628b:	76 0e                	jbe    80629b <tcp_slowtmr+0x224>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80628d:	89 1c 24             	mov    %ebx,(%esp)
  806290:	e8 2e 2a 00 00       	call   808cc3 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  806295:	fe 83 a5 00 00 00    	incb   0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80629b:	8b 53 7c             	mov    0x7c(%ebx),%edx
  80629e:	85 d2                	test   %edx,%edx
  8062a0:	74 25                	je     8062c7 <tcp_slowtmr+0x250>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  8062a2:	8b 0d 80 c2 b3 00    	mov    0xb3c280,%ecx
  8062a8:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  8062ab:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  8062af:	8d 04 40             	lea    (%eax,%eax,2),%eax
  8062b2:	d1 e0                	shl    %eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  8062b4:	39 c1                	cmp    %eax,%ecx
  8062b6:	72 0f                	jb     8062c7 <tcp_slowtmr+0x250>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  8062b8:	89 14 24             	mov    %edx,(%esp)
  8062bb:	e8 4c fa ff ff       	call   805d0c <tcp_segs_free>
      pcb->ooseq = NULL;
  8062c0:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  8062c7:	8b 43 10             	mov    0x10(%ebx),%eax
  8062ca:	83 f8 03             	cmp    $0x3,%eax
  8062cd:	75 11                	jne    8062e0 <tcp_slowtmr+0x269>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  8062cf:	8b 15 80 c2 b3 00    	mov    0xb3c280,%edx
  8062d5:	2b 53 2c             	sub    0x2c(%ebx),%edx
  8062d8:	83 fa 28             	cmp    $0x28,%edx
  8062db:	76 03                	jbe    8062e0 <tcp_slowtmr+0x269>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  8062dd:	46                   	inc    %esi
  8062de:	eb 19                	jmp    8062f9 <tcp_slowtmr+0x282>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  8062e0:	83 f8 09             	cmp    $0x9,%eax
  8062e3:	75 14                	jne    8062f9 <tcp_slowtmr+0x282>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8062e5:	a1 80 c2 b3 00       	mov    0xb3c280,%eax
  8062ea:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  8062ed:	3d f1 00 00 00       	cmp    $0xf1,%eax
  8062f2:	89 f2                	mov    %esi,%edx
  8062f4:	80 da ff             	sbb    $0xff,%dl
  8062f7:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  8062f9:	89 f1                	mov    %esi,%ecx
  8062fb:	84 c9                	test   %cl,%cl
  8062fd:	0f 84 96 00 00 00    	je     806399 <tcp_slowtmr+0x322>
      tcp_pcb_purge(pcb);      
  806303:	89 1c 24             	mov    %ebx,(%esp)
  806306:	e8 e5 fa ff ff       	call   805df0 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80630b:	85 ff                	test   %edi,%edi
  80630d:	74 2c                	je     80633b <tcp_slowtmr+0x2c4>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80630f:	3b 1d 7c c2 b3 00    	cmp    0xb3c27c,%ebx
  806315:	75 1c                	jne    806333 <tcp_slowtmr+0x2bc>
  806317:	c7 44 24 08 98 28 81 	movl   $0x812898,0x8(%esp)
  80631e:	00 
  80631f:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  806326:	00 
  806327:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  80632e:	e8 4d 8b 00 00       	call   80ee80 <_panic>
        prev->next = pcb->next;
  806333:	8b 43 0c             	mov    0xc(%ebx),%eax
  806336:	89 47 0c             	mov    %eax,0xc(%edi)
  806339:	eb 2d                	jmp    806368 <tcp_slowtmr+0x2f1>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80633b:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  806340:	39 d8                	cmp    %ebx,%eax
  806342:	74 1c                	je     806360 <tcp_slowtmr+0x2e9>
  806344:	c7 44 24 08 c4 28 81 	movl   $0x8128c4,0x8(%esp)
  80634b:	00 
  80634c:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  806353:	00 
  806354:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  80635b:	e8 20 8b 00 00       	call   80ee80 <_panic>
        tcp_active_pcbs = pcb->next;
  806360:	8b 40 0c             	mov    0xc(%eax),%eax
  806363:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  806368:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80636e:	85 c0                	test   %eax,%eax
  806370:	74 10                	je     806382 <tcp_slowtmr+0x30b>
  806372:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  806379:	ff 
  80637a:	8b 53 18             	mov    0x18(%ebx),%edx
  80637d:	89 14 24             	mov    %edx,(%esp)
  806380:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  806382:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  806385:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806389:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806390:	e8 31 e6 ff ff       	call   8049c6 <memp_free>
      pcb = pcb2;
  806395:	89 f3                	mov    %esi,%ebx
  806397:	eb 3c                	jmp    8063d5 <tcp_slowtmr+0x35e>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  806399:	8a 43 30             	mov    0x30(%ebx),%al
  80639c:	40                   	inc    %eax
  80639d:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  8063a0:	3a 43 31             	cmp    0x31(%ebx),%al
  8063a3:	72 2b                	jb     8063d0 <tcp_slowtmr+0x359>
        pcb->polltmr = 0;
  8063a5:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  8063a9:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  8063af:	85 c0                	test   %eax,%eax
  8063b1:	74 0f                	je     8063c2 <tcp_slowtmr+0x34b>
  8063b3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8063b7:	8b 53 18             	mov    0x18(%ebx),%edx
  8063ba:	89 14 24             	mov    %edx,(%esp)
  8063bd:	ff d0                	call   *%eax
  8063bf:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  8063c2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8063c6:	75 08                	jne    8063d0 <tcp_slowtmr+0x359>
          tcp_output(pcb);
  8063c8:	89 1c 24             	mov    %ebx,(%esp)
  8063cb:	e8 6e 22 00 00       	call   80863e <tcp_output>
        }
      }
      
      prev = pcb;
  8063d0:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  8063d2:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  8063d5:	85 db                	test   %ebx,%ebx
  8063d7:	0f 85 bd fc ff ff    	jne    80609a <tcp_slowtmr+0x23>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  8063dd:	8b 1d 90 c2 b3 00    	mov    0xb3c290,%ebx
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  8063e3:	be 00 00 00 00       	mov    $0x0,%esi
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  8063e8:	e9 b2 00 00 00       	jmp    80649f <tcp_slowtmr+0x428>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8063ed:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  8063f1:	74 1c                	je     80640f <tcp_slowtmr+0x398>
  8063f3:	c7 44 24 08 f0 28 81 	movl   $0x8128f0,0x8(%esp)
  8063fa:	00 
  8063fb:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  806402:	00 
  806403:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  80640a:	e8 71 8a 00 00       	call   80ee80 <_panic>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80640f:	a1 80 c2 b3 00       	mov    0xb3c280,%eax
  806414:	2b 43 2c             	sub    0x2c(%ebx),%eax
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  806417:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80641c:	76 7c                	jbe    80649a <tcp_slowtmr+0x423>
      tcp_pcb_purge(pcb);      
  80641e:	89 1c 24             	mov    %ebx,(%esp)
  806421:	e8 ca f9 ff ff       	call   805df0 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  806426:	85 f6                	test   %esi,%esi
  806428:	74 2c                	je     806456 <tcp_slowtmr+0x3df>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80642a:	3b 1d 90 c2 b3 00    	cmp    0xb3c290,%ebx
  806430:	75 1c                	jne    80644e <tcp_slowtmr+0x3d7>
  806432:	c7 44 24 08 20 29 81 	movl   $0x812920,0x8(%esp)
  806439:	00 
  80643a:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  806441:	00 
  806442:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  806449:	e8 32 8a 00 00       	call   80ee80 <_panic>
        prev->next = pcb->next;
  80644e:	8b 43 0c             	mov    0xc(%ebx),%eax
  806451:	89 46 0c             	mov    %eax,0xc(%esi)
  806454:	eb 2d                	jmp    806483 <tcp_slowtmr+0x40c>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806456:	a1 90 c2 b3 00       	mov    0xb3c290,%eax
  80645b:	39 d8                	cmp    %ebx,%eax
  80645d:	74 1c                	je     80647b <tcp_slowtmr+0x404>
  80645f:	c7 44 24 08 48 29 81 	movl   $0x812948,0x8(%esp)
  806466:	00 
  806467:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  80646e:	00 
  80646f:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  806476:	e8 05 8a 00 00       	call   80ee80 <_panic>
        tcp_tw_pcbs = pcb->next;
  80647b:	8b 40 0c             	mov    0xc(%eax),%eax
  80647e:	a3 90 c2 b3 00       	mov    %eax,0xb3c290
      }
      pcb2 = pcb->next;
  806483:	8b 7b 0c             	mov    0xc(%ebx),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806486:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80648a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806491:	e8 30 e5 ff ff       	call   8049c6 <memp_free>
      pcb = pcb2;
  806496:	89 fb                	mov    %edi,%ebx
  806498:	eb 05                	jmp    80649f <tcp_slowtmr+0x428>
    } else {
      prev = pcb;
  80649a:	89 de                	mov    %ebx,%esi
      pcb = pcb->next;
  80649c:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  80649f:	85 db                	test   %ebx,%ebx
  8064a1:	0f 85 46 ff ff ff    	jne    8063ed <tcp_slowtmr+0x376>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  8064a7:	83 c4 2c             	add    $0x2c,%esp
  8064aa:	5b                   	pop    %ebx
  8064ab:	5e                   	pop    %esi
  8064ac:	5f                   	pop    %edi
  8064ad:	5d                   	pop    %ebp
  8064ae:	c3                   	ret    

008064af <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  8064af:	55                   	push   %ebp
  8064b0:	89 e5                	mov    %esp,%ebp
  8064b2:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  8064b5:	e8 92 f7 ff ff       	call   805c4c <tcp_fasttmr>

  if (++tcp_timer & 1) {
  8064ba:	a0 1c 54 b3 00       	mov    0xb3541c,%al
  8064bf:	40                   	inc    %eax
  8064c0:	a2 1c 54 b3 00       	mov    %al,0xb3541c
  8064c5:	a8 01                	test   $0x1,%al
  8064c7:	74 05                	je     8064ce <tcp_tmr+0x1f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  8064c9:	e8 a9 fb ff ff       	call   806077 <tcp_slowtmr>
  }
}
  8064ce:	c9                   	leave  
  8064cf:	c3                   	ret    

008064d0 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  8064d0:	55                   	push   %ebp
  8064d1:	89 e5                	mov    %esp,%ebp
  8064d3:	56                   	push   %esi
  8064d4:	53                   	push   %ebx
  8064d5:	83 ec 10             	sub    $0x10,%esp
  8064d8:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  8064db:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8064df:	0f 87 1e 01 00 00    	ja     806603 <tcp_close+0x133>
  8064e5:	8b 43 10             	mov    0x10(%ebx),%eax
  8064e8:	ff 24 85 00 2a 81 00 	jmp    *0x812a00(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  8064ef:	8b 15 8c c2 b3 00    	mov    0xb3c28c,%edx
  8064f5:	39 da                	cmp    %ebx,%edx
  8064f7:	75 0a                	jne    806503 <tcp_close+0x33>
  8064f9:	8b 42 0c             	mov    0xc(%edx),%eax
  8064fc:	a3 8c c2 b3 00       	mov    %eax,0xb3c28c
  806501:	eb 31                	jmp    806534 <tcp_close+0x64>
  806503:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  806509:	eb 1f                	jmp    80652a <tcp_close+0x5a>
  80650b:	8b 42 0c             	mov    0xc(%edx),%eax
  80650e:	85 c0                	test   %eax,%eax
  806510:	74 12                	je     806524 <tcp_close+0x54>
  806512:	39 c3                	cmp    %eax,%ebx
  806514:	75 12                	jne    806528 <tcp_close+0x58>
  806516:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  80651c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80651f:	89 42 0c             	mov    %eax,0xc(%edx)
  806522:	eb 10                	jmp    806534 <tcp_close+0x64>
  806524:	89 c2                	mov    %eax,%edx
  806526:	eb 02                	jmp    80652a <tcp_close+0x5a>
  806528:	89 c2                	mov    %eax,%edx
  80652a:	85 d2                	test   %edx,%edx
  80652c:	75 dd                	jne    80650b <tcp_close+0x3b>
  80652e:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  806534:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  80653b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80653f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806546:	e8 7b e4 ff ff       	call   8049c6 <memp_free>
    pcb = NULL;
    break;
  80654b:	be 00 00 00 00       	mov    $0x0,%esi
  806550:	e9 ca 00 00 00       	jmp    80661f <tcp_close+0x14f>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  806555:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806559:	c7 04 24 84 c2 b3 00 	movl   $0xb3c284,(%esp)
  806560:	e8 04 f9 ff ff       	call   805e69 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  806565:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806569:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  806570:	e8 51 e4 ff ff       	call   8049c6 <memp_free>
    pcb = NULL;
    break;
  806575:	be 00 00 00 00       	mov    $0x0,%esi
  80657a:	e9 a0 00 00 00       	jmp    80661f <tcp_close+0x14f>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80657f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806583:	c7 04 24 7c c2 b3 00 	movl   $0xb3c27c,(%esp)
  80658a:	e8 da f8 ff ff       	call   805e69 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  80658f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806593:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80659a:	e8 27 e4 ff ff       	call   8049c6 <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  80659f:	be 00 00 00 00       	mov    $0x0,%esi
  8065a4:	eb 79                	jmp    80661f <tcp_close+0x14f>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8065a6:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8065ad:	00 
  8065ae:	89 1c 24             	mov    %ebx,(%esp)
  8065b1:	e8 45 20 00 00       	call   8085fb <tcp_send_ctrl>
  8065b6:	89 c6                	mov    %eax,%esi
    if (err == ERR_OK) {
  8065b8:	84 c0                	test   %al,%al
  8065ba:	75 51                	jne    80660d <tcp_close+0x13d>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  8065bc:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8065c3:	eb 48                	jmp    80660d <tcp_close+0x13d>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8065c5:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8065cc:	00 
  8065cd:	89 1c 24             	mov    %ebx,(%esp)
  8065d0:	e8 26 20 00 00       	call   8085fb <tcp_send_ctrl>
  8065d5:	89 c6                	mov    %eax,%esi
    if (err == ERR_OK) {
  8065d7:	84 c0                	test   %al,%al
  8065d9:	75 32                	jne    80660d <tcp_close+0x13d>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  8065db:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8065e2:	eb 29                	jmp    80660d <tcp_close+0x13d>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8065e4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8065eb:	00 
  8065ec:	89 1c 24             	mov    %ebx,(%esp)
  8065ef:	e8 07 20 00 00       	call   8085fb <tcp_send_ctrl>
  8065f4:	89 c6                	mov    %eax,%esi
    if (err == ERR_OK) {
  8065f6:	84 c0                	test   %al,%al
  8065f8:	75 13                	jne    80660d <tcp_close+0x13d>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  8065fa:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  806601:	eb 0a                	jmp    80660d <tcp_close+0x13d>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  806603:	be 00 00 00 00       	mov    $0x0,%esi
    pcb = NULL;
  806608:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  80660d:	85 db                	test   %ebx,%ebx
  80660f:	74 0e                	je     80661f <tcp_close+0x14f>
  806611:	89 f0                	mov    %esi,%eax
  806613:	84 c0                	test   %al,%al
  806615:	75 08                	jne    80661f <tcp_close+0x14f>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  806617:	89 1c 24             	mov    %ebx,(%esp)
  80661a:	e8 1f 20 00 00       	call   80863e <tcp_output>
  }
  return err;
}
  80661f:	89 f0                	mov    %esi,%eax
  806621:	83 c4 10             	add    $0x10,%esp
  806624:	5b                   	pop    %ebx
  806625:	5e                   	pop    %esi
  806626:	5d                   	pop    %ebp
  806627:	c3                   	ret    

00806628 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  806628:	55                   	push   %ebp
  806629:	89 e5                	mov    %esp,%ebp
  80662b:	83 ec 18             	sub    $0x18,%esp
  80662e:	8b 45 10             	mov    0x10(%ebp),%eax
  806631:	8a 55 14             	mov    0x14(%ebp),%dl
  arg = arg;
  if (p != NULL) {
  806634:	85 c0                	test   %eax,%eax
  806636:	74 0c                	je     806644 <tcp_recv_null+0x1c>
    pbuf_free(p);
  806638:	89 04 24             	mov    %eax,(%esp)
  80663b:	e8 11 e7 ff ff       	call   804d51 <pbuf_free>
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  806640:	b0 00                	mov    $0x0,%al
  806642:	eb 13                	jmp    806657 <tcp_recv_null+0x2f>
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  806644:	84 d2                	test   %dl,%dl
  806646:	75 0d                	jne    806655 <tcp_recv_null+0x2d>
    return tcp_close(pcb);
  806648:	8b 45 0c             	mov    0xc(%ebp),%eax
  80664b:	89 04 24             	mov    %eax,(%esp)
  80664e:	e8 7d fe ff ff       	call   8064d0 <tcp_close>
  806653:	eb 02                	jmp    806657 <tcp_recv_null+0x2f>
  }
  return ERR_OK;
  806655:	b0 00                	mov    $0x0,%al
}
  806657:	c9                   	leave  
  806658:	c3                   	ret    

00806659 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  806659:	55                   	push   %ebp
  80665a:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  80665c:	a1 80 c2 b3 00       	mov    0xb3c280,%eax
  806661:	03 05 0c 50 81 00    	add    0x81500c,%eax
  806667:	a3 0c 50 81 00       	mov    %eax,0x81500c
  return iss;
}
  80666c:	5d                   	pop    %ebp
  80666d:	c3                   	ret    

0080666e <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  80666e:	55                   	push   %ebp
  80666f:	89 e5                	mov    %esp,%ebp
  806671:	57                   	push   %edi
  806672:	56                   	push   %esi
  806673:	53                   	push   %ebx
  806674:	83 ec 2c             	sub    $0x2c,%esp
  806677:	8a 45 08             	mov    0x8(%ebp),%al
  80667a:	88 45 e7             	mov    %al,-0x19(%ebp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  80667d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806684:	e8 dd e2 ff ff       	call   804966 <memp_malloc>
  806689:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  80668b:	85 c0                	test   %eax,%eax
  80668d:	0f 85 aa 00 00 00    	jne    80673d <tcp_alloc+0xcf>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806693:	a1 90 c2 b3 00       	mov    0xb3c290,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806698:	8b 1d 80 c2 b3 00    	mov    0xb3c280,%ebx
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  80669e:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  8066a3:	be 00 00 00 00       	mov    $0x0,%esi
  8066a8:	eb 10                	jmp    8066ba <tcp_alloc+0x4c>
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8066aa:	89 da                	mov    %ebx,%edx
  8066ac:	2b 50 2c             	sub    0x2c(%eax),%edx
  8066af:	39 ca                	cmp    %ecx,%edx
  8066b1:	72 04                	jb     8066b7 <tcp_alloc+0x49>
      inactivity = tcp_ticks - pcb->tmr;
  8066b3:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8066b5:	89 c6                	mov    %eax,%esi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8066b7:	8b 40 0c             	mov    0xc(%eax),%eax
  8066ba:	85 c0                	test   %eax,%eax
  8066bc:	75 ec                	jne    8066aa <tcp_alloc+0x3c>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8066be:	85 f6                	test   %esi,%esi
  8066c0:	74 08                	je     8066ca <tcp_alloc+0x5c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8066c2:	89 34 24             	mov    %esi,(%esp)
  8066c5:	e8 98 f8 ff ff       	call   805f62 <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  8066ca:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8066d1:	e8 90 e2 ff ff       	call   804966 <memp_malloc>
  8066d6:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  8066d8:	85 c0                	test   %eax,%eax
  8066da:	75 61                	jne    80673d <tcp_alloc+0xcf>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8066dc:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8066e1:	8b 3d 80 c2 b3 00    	mov    0xb3c280,%edi
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  8066e7:	b1 7f                	mov    $0x7f,%cl
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  8066e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  inactive = NULL;
  8066f0:	be 00 00 00 00       	mov    $0x0,%esi
  8066f5:	eb 20                	jmp    806717 <tcp_alloc+0xa9>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  8066f7:	8a 50 14             	mov    0x14(%eax),%dl
  8066fa:	38 55 e7             	cmp    %dl,-0x19(%ebp)
  8066fd:	72 15                	jb     806714 <tcp_alloc+0xa6>
  8066ff:	38 ca                	cmp    %cl,%dl
  806701:	77 11                	ja     806714 <tcp_alloc+0xa6>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806703:	89 fb                	mov    %edi,%ebx
  806705:	2b 58 2c             	sub    0x2c(%eax),%ebx
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  806708:	3b 5d e0             	cmp    -0x20(%ebp),%ebx
  80670b:	72 07                	jb     806714 <tcp_alloc+0xa6>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  80670d:	88 d1                	mov    %dl,%cl
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  80670f:	89 5d e0             	mov    %ebx,-0x20(%ebp)
      inactive = pcb;
  806712:	89 c6                	mov    %eax,%esi
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806714:	8b 40 0c             	mov    0xc(%eax),%eax
  806717:	85 c0                	test   %eax,%eax
  806719:	75 dc                	jne    8066f7 <tcp_alloc+0x89>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  80671b:	85 f6                	test   %esi,%esi
  80671d:	74 08                	je     806727 <tcp_alloc+0xb9>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80671f:	89 34 24             	mov    %esi,(%esp)
  806722:	e8 3b f8 ff ff       	call   805f62 <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  806727:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80672e:	e8 33 e2 ff ff       	call   804966 <memp_malloc>
  806733:	89 c3                	mov    %eax,%ebx
    }
  }
  if (pcb != NULL) {
  806735:	85 c0                	test   %eax,%eax
  806737:	0f 84 9b 00 00 00    	je     8067d8 <tcp_alloc+0x16a>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  80673d:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  806744:	00 
  806745:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80674c:	00 
  80674d:	89 1c 24             	mov    %ebx,(%esp)
  806750:	e8 fd 8e 00 00       	call   80f652 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806755:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  806759:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  80675f:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  806765:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  80676b:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  806771:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  806775:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  806779:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  80677f:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  806785:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80678b:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  806791:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  806797:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  80679d:	e8 b7 fe ff ff       	call   806659 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  8067a2:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  8067a5:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  8067a8:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  8067ab:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  8067ae:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  8067b1:	a1 80 c2 b3 00       	mov    0xb3c280,%eax
  8067b6:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  8067b9:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  8067bd:	c7 83 88 00 00 00 28 	movl   $0x806628,0x88(%ebx)
  8067c4:	66 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8067c7:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  8067ce:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8067d1:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  }
  return pcb;
}
  8067d8:	89 d8                	mov    %ebx,%eax
  8067da:	83 c4 2c             	add    $0x2c,%esp
  8067dd:	5b                   	pop    %ebx
  8067de:	5e                   	pop    %esi
  8067df:	5f                   	pop    %edi
  8067e0:	5d                   	pop    %ebp
  8067e1:	c3                   	ret    

008067e2 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  8067e2:	55                   	push   %ebp
  8067e3:	89 e5                	mov    %esp,%ebp
  8067e5:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  8067e8:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  8067ef:	e8 7a fe ff ff       	call   80666e <tcp_alloc>
}
  8067f4:	c9                   	leave  
  8067f5:	c3                   	ret    

008067f6 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  8067f6:	55                   	push   %ebp
  8067f7:	89 e5                	mov    %esp,%ebp
  8067f9:	53                   	push   %ebx
  8067fa:	83 ec 14             	sub    $0x14,%esp
  8067fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  806800:	8b 45 0c             	mov    0xc(%ebp),%eax
  806803:	89 04 24             	mov    %eax,(%esp)
  806806:	e8 d5 01 00 00       	call   8069e0 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  80680b:	85 c0                	test   %eax,%eax
  80680d:	74 12                	je     806821 <tcp_eff_send_mss+0x2b>
  80680f:	8b 40 2c             	mov    0x2c(%eax),%eax
  806812:	66 85 c0             	test   %ax,%ax
  806815:	74 0a                	je     806821 <tcp_eff_send_mss+0x2b>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  806817:	83 e8 28             	sub    $0x28,%eax
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  80681a:	66 39 c3             	cmp    %ax,%bx
  80681d:	76 02                	jbe    806821 <tcp_eff_send_mss+0x2b>
  80681f:	89 c3                	mov    %eax,%ebx
  }
  return sendmss;
}
  806821:	89 d8                	mov    %ebx,%eax
  806823:	83 c4 14             	add    $0x14,%esp
  806826:	5b                   	pop    %ebx
  806827:	5d                   	pop    %ebp
  806828:	c3                   	ret    

00806829 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  806829:	55                   	push   %ebp
  80682a:	89 e5                	mov    %esp,%ebp
  80682c:	56                   	push   %esi
  80682d:	53                   	push   %ebx
  80682e:	83 ec 30             	sub    $0x30,%esp
  806831:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806834:	8b 75 0c             	mov    0xc(%ebp),%esi
  806837:	8b 45 10             	mov    0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80683a:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80683e:	74 1c                	je     80685c <tcp_connect+0x33>
  806840:	c7 44 24 08 70 29 81 	movl   $0x812970,0x8(%esp)
  806847:	00 
  806848:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  80684f:	00 
  806850:	c7 04 24 a2 29 81 00 	movl   $0x8129a2,(%esp)
  806857:	e8 24 86 00 00       	call   80ee80 <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80685c:	85 f6                	test   %esi,%esi
  80685e:	0f 84 28 01 00 00    	je     80698c <tcp_connect+0x163>
    pcb->remote_ip = *ipaddr;
  806864:	8b 16                	mov    (%esi),%edx
  806866:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  806869:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  80686d:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  806872:	75 09                	jne    80687d <tcp_connect+0x54>
    pcb->local_port = tcp_new_port();
  806874:	e8 62 f0 ff ff       	call   8058db <tcp_new_port>
  806879:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  80687d:	e8 d7 fd ff ff       	call   806659 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  806882:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  806889:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  80688c:	48                   	dec    %eax
  80688d:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  806890:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  806893:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  806899:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  80689f:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8068a5:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8068ab:	89 74 24 04          	mov    %esi,0x4(%esp)
  8068af:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  8068b6:	e8 3b ff ff ff       	call   8067f6 <tcp_eff_send_mss>
  8068bb:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  8068bf:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8068c5:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8068c8:	d1 e0                	shl    %eax
  8068ca:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8068ce:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8068d5:	8b 45 14             	mov    0x14(%ebp),%eax
  8068d8:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8068de:	8b 15 8c c2 b3 00    	mov    0xb3c28c,%edx
  8068e4:	39 da                	cmp    %ebx,%edx
  8068e6:	75 0a                	jne    8068f2 <tcp_connect+0xc9>
  8068e8:	8b 42 0c             	mov    0xc(%edx),%eax
  8068eb:	a3 8c c2 b3 00       	mov    %eax,0xb3c28c
  8068f0:	eb 31                	jmp    806923 <tcp_connect+0xfa>
  8068f2:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  8068f8:	eb 1f                	jmp    806919 <tcp_connect+0xf0>
  8068fa:	8b 42 0c             	mov    0xc(%edx),%eax
  8068fd:	85 c0                	test   %eax,%eax
  8068ff:	74 12                	je     806913 <tcp_connect+0xea>
  806901:	39 c3                	cmp    %eax,%ebx
  806903:	75 12                	jne    806917 <tcp_connect+0xee>
  806905:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  80690b:	8b 43 0c             	mov    0xc(%ebx),%eax
  80690e:	89 42 0c             	mov    %eax,0xc(%edx)
  806911:	eb 10                	jmp    806923 <tcp_connect+0xfa>
  806913:	89 c2                	mov    %eax,%edx
  806915:	eb 02                	jmp    806919 <tcp_connect+0xf0>
  806917:	89 c2                	mov    %eax,%edx
  806919:	85 d2                	test   %edx,%edx
  80691b:	75 dd                	jne    8068fa <tcp_connect+0xd1>
  80691d:	89 15 88 c2 b3 00    	mov    %edx,0xb3c288
  TCP_REG(&tcp_active_pcbs, pcb);
  806923:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  806928:	89 43 0c             	mov    %eax,0xc(%ebx)
  80692b:	89 1d 7c c2 b3 00    	mov    %ebx,0xb3c27c
  806931:	e8 f8 bb ff ff       	call   80252e <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  806936:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80693d:	e8 37 13 00 00       	call   807c79 <htonl>
  806942:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806945:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  80694c:	00 
  80694d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  806950:	89 44 24 14          	mov    %eax,0x14(%esp)
  806954:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80695b:	00 
  80695c:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  806963:	00 
  806964:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80696b:	00 
  80696c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806973:	00 
  806974:	89 1c 24             	mov    %ebx,(%esp)
  806977:	e8 68 15 00 00       	call   807ee4 <tcp_enqueue>
  80697c:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  80697e:	84 c0                	test   %al,%al
  806980:	75 0f                	jne    806991 <tcp_connect+0x168>
    tcp_output(pcb);
  806982:	89 1c 24             	mov    %ebx,(%esp)
  806985:	e8 b4 1c 00 00       	call   80863e <tcp_output>
  80698a:	eb 05                	jmp    806991 <tcp_connect+0x168>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  80698c:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  806991:	89 f0                	mov    %esi,%eax
  806993:	83 c4 30             	add    $0x30,%esp
  806996:	5b                   	pop    %ebx
  806997:	5e                   	pop    %esi
  806998:	5d                   	pop    %ebp
  806999:	c3                   	ret    
	...

0080699c <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  80699c:	55                   	push   %ebp
  80699d:	89 e5                	mov    %esp,%ebp
  80699f:	8b 55 0c             	mov    0xc(%ebp),%edx
  u32_t addr2test;

  addr2test = addr->addr;
  8069a2:	8b 45 08             	mov    0x8(%ebp),%eax
  8069a5:	8b 00                	mov    (%eax),%eax
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8069a7:	8d 48 ff             	lea    -0x1(%eax),%ecx
  8069aa:	83 f9 fd             	cmp    $0xfffffffd,%ecx
  8069ad:	77 21                	ja     8069d0 <ip_addr_isbroadcast+0x34>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8069af:	f6 42 2e 02          	testb  $0x2,0x2e(%edx)
  8069b3:	74 1f                	je     8069d4 <ip_addr_isbroadcast+0x38>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  8069b5:	8b 4a 04             	mov    0x4(%edx),%ecx
  8069b8:	39 c1                	cmp    %eax,%ecx
  8069ba:	74 1c                	je     8069d8 <ip_addr_isbroadcast+0x3c>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8069bc:	8b 52 08             	mov    0x8(%edx),%edx
  8069bf:	31 c1                	xor    %eax,%ecx
  8069c1:	85 d1                	test   %edx,%ecx
  8069c3:	75 17                	jne    8069dc <ip_addr_isbroadcast+0x40>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  8069c5:	f7 d2                	not    %edx
  8069c7:	21 d0                	and    %edx,%eax
 * 
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
  8069c9:	39 c2                	cmp    %eax,%edx
  8069cb:	0f 94 c0             	sete   %al
  8069ce:	eb 0e                	jmp    8069de <ip_addr_isbroadcast+0x42>

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8069d0:	b0 01                	mov    $0x1,%al
  8069d2:	eb 0a                	jmp    8069de <ip_addr_isbroadcast+0x42>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  8069d4:	b0 00                	mov    $0x0,%al
  8069d6:	eb 06                	jmp    8069de <ip_addr_isbroadcast+0x42>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  8069d8:	b0 00                	mov    $0x0,%al
  8069da:	eb 02                	jmp    8069de <ip_addr_isbroadcast+0x42>
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
  8069dc:	b0 00                	mov    $0x0,%al
}
  8069de:	5d                   	pop    %ebp
  8069df:	c3                   	ret    

008069e0 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  8069e0:	55                   	push   %ebp
  8069e1:	89 e5                	mov    %esp,%ebp
  8069e3:	56                   	push   %esi
  8069e4:	53                   	push   %ebx
  8069e5:	83 ec 10             	sub    $0x10,%esp
  8069e8:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8069eb:	8b 1d 74 c2 b3 00    	mov    0xb3c274,%ebx
  8069f1:	eb 18                	jmp    806a0b <ip_route+0x2b>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  8069f3:	89 1c 24             	mov    %ebx,(%esp)
  8069f6:	e8 62 e2 ff ff       	call   804c5d <netif_is_up>
  8069fb:	84 c0                	test   %al,%al
  8069fd:	74 0a                	je     806a09 <ip_route+0x29>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  8069ff:	8b 43 04             	mov    0x4(%ebx),%eax
  806a02:	33 06                	xor    (%esi),%eax
  806a04:	85 43 08             	test   %eax,0x8(%ebx)
  806a07:	74 21                	je     806a2a <ip_route+0x4a>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806a09:	8b 1b                	mov    (%ebx),%ebx
  806a0b:	85 db                	test   %ebx,%ebx
  806a0d:	75 e4                	jne    8069f3 <ip_route+0x13>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  806a0f:	a1 78 c2 b3 00       	mov    0xb3c278,%eax
  806a14:	85 c0                	test   %eax,%eax
  806a16:	74 12                	je     806a2a <ip_route+0x4a>
  806a18:	89 04 24             	mov    %eax,(%esp)
  806a1b:	e8 3d e2 ff ff       	call   804c5d <netif_is_up>
  806a20:	84 c0                	test   %al,%al
  806a22:	74 06                	je     806a2a <ip_route+0x4a>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  806a24:	8b 1d 78 c2 b3 00    	mov    0xb3c278,%ebx
}
  806a2a:	89 d8                	mov    %ebx,%eax
  806a2c:	83 c4 10             	add    $0x10,%esp
  806a2f:	5b                   	pop    %ebx
  806a30:	5e                   	pop    %esi
  806a31:	5d                   	pop    %ebp
  806a32:	c3                   	ret    

00806a33 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  806a33:	55                   	push   %ebp
  806a34:	89 e5                	mov    %esp,%ebp
  806a36:	57                   	push   %edi
  806a37:	56                   	push   %esi
  806a38:	53                   	push   %ebx
  806a39:	83 ec 2c             	sub    $0x2c,%esp
  806a3c:	8b 7d 08             	mov    0x8(%ebp),%edi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806a3f:	8b 77 04             	mov    0x4(%edi),%esi
  if (IPH_V(iphdr) != 4) {
  806a42:	0f b7 06             	movzwl (%esi),%eax
  806a45:	89 04 24             	mov    %eax,(%esp)
  806a48:	e8 18 12 00 00       	call   807c65 <ntohs>
  806a4d:	66 c1 e8 0c          	shr    $0xc,%ax
  806a51:	66 83 f8 04          	cmp    $0x4,%ax
  806a55:	74 0d                	je     806a64 <ip_input+0x31>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  806a57:	89 3c 24             	mov    %edi,(%esp)
  806a5a:	e8 f2 e2 ff ff       	call   804d51 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806a5f:	e9 72 02 00 00       	jmp    806cd6 <ip_input+0x2a3>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  806a64:	0f b7 06             	movzwl (%esi),%eax
  806a67:	89 04 24             	mov    %eax,(%esp)
  806a6a:	e8 f6 11 00 00       	call   807c65 <ntohs>
  806a6f:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  806a73:	83 e0 3c             	and    $0x3c,%eax
  806a76:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806a7a:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806a7e:	89 04 24             	mov    %eax,(%esp)
  806a81:	e8 df 11 00 00       	call   807c65 <ntohs>
  806a86:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806a88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a8b:	66 3b 47 0a          	cmp    0xa(%edi),%ax
  806a8f:	77 06                	ja     806a97 <ip_input+0x64>
  806a91:	66 3b 5f 08          	cmp    0x8(%edi),%bx
  806a95:	76 0d                	jbe    806aa4 <ip_input+0x71>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  806a97:	89 3c 24             	mov    %edi,(%esp)
  806a9a:	e8 b2 e2 ff ff       	call   804d51 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  806a9f:	e9 32 02 00 00       	jmp    806cd6 <ip_input+0x2a3>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806aa4:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806aa8:	89 44 24 04          	mov    %eax,0x4(%esp)
  806aac:	89 34 24             	mov    %esi,(%esp)
  806aaf:	e8 6f 10 00 00       	call   807b23 <inet_chksum>
  806ab4:	66 85 c0             	test   %ax,%ax
  806ab7:	74 0d                	je     806ac6 <ip_input+0x93>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806ab9:	89 3c 24             	mov    %edi,(%esp)
  806abc:	e8 90 e2 ff ff       	call   804d51 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806ac1:	e9 10 02 00 00       	jmp    806cd6 <ip_input+0x2a3>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  806ac6:	0f b7 db             	movzwl %bx,%ebx
  806ac9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806acd:	89 3c 24             	mov    %edi,(%esp)
  806ad0:	e8 4e e3 ff ff       	call   804e23 <pbuf_realloc>
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  806ad5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  806ad8:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806adf:	8d 46 10             	lea    0x10(%esi),%eax
  806ae2:	89 45 e0             	mov    %eax,-0x20(%ebp)
  806ae5:	89 7d d8             	mov    %edi,-0x28(%ebp)
  806ae8:	89 f7                	mov    %esi,%edi
  806aea:	be 01 00 00 00       	mov    $0x1,%esi
  806aef:	eb 05                	jmp    806af6 <ip_input+0xc3>
        netif = netif->next;
      }
      if (netif == inp) {
        netif = netif->next;
      }
    } while(netif != NULL);
  806af1:	be 00 00 00 00       	mov    $0x0,%esi
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  806af6:	89 1c 24             	mov    %ebx,(%esp)
  806af9:	e8 5f e1 ff ff       	call   804c5d <netif_is_up>
  806afe:	84 c0                	test   %al,%al
  806b00:	74 24                	je     806b26 <ip_input+0xf3>
  806b02:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806b05:	74 1f                	je     806b26 <ip_input+0xf3>
  806b07:	8b 43 04             	mov    0x4(%ebx),%eax
  806b0a:	85 c0                	test   %eax,%eax
  806b0c:	74 18                	je     806b26 <ip_input+0xf3>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806b0e:	3b 47 10             	cmp    0x10(%edi),%eax
  806b11:	74 36                	je     806b49 <ip_input+0x116>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806b13:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806b17:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806b1a:	89 04 24             	mov    %eax,(%esp)
  806b1d:	e8 7a fe ff ff       	call   80699c <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806b22:	84 c0                	test   %al,%al
  806b24:	75 2c                	jne    806b52 <ip_input+0x11f>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  806b26:	85 f6                	test   %esi,%esi
  806b28:	74 08                	je     806b32 <ip_input+0xff>
        first = 0;
        netif = netif_list;
  806b2a:	8b 1d 74 c2 b3 00    	mov    0xb3c274,%ebx
  806b30:	eb 02                	jmp    806b34 <ip_input+0x101>
      } else {
        netif = netif->next;
  806b32:	8b 1b                	mov    (%ebx),%ebx
      }
      if (netif == inp) {
  806b34:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  806b37:	75 05                	jne    806b3e <ip_input+0x10b>
        netif = netif->next;
  806b39:	8b 45 0c             	mov    0xc(%ebp),%eax
  806b3c:	8b 18                	mov    (%eax),%ebx
      }
    } while(netif != NULL);
  806b3e:	85 db                	test   %ebx,%ebx
  806b40:	75 af                	jne    806af1 <ip_input+0xbe>
  806b42:	89 fe                	mov    %edi,%esi
  806b44:	8b 7d d8             	mov    -0x28(%ebp),%edi
  806b47:	eb 14                	jmp    806b5d <ip_input+0x12a>
  806b49:	89 fe                	mov    %edi,%esi
  806b4b:	8b 7d d8             	mov    -0x28(%ebp),%edi
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806b4e:	89 d8                	mov    %ebx,%eax
  806b50:	eb 07                	jmp    806b59 <ip_input+0x126>
  806b52:	89 fe                	mov    %edi,%esi
  806b54:	8b 7d d8             	mov    -0x28(%ebp),%edi
  806b57:	89 d8                	mov    %ebx,%eax
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  806b59:	85 c0                	test   %eax,%eax
  806b5b:	75 33                	jne    806b90 <ip_input+0x15d>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806b5d:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806b61:	89 04 24             	mov    %eax,(%esp)
  806b64:	e8 fc 10 00 00       	call   807c65 <ntohs>
  806b69:	3c 11                	cmp    $0x11,%al
  806b6b:	75 1e                	jne    806b8b <ip_input+0x158>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806b6d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806b71:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  806b76:	89 04 24             	mov    %eax,(%esp)
  806b79:	e8 e7 10 00 00       	call   807c65 <ntohs>
  806b7e:	bb 00 00 00 00       	mov    $0x0,%ebx
  806b83:	66 83 f8 44          	cmp    $0x44,%ax
  806b87:	75 07                	jne    806b90 <ip_input+0x15d>
  806b89:	eb 51                	jmp    806bdc <ip_input+0x1a9>
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806b8b:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806b90:	8b 45 0c             	mov    0xc(%ebp),%eax
  806b93:	89 44 24 04          	mov    %eax,0x4(%esp)
  806b97:	8d 46 0c             	lea    0xc(%esi),%eax
  806b9a:	89 04 24             	mov    %eax,(%esp)
  806b9d:	e8 fa fd ff ff       	call   80699c <ip_addr_isbroadcast>
  806ba2:	84 c0                	test   %al,%al
  806ba4:	75 29                	jne    806bcf <ip_input+0x19c>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806ba6:	8b 46 0c             	mov    0xc(%esi),%eax
  806ba9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806bac:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806bb3:	e8 17 13 00 00       	call   807ecf <ntohl>
  806bb8:	23 45 e4             	and    -0x1c(%ebp),%eax
  806bbb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806bbe:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806bc5:	e8 05 13 00 00       	call   807ecf <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806bca:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  806bcd:	75 10                	jne    806bdf <ip_input+0x1ac>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  806bcf:	89 3c 24             	mov    %edi,(%esp)
  806bd2:	e8 7a e1 ff ff       	call   804d51 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  806bd7:	e9 fa 00 00 00       	jmp    806cd6 <ip_input+0x2a3>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  806bdc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  806bdf:	85 db                	test   %ebx,%ebx
  806be1:	75 0d                	jne    806bf0 <ip_input+0x1bd>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  806be3:	89 3c 24             	mov    %edi,(%esp)
  806be6:	e8 66 e1 ff ff       	call   804d51 <pbuf_free>
    return ERR_OK;
  806beb:	e9 e6 00 00 00       	jmp    806cd6 <ip_input+0x2a3>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806bf0:	66 8b 5e 06          	mov    0x6(%esi),%bx
  806bf4:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  806bfb:	e8 59 10 00 00       	call   807c59 <htons>
  806c00:	66 85 d8             	test   %bx,%ax
  806c03:	74 15                	je     806c1a <ip_input+0x1e7>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  806c05:	89 3c 24             	mov    %edi,(%esp)
  806c08:	e8 03 05 00 00       	call   807110 <ip_reass>
  806c0d:	89 c7                	mov    %eax,%edi
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  806c0f:	85 c0                	test   %eax,%eax
  806c11:	0f 84 bf 00 00 00    	je     806cd6 <ip_input+0x2a3>
      return ERR_OK;
    }
    iphdr = p->payload;
  806c17:	8b 70 04             	mov    0x4(%eax),%esi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  806c1a:	8b 45 0c             	mov    0xc(%ebp),%eax
  806c1d:	89 44 24 04          	mov    %eax,0x4(%esp)
  806c21:	89 3c 24             	mov    %edi,(%esp)
  806c24:	e8 bb 79 00 00       	call   80e5e4 <raw_input>
  806c29:	84 c0                	test   %al,%al
  806c2b:	0f 85 a5 00 00 00    	jne    806cd6 <ip_input+0x2a3>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  806c31:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806c35:	89 04 24             	mov    %eax,(%esp)
  806c38:	e8 28 10 00 00       	call   807c65 <ntohs>
  806c3d:	0f b6 c0             	movzbl %al,%eax
  806c40:	83 f8 06             	cmp    $0x6,%eax
  806c43:	74 1d                	je     806c62 <ip_input+0x22f>
  806c45:	83 f8 11             	cmp    $0x11,%eax
  806c48:	74 07                	je     806c51 <ip_input+0x21e>
  806c4a:	83 f8 01             	cmp    $0x1,%eax
  806c4d:	75 35                	jne    806c84 <ip_input+0x251>
  806c4f:	eb 22                	jmp    806c73 <ip_input+0x240>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  806c51:	8b 45 0c             	mov    0xc(%ebp),%eax
  806c54:	89 44 24 04          	mov    %eax,0x4(%esp)
  806c58:	89 3c 24             	mov    %edi,(%esp)
  806c5b:	e8 2c 23 00 00       	call   808f8c <udp_input>
      break;
  806c60:	eb 74                	jmp    806cd6 <ip_input+0x2a3>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  806c62:	8b 45 0c             	mov    0xc(%ebp),%eax
  806c65:	89 44 24 04          	mov    %eax,0x4(%esp)
  806c69:	89 3c 24             	mov    %edi,(%esp)
  806c6c:	e8 44 6c 00 00       	call   80d8b5 <tcp_input>
      break;
  806c71:	eb 63                	jmp    806cd6 <ip_input+0x2a3>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  806c73:	8b 45 0c             	mov    0xc(%ebp),%eax
  806c76:	89 44 24 04          	mov    %eax,0x4(%esp)
  806c7a:	89 3c 24             	mov    %edi,(%esp)
  806c7d:	e8 0a 7c 00 00       	call   80e88c <icmp_input>
      break;
  806c82:	eb 52                	jmp    806cd6 <ip_input+0x2a3>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806c84:	8b 45 0c             	mov    0xc(%ebp),%eax
  806c87:	89 44 24 04          	mov    %eax,0x4(%esp)
  806c8b:	8d 46 10             	lea    0x10(%esi),%eax
  806c8e:	89 04 24             	mov    %eax,(%esp)
  806c91:	e8 06 fd ff ff       	call   80699c <ip_addr_isbroadcast>
  806c96:	84 c0                	test   %al,%al
  806c98:	75 34                	jne    806cce <ip_input+0x29b>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806c9a:	8b 5e 10             	mov    0x10(%esi),%ebx
  806c9d:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806ca4:	e8 26 12 00 00       	call   807ecf <ntohl>
  806ca9:	21 c3                	and    %eax,%ebx
  806cab:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806cb2:	e8 18 12 00 00       	call   807ecf <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806cb7:	39 c3                	cmp    %eax,%ebx
  806cb9:	74 13                	je     806cce <ip_input+0x29b>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  806cbb:	89 77 04             	mov    %esi,0x4(%edi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806cbe:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  806cc5:	00 
  806cc6:	89 3c 24             	mov    %edi,(%esp)
  806cc9:	e8 1d 7f 00 00       	call   80ebeb <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  806cce:	89 3c 24             	mov    %edi,(%esp)
  806cd1:	e8 7b e0 ff ff       	call   804d51 <pbuf_free>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  806cd6:	b0 00                	mov    $0x0,%al
  806cd8:	83 c4 2c             	add    $0x2c,%esp
  806cdb:	5b                   	pop    %ebx
  806cdc:	5e                   	pop    %esi
  806cdd:	5f                   	pop    %edi
  806cde:	5d                   	pop    %ebp
  806cdf:	c3                   	ret    

00806ce0 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806ce0:	55                   	push   %ebp
  806ce1:	89 e5                	mov    %esp,%ebp
  806ce3:	57                   	push   %edi
  806ce4:	56                   	push   %esi
  806ce5:	53                   	push   %ebx
  806ce6:	83 ec 3c             	sub    $0x3c,%esp
  806ce9:	8b 75 08             	mov    0x8(%ebp),%esi
  806cec:	8b 7d 10             	mov    0x10(%ebp),%edi
  806cef:	8a 45 14             	mov    0x14(%ebp),%al
  806cf2:	88 45 d8             	mov    %al,-0x28(%ebp)
  806cf5:	8a 55 18             	mov    0x18(%ebp),%dl
  806cf8:	88 55 d7             	mov    %dl,-0x29(%ebp)
  806cfb:	8a 45 1c             	mov    0x1c(%ebp),%al
  806cfe:	88 45 d6             	mov    %al,-0x2a(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806d01:	85 ff                	test   %edi,%edi
  806d03:	0f 84 18 01 00 00    	je     806e21 <ip_output_if+0x141>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806d09:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806d10:	00 
  806d11:	89 34 24             	mov    %esi,(%esp)
  806d14:	e8 53 df ff ff       	call   804c6c <pbuf_header>
  806d19:	84 c0                	test   %al,%al
  806d1b:	0f 85 3c 01 00 00    	jne    806e5d <ip_output_if+0x17d>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806d21:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806d24:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806d29:	77 1c                	ja     806d47 <ip_output_if+0x67>
  806d2b:	c7 44 24 08 3c 2a 81 	movl   $0x812a3c,0x8(%esp)
  806d32:	00 
  806d33:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  806d3a:	00 
  806d3b:	c7 04 24 69 2a 81 00 	movl   $0x812a69,(%esp)
  806d42:	e8 39 81 00 00       	call   80ee80 <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806d47:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806d4b:	89 04 24             	mov    %eax,(%esp)
  806d4e:	e8 12 0f 00 00       	call   807c65 <ntohs>
  806d53:	25 ff 00 00 00       	and    $0xff,%eax
  806d58:	8a 55 d8             	mov    -0x28(%ebp),%dl
  806d5b:	c1 e2 08             	shl    $0x8,%edx
  806d5e:	09 d0                	or     %edx,%eax
  806d60:	0f b7 c0             	movzwl %ax,%eax
  806d63:	89 04 24             	mov    %eax,(%esp)
  806d66:	e8 ee 0e 00 00       	call   807c59 <htons>
  806d6b:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806d6f:	0f b7 c0             	movzwl %ax,%eax
  806d72:	89 04 24             	mov    %eax,(%esp)
  806d75:	e8 eb 0e 00 00       	call   807c65 <ntohs>
  806d7a:	25 00 ff 00 00       	and    $0xff00,%eax
  806d7f:	0f b6 55 d6          	movzbl -0x2a(%ebp),%edx
  806d83:	09 d0                	or     %edx,%eax
  806d85:	0f b7 c0             	movzwl %ax,%eax
  806d88:	89 04 24             	mov    %eax,(%esp)
  806d8b:	e8 c9 0e 00 00       	call   807c59 <htons>
  806d90:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806d94:	8b 07                	mov    (%edi),%eax
  806d96:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806d99:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  806d9d:	80 cc 45             	or     $0x45,%ah
  806da0:	89 04 24             	mov    %eax,(%esp)
  806da3:	e8 b1 0e 00 00       	call   807c59 <htons>
  806da8:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806dab:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806daf:	89 04 24             	mov    %eax,(%esp)
  806db2:	e8 a2 0e 00 00       	call   807c59 <htons>
  806db7:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806dbb:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806dc1:	0f b7 05 20 54 b3 00 	movzwl 0xb35420,%eax
  806dc8:	89 04 24             	mov    %eax,(%esp)
  806dcb:	e8 89 0e 00 00       	call   807c59 <htons>
  806dd0:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806dd4:	66 ff 05 20 54 b3 00 	incw   0xb35420

    if (ip_addr_isany(src)) {
  806ddb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806ddf:	74 09                	je     806dea <ip_output_if+0x10a>
  806de1:	8b 55 0c             	mov    0xc(%ebp),%edx
  806de4:	8b 02                	mov    (%edx),%eax
  806de6:	85 c0                	test   %eax,%eax
  806de8:	75 18                	jne    806e02 <ip_output_if+0x122>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806dea:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  806dee:	74 08                	je     806df8 <ip_output_if+0x118>
  806df0:	8b 55 20             	mov    0x20(%ebp),%edx
  806df3:	8b 42 04             	mov    0x4(%edx),%eax
  806df6:	eb 05                	jmp    806dfd <ip_output_if+0x11d>
  806df8:	b8 00 00 00 00       	mov    $0x0,%eax
  806dfd:	89 43 0c             	mov    %eax,0xc(%ebx)
  806e00:	eb 03                	jmp    806e05 <ip_output_if+0x125>
    } else {
      ip_addr_set(&(iphdr->src), src);
  806e02:	89 43 0c             	mov    %eax,0xc(%ebx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806e05:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806e0b:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806e12:	00 
  806e13:	89 1c 24             	mov    %ebx,(%esp)
  806e16:	e8 08 0d 00 00       	call   807b23 <inet_chksum>
  806e1b:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806e1f:	eb 06                	jmp    806e27 <ip_output_if+0x147>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  806e21:	8b 7e 04             	mov    0x4(%esi),%edi
  806e24:	83 c7 10             	add    $0x10,%edi
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806e27:	8b 55 20             	mov    0x20(%ebp),%edx
  806e2a:	8b 42 2c             	mov    0x2c(%edx),%eax
  806e2d:	66 85 c0             	test   %ax,%ax
  806e30:	74 18                	je     806e4a <ip_output_if+0x16a>
  806e32:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806e36:	73 12                	jae    806e4a <ip_output_if+0x16a>
    return ip_frag(p,netif,dest);
  806e38:	89 7c 24 08          	mov    %edi,0x8(%esp)
  806e3c:	89 54 24 04          	mov    %edx,0x4(%esp)
  806e40:	89 34 24             	mov    %esi,(%esp)
  806e43:	e8 21 08 00 00       	call   807669 <ip_frag>
  806e48:	eb 15                	jmp    806e5f <ip_output_if+0x17f>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806e4a:	89 7c 24 08          	mov    %edi,0x8(%esp)
  806e4e:	89 74 24 04          	mov    %esi,0x4(%esp)
  806e52:	8b 45 20             	mov    0x20(%ebp),%eax
  806e55:	89 04 24             	mov    %eax,(%esp)
  806e58:	ff 50 14             	call   *0x14(%eax)
  806e5b:	eb 02                	jmp    806e5f <ip_output_if+0x17f>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  806e5d:	b0 fe                	mov    $0xfe,%al
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  806e5f:	83 c4 3c             	add    $0x3c,%esp
  806e62:	5b                   	pop    %ebx
  806e63:	5e                   	pop    %esi
  806e64:	5f                   	pop    %edi
  806e65:	5d                   	pop    %ebp
  806e66:	c3                   	ret    

00806e67 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806e67:	55                   	push   %ebp
  806e68:	89 e5                	mov    %esp,%ebp
  806e6a:	57                   	push   %edi
  806e6b:	56                   	push   %esi
  806e6c:	53                   	push   %ebx
  806e6d:	83 ec 3c             	sub    $0x3c,%esp
  806e70:	8b 5d 10             	mov    0x10(%ebp),%ebx
  806e73:	8a 45 14             	mov    0x14(%ebp),%al
  806e76:	88 45 e7             	mov    %al,-0x19(%ebp)
  806e79:	0f b6 7d 18          	movzbl 0x18(%ebp),%edi
  806e7d:	0f b6 75 1c          	movzbl 0x1c(%ebp),%esi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806e81:	89 1c 24             	mov    %ebx,(%esp)
  806e84:	e8 57 fb ff ff       	call   8069e0 <ip_route>
  806e89:	85 c0                	test   %eax,%eax
  806e8b:	74 38                	je     806ec5 <ip_output+0x5e>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806e8d:	89 44 24 18          	mov    %eax,0x18(%esp)
  806e91:	81 e6 ff 00 00 00    	and    $0xff,%esi
  806e97:	89 74 24 14          	mov    %esi,0x14(%esp)
  806e9b:	81 e7 ff 00 00 00    	and    $0xff,%edi
  806ea1:	89 7c 24 10          	mov    %edi,0x10(%esp)
  806ea5:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  806ea9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  806ead:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  806eb1:	8b 45 0c             	mov    0xc(%ebp),%eax
  806eb4:	89 44 24 04          	mov    %eax,0x4(%esp)
  806eb8:	8b 45 08             	mov    0x8(%ebp),%eax
  806ebb:	89 04 24             	mov    %eax,(%esp)
  806ebe:	e8 1d fe ff ff       	call   806ce0 <ip_output_if>
  806ec3:	eb 02                	jmp    806ec7 <ip_output+0x60>
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    return ERR_RTE;
  806ec5:	b0 fc                	mov    $0xfc,%al
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
}
  806ec7:	83 c4 3c             	add    $0x3c,%esp
  806eca:	5b                   	pop    %ebx
  806ecb:	5e                   	pop    %esi
  806ecc:	5f                   	pop    %edi
  806ecd:	5d                   	pop    %ebp
  806ece:	c3                   	ret    
	...

00806ed0 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806ed0:	55                   	push   %ebp
  806ed1:	89 e5                	mov    %esp,%ebp
  806ed3:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806ed6:	8b 0d 40 54 b3 00    	mov    0xb35440,%ecx
  806edc:	39 c1                	cmp    %eax,%ecx
  806ede:	75 0a                	jne    806eea <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  806ee0:	8b 11                	mov    (%ecx),%edx
  806ee2:	89 15 40 54 b3 00    	mov    %edx,0xb35440
  806ee8:	eb 24                	jmp    806f0e <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806eea:	85 d2                	test   %edx,%edx
  806eec:	75 1c                	jne    806f0a <ip_reass_dequeue_datagram+0x3a>
  806eee:	c7 44 24 08 81 2a 81 	movl   $0x812a81,0x8(%esp)
  806ef5:	00 
  806ef6:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  806efd:	00 
  806efe:	c7 04 24 9a 2a 81 00 	movl   $0x812a9a,(%esp)
  806f05:	e8 76 7f 00 00       	call   80ee80 <_panic>
    prev->next = ipr->next;
  806f0a:	8b 08                	mov    (%eax),%ecx
  806f0c:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806f0e:	89 44 24 04          	mov    %eax,0x4(%esp)
  806f12:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  806f19:	e8 a8 da ff ff       	call   8049c6 <memp_free>
}
  806f1e:	c9                   	leave  
  806f1f:	c3                   	ret    

00806f20 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806f20:	55                   	push   %ebp
  806f21:	89 e5                	mov    %esp,%ebp
  806f23:	57                   	push   %edi
  806f24:	56                   	push   %esi
  806f25:	53                   	push   %ebx
  806f26:	83 ec 2c             	sub    $0x2c,%esp
  806f29:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806f2c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  806f2f:	39 c2                	cmp    %eax,%edx
  806f31:	75 1c                	jne    806f4f <ip_reass_free_complete_datagram+0x2f>
  806f33:	c7 44 24 08 b7 2a 81 	movl   $0x812ab7,0x8(%esp)
  806f3a:	00 
  806f3b:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  806f42:	00 
  806f43:	c7 04 24 9a 2a 81 00 	movl   $0x812a9a,(%esp)
  806f4a:	e8 31 7f 00 00       	call   80ee80 <_panic>
  if (prev != NULL) {
  806f4f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  806f53:	74 26                	je     806f7b <ip_reass_free_complete_datagram+0x5b>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806f55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806f58:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806f5b:	39 02                	cmp    %eax,(%edx)
  806f5d:	74 1c                	je     806f7b <ip_reass_free_complete_datagram+0x5b>
  806f5f:	c7 44 24 08 c3 2a 81 	movl   $0x812ac3,0x8(%esp)
  806f66:	00 
  806f67:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  806f6e:	00 
  806f6f:	c7 04 24 9a 2a 81 00 	movl   $0x812a9a,(%esp)
  806f76:	e8 05 7f 00 00       	call   80ee80 <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806f7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806f7e:	8b 58 04             	mov    0x4(%eax),%ebx
  806f81:	8b 43 04             	mov    0x4(%ebx),%eax
  if (iprh->start == 0) {
  806f84:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806f89:	75 49                	jne    806fd4 <ip_reass_free_complete_datagram+0xb4>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  806f8b:	8b 00                	mov    (%eax),%eax
  806f8d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806f90:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806f93:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  806f9a:	00 
  806f9b:	89 d0                	mov    %edx,%eax
  806f9d:	83 c0 08             	add    $0x8,%eax
  806fa0:	89 44 24 04          	mov    %eax,0x4(%esp)
  806fa4:	8b 43 04             	mov    0x4(%ebx),%eax
  806fa7:	89 04 24             	mov    %eax,(%esp)
  806faa:	e8 57 87 00 00       	call   80f706 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806faf:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  806fb6:	00 
  806fb7:	89 1c 24             	mov    %ebx,(%esp)
  806fba:	e8 3d 7d 00 00       	call   80ecfc <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806fbf:	89 1c 24             	mov    %ebx,(%esp)
  806fc2:	e8 11 e2 ff ff       	call   8051d8 <pbuf_clen>
  806fc7:	0f b6 f8             	movzbl %al,%edi
    pbuf_free(p);
  806fca:	89 1c 24             	mov    %ebx,(%esp)
  806fcd:	e8 7f dd ff ff       	call   804d51 <pbuf_free>
  806fd2:	eb 05                	jmp    806fd9 <ip_reass_free_complete_datagram+0xb9>
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  806fd4:	bf 00 00 00 00       	mov    $0x0,%edi
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  806fd9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806fdc:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806fdf:	eb 1c                	jmp    806ffd <ip_reass_free_complete_datagram+0xdd>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  806fe1:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806fe4:	8b 30                	mov    (%eax),%esi
    pbufs_freed += pbuf_clen(pcur);
  806fe6:	89 1c 24             	mov    %ebx,(%esp)
  806fe9:	e8 ea e1 ff ff       	call   8051d8 <pbuf_clen>
  806fee:	0f b6 c0             	movzbl %al,%eax
  806ff1:	01 c7                	add    %eax,%edi
    pbuf_free(pcur);    
  806ff3:	89 1c 24             	mov    %ebx,(%esp)
  806ff6:	e8 56 dd ff ff       	call   804d51 <pbuf_free>
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806ffb:	89 f3                	mov    %esi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  806ffd:	85 db                	test   %ebx,%ebx
  806fff:	75 e0                	jne    806fe1 <ip_reass_free_complete_datagram+0xc1>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  807001:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807004:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807007:	e8 c4 fe ff ff       	call   806ed0 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  80700c:	66 a1 44 54 b3 00    	mov    0xb35444,%ax
  807012:	0f b7 d0             	movzwl %ax,%edx
  807015:	39 fa                	cmp    %edi,%edx
  807017:	7d 1c                	jge    807035 <ip_reass_free_complete_datagram+0x115>
  807019:	c7 44 24 08 d5 2a 81 	movl   $0x812ad5,0x8(%esp)
  807020:	00 
  807021:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  807028:	00 
  807029:	c7 04 24 9a 2a 81 00 	movl   $0x812a9a,(%esp)
  807030:	e8 4b 7e 00 00       	call   80ee80 <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  807035:	66 29 f8             	sub    %di,%ax
  807038:	66 a3 44 54 b3 00    	mov    %ax,0xb35444

  return pbufs_freed;
}
  80703e:	89 f8                	mov    %edi,%eax
  807040:	83 c4 2c             	add    $0x2c,%esp
  807043:	5b                   	pop    %ebx
  807044:	5e                   	pop    %esi
  807045:	5f                   	pop    %edi
  807046:	5d                   	pop    %ebp
  807047:	c3                   	ret    

00807048 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  807048:	55                   	push   %ebp
  807049:	89 e5                	mov    %esp,%ebp
  80704b:	57                   	push   %edi
  80704c:	56                   	push   %esi
  80704d:	53                   	push   %ebx
  80704e:	83 ec 1c             	sub    $0x1c,%esp
  807051:	89 c3                	mov    %eax,%ebx
  807053:	89 55 e0             	mov    %edx,-0x20(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  807056:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  80705d:	8b 0d 40 54 b3 00    	mov    0xb35440,%ecx
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  807063:	be 00 00 00 00       	mov    $0x0,%esi

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  807068:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  80706d:	b8 00 00 00 00       	mov    $0x0,%eax
  807072:	89 55 dc             	mov    %edx,-0x24(%ebp)
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  807075:	eb 39                	jmp    8070b0 <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  807077:	8b 53 0c             	mov    0xc(%ebx),%edx
  80707a:	39 51 14             	cmp    %edx,0x14(%ecx)
  80707d:	75 11                	jne    807090 <ip_reass_remove_oldest_datagram+0x48>
  80707f:	8b 7b 10             	mov    0x10(%ebx),%edi
  807082:	39 79 18             	cmp    %edi,0x18(%ecx)
  807085:	75 09                	jne    807090 <ip_reass_remove_oldest_datagram+0x48>
  807087:	8b 53 04             	mov    0x4(%ebx),%edx
  80708a:	66 39 51 0c          	cmp    %dx,0xc(%ecx)
  80708e:	74 15                	je     8070a5 <ip_reass_remove_oldest_datagram+0x5d>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  807090:	46                   	inc    %esi
        if (oldest == NULL) {
  807091:	85 c0                	test   %eax,%eax
  807093:	74 0a                	je     80709f <ip_reass_remove_oldest_datagram+0x57>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  807095:	8a 50 1f             	mov    0x1f(%eax),%dl
  807098:	38 51 1f             	cmp    %dl,0x1f(%ecx)
  80709b:	76 06                	jbe    8070a3 <ip_reass_remove_oldest_datagram+0x5b>
  80709d:	eb 06                	jmp    8070a5 <ip_reass_remove_oldest_datagram+0x5d>
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
  80709f:	89 c8                	mov    %ecx,%eax
  8070a1:	eb 02                	jmp    8070a5 <ip_reass_remove_oldest_datagram+0x5d>
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
  8070a3:	89 c8                	mov    %ecx,%eax
        }
      }
      if (r->next != NULL) {
  8070a5:	8b 39                	mov    (%ecx),%edi
  8070a7:	85 ff                	test   %edi,%edi
  8070a9:	74 03                	je     8070ae <ip_reass_remove_oldest_datagram+0x66>
        prev = r;
  8070ab:	89 4d dc             	mov    %ecx,-0x24(%ebp)
      }
      r = r->next;
  8070ae:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  8070b0:	85 c9                	test   %ecx,%ecx
  8070b2:	75 c3                	jne    807077 <ip_reass_remove_oldest_datagram+0x2f>
  8070b4:	8b 55 dc             	mov    -0x24(%ebp),%edx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  8070b7:	85 c0                	test   %eax,%eax
  8070b9:	74 08                	je     8070c3 <ip_reass_remove_oldest_datagram+0x7b>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  8070bb:	e8 60 fe ff ff       	call   806f20 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  8070c0:	01 45 e4             	add    %eax,-0x1c(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  8070c3:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8070c6:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8070c9:	7d 05                	jge    8070d0 <ip_reass_remove_oldest_datagram+0x88>
  8070cb:	83 fe 01             	cmp    $0x1,%esi
  8070ce:	7f 8d                	jg     80705d <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  8070d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8070d3:	83 c4 1c             	add    $0x1c,%esp
  8070d6:	5b                   	pop    %ebx
  8070d7:	5e                   	pop    %esi
  8070d8:	5f                   	pop    %edi
  8070d9:	5d                   	pop    %ebp
  8070da:	c3                   	ret    

008070db <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  8070db:	55                   	push   %ebp
  8070dc:	89 e5                	mov    %esp,%ebp
  8070de:	56                   	push   %esi
  8070df:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  8070e0:	a1 40 54 b3 00       	mov    0xb35440,%eax
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  8070e5:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
  8070ea:	eb 1c                	jmp    807108 <ip_reass_tmr+0x2d>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  8070ec:	8a 50 1f             	mov    0x1f(%eax),%dl
  8070ef:	84 d2                	test   %dl,%dl
  8070f1:	74 0a                	je     8070fd <ip_reass_tmr+0x22>
      r->timer--;
  8070f3:	4a                   	dec    %edx
  8070f4:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  8070f7:	89 c3                	mov    %eax,%ebx
      r = r->next;
  8070f9:	8b 00                	mov    (%eax),%eax
  8070fb:	eb 0b                	jmp    807108 <ip_reass_tmr+0x2d>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  8070fd:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  8070ff:	89 da                	mov    %ebx,%edx
  807101:	e8 1a fe ff ff       	call   806f20 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  807106:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  807108:	85 c0                	test   %eax,%eax
  80710a:	75 e0                	jne    8070ec <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  80710c:	5b                   	pop    %ebx
  80710d:	5e                   	pop    %esi
  80710e:	5d                   	pop    %ebp
  80710f:	c3                   	ret    

00807110 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  807110:	55                   	push   %ebp
  807111:	89 e5                	mov    %esp,%ebp
  807113:	57                   	push   %edi
  807114:	56                   	push   %esi
  807115:	53                   	push   %ebx
  807116:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  807119:	8b 45 08             	mov    0x8(%ebp),%eax
  80711c:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  80711f:	0f b7 03             	movzwl (%ebx),%eax
  807122:	89 04 24             	mov    %eax,(%esp)
  807125:	e8 3b 0b 00 00       	call   807c65 <ntohs>
  80712a:	c1 e8 06             	shr    $0x6,%eax
  80712d:	83 e0 3c             	and    $0x3c,%eax
  807130:	83 f8 14             	cmp    $0x14,%eax
  807133:	0f 85 67 04 00 00    	jne    8075a0 <ip_reass+0x490>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  807139:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80713d:	89 04 24             	mov    %eax,(%esp)
  807140:	e8 20 0b 00 00       	call   807c65 <ntohs>
  807145:	89 c7                	mov    %eax,%edi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  807147:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80714b:	89 04 24             	mov    %eax,(%esp)
  80714e:	e8 12 0b 00 00       	call   807c65 <ntohs>
  807153:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  807157:	0f b7 03             	movzwl (%ebx),%eax
  80715a:	89 04 24             	mov    %eax,(%esp)
  80715d:	e8 03 0b 00 00       	call   807c65 <ntohs>
  807162:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  807166:	8b 55 08             	mov    0x8(%ebp),%edx
  807169:	89 14 24             	mov    %edx,(%esp)
  80716c:	e8 67 e0 ff ff       	call   8051d8 <pbuf_clen>
  807171:	88 45 e0             	mov    %al,-0x20(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  807174:	0f b6 c8             	movzbl %al,%ecx
  807177:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80717a:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  807181:	01 c8                	add    %ecx,%eax
  807183:	83 f8 0a             	cmp    $0xa,%eax
  807186:	7e 24                	jle    8071ac <ip_reass+0x9c>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  807188:	89 ca                	mov    %ecx,%edx
  80718a:	89 d8                	mov    %ebx,%eax
  80718c:	e8 b7 fe ff ff       	call   807048 <ip_reass_remove_oldest_datagram>
  807191:	85 c0                	test   %eax,%eax
  807193:	0f 84 07 04 00 00    	je     8075a0 <ip_reass+0x490>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  807199:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  8071a0:	03 45 dc             	add    -0x24(%ebp),%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  8071a3:	83 f8 0a             	cmp    $0xa,%eax
  8071a6:	0f 8f f4 03 00 00    	jg     8075a0 <ip_reass+0x490>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8071ac:	8b 35 40 54 b3 00    	mov    0xb35440,%esi
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  8071b2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8071b9:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8071be:	eb 21                	jmp    8071e1 <ip_reass+0xd1>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  8071c0:	8b 53 0c             	mov    0xc(%ebx),%edx
  8071c3:	39 56 14             	cmp    %edx,0x14(%esi)
  8071c6:	75 15                	jne    8071dd <ip_reass+0xcd>
  8071c8:	8b 4b 10             	mov    0x10(%ebx),%ecx
  8071cb:	39 4e 18             	cmp    %ecx,0x18(%esi)
  8071ce:	75 0d                	jne    8071dd <ip_reass+0xcd>
  8071d0:	8b 53 04             	mov    0x4(%ebx),%edx
  8071d3:	66 39 56 0c          	cmp    %dx,0xc(%esi)
  8071d7:	0f 84 88 00 00 00    	je     807265 <ip_reass+0x155>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8071dd:	89 f0                	mov    %esi,%eax
  8071df:	8b 36                	mov    (%esi),%esi
  8071e1:	85 f6                	test   %esi,%esi
  8071e3:	75 db                	jne    8071c0 <ip_reass+0xb0>
  8071e5:	89 45 d8             	mov    %eax,-0x28(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  8071e8:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  8071ef:	e8 72 d7 ff ff       	call   804966 <memp_malloc>
  8071f4:	89 c6                	mov    %eax,%esi
  if (ipr == NULL) {
  8071f6:	85 c0                	test   %eax,%eax
  8071f8:	75 29                	jne    807223 <ip_reass+0x113>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  8071fa:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8071fd:	89 d8                	mov    %ebx,%eax
  8071ff:	e8 44 fe ff ff       	call   807048 <ip_reass_remove_oldest_datagram>
  807204:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  807207:	0f 8f 93 03 00 00    	jg     8075a0 <ip_reass+0x490>
      ipr = memp_malloc(MEMP_REASSDATA);
  80720d:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807214:	e8 4d d7 ff ff       	call   804966 <memp_malloc>
  807219:	89 c6                	mov    %eax,%esi
    }
    if (ipr == NULL)
  80721b:	85 c0                	test   %eax,%eax
  80721d:	0f 84 7d 03 00 00    	je     8075a0 <ip_reass+0x490>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  807223:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80722a:	00 
  80722b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807232:	00 
  807233:	89 34 24             	mov    %esi,(%esp)
  807236:	e8 17 84 00 00       	call   80f652 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80723b:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  80723f:	a1 40 54 b3 00       	mov    0xb35440,%eax
  807244:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  807246:	89 35 40 54 b3 00    	mov    %esi,0xb35440
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80724c:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  807253:	00 
  807254:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  807258:	8d 46 08             	lea    0x8(%esi),%eax
  80725b:	89 04 24             	mov    %eax,(%esp)
  80725e:	e8 a3 84 00 00       	call   80f706 <memcpy>
  807263:	eb 46                	jmp    8072ab <ip_reass+0x19b>
  807265:	89 45 d8             	mov    %eax,-0x28(%ebp)
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  807268:	89 75 dc             	mov    %esi,-0x24(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80726b:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80726f:	89 04 24             	mov    %eax,(%esp)
  807272:	e8 ee 09 00 00       	call   807c65 <ntohs>
  807277:	a9 ff 1f 00 00       	test   $0x1fff,%eax
  80727c:	75 2d                	jne    8072ab <ip_reass+0x19b>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  80727e:	0f b7 46 0e          	movzwl 0xe(%esi),%eax
  807282:	89 04 24             	mov    %eax,(%esp)
  807285:	e8 db 09 00 00       	call   807c65 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80728a:	a9 ff 1f 00 00       	test   $0x1fff,%eax
  80728f:	74 1a                	je     8072ab <ip_reass+0x19b>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  807291:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  807298:	00 
  807299:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80729d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8072a0:	83 c0 08             	add    $0x8,%eax
  8072a3:	89 04 24             	mov    %eax,(%esp)
  8072a6:	e8 5b 84 00 00       	call   80f706 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  8072ab:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  8072af:	66 01 05 44 54 b3 00 	add    %ax,0xb35444

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  8072b6:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8072ba:	89 04 24             	mov    %eax,(%esp)
  8072bd:	e8 a3 09 00 00       	call   807c65 <ntohs>
  8072c2:	f6 c4 20             	test   $0x20,%ah
  8072c5:	75 1d                	jne    8072e4 <ip_reass+0x1d4>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  8072c7:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8072cb:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  8072ce:	8d 04 f9             	lea    (%ecx,%edi,8),%eax
  8072d1:	8b 7d d0             	mov    -0x30(%ebp),%edi
  8072d4:	66 c1 ef 08          	shr    $0x8,%di
  8072d8:	83 e7 0f             	and    $0xf,%edi
  8072db:	f7 df                	neg    %edi
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    ipr->datagram_len = offset + len;
  8072dd:	8d 3c b8             	lea    (%eax,%edi,4),%edi
  8072e0:	66 89 7e 1c          	mov    %di,0x1c(%esi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  8072e4:	8b 45 08             	mov    0x8(%ebp),%eax
  8072e7:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8072ea:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  8072ee:	89 04 24             	mov    %eax,(%esp)
  8072f1:	e8 6f 09 00 00       	call   807c65 <ntohs>
  8072f6:	89 c7                	mov    %eax,%edi
  8072f8:	0f b7 03             	movzwl (%ebx),%eax
  8072fb:	89 04 24             	mov    %eax,(%esp)
  8072fe:	e8 62 09 00 00       	call   807c65 <ntohs>
  807303:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  807307:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80730b:	89 04 24             	mov    %eax,(%esp)
  80730e:	e8 52 09 00 00       	call   807c65 <ntohs>
  807313:	c1 e0 03             	shl    $0x3,%eax
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  807316:	8b 55 08             	mov    0x8(%ebp),%edx
  807319:	8b 52 04             	mov    0x4(%edx),%edx
  80731c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  80731f:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  807325:	66 89 42 04          	mov    %ax,0x4(%edx)
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  807329:	01 c7                	add    %eax,%edi
  80732b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80732e:	66 c1 ea 08          	shr    $0x8,%dx
  807332:	83 e2 0f             	and    $0xf,%edx
  807335:	f7 da                	neg    %edx
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
  iprh->end = offset + len;
  807337:	8d 14 97             	lea    (%edi,%edx,4),%edx
  80733a:	66 89 55 dc          	mov    %dx,-0x24(%ebp)
  80733e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807341:	66 89 51 06          	mov    %dx,0x6(%ecx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  807345:	8b 56 04             	mov    0x4(%esi),%edx
  807348:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  80734b:	89 d3                	mov    %edx,%ebx
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  80734d:	b9 01 00 00 00       	mov    $0x1,%ecx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  807352:	bf 00 00 00 00       	mov    $0x0,%edi
  807357:	89 75 d0             	mov    %esi,-0x30(%ebp)
  80735a:	89 ce                	mov    %ecx,%esi
  80735c:	eb 71                	jmp    8073cf <ip_reass+0x2bf>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80735e:	8b 53 04             	mov    0x4(%ebx),%edx
    if (iprh->start < iprh_tmp->start) {
  807361:	8b 4a 04             	mov    0x4(%edx),%ecx
  807364:	66 39 c8             	cmp    %cx,%ax
  807367:	73 40                	jae    8073a9 <ip_reass+0x299>
  807369:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80736c:	89 f1                	mov    %esi,%ecx
  80736e:	8b 75 d0             	mov    -0x30(%ebp),%esi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  807371:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807374:	89 1a                	mov    %ebx,(%edx)
      if (iprh_prev != NULL) {
  807376:	85 ff                	test   %edi,%edi
  807378:	74 24                	je     80739e <ip_reass+0x28e>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80737a:	66 3b 47 06          	cmp    0x6(%edi),%ax
  80737e:	0f 82 93 01 00 00    	jb     807517 <ip_reass+0x407>
  807384:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807387:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80738a:	66 3b 50 04          	cmp    0x4(%eax),%dx
  80738e:	0f 87 83 01 00 00    	ja     807517 <ip_reass+0x407>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  807394:	8b 45 08             	mov    0x8(%ebp),%eax
  807397:	89 07                	mov    %eax,(%edi)
  807399:	e9 a2 00 00 00       	jmp    807440 <ip_reass+0x330>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  80739e:	8b 55 08             	mov    0x8(%ebp),%edx
  8073a1:	89 56 04             	mov    %edx,0x4(%esi)
  8073a4:	e9 97 00 00 00       	jmp    807440 <ip_reass+0x330>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  8073a9:	66 39 c8             	cmp    %cx,%ax
  8073ac:	0f 84 65 01 00 00    	je     807517 <ip_reass+0x407>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  8073b2:	66 3b 42 06          	cmp    0x6(%edx),%ax
  8073b6:	0f 82 5b 01 00 00    	jb     807517 <ip_reass+0x407>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  8073bc:	85 ff                	test   %edi,%edi
  8073be:	74 0b                	je     8073cb <ip_reass+0x2bb>
        if (iprh_prev->end != iprh_tmp->start) {
  8073c0:	66 3b 4f 06          	cmp    0x6(%edi),%cx
  8073c4:	74 05                	je     8073cb <ip_reass+0x2bb>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  8073c6:	be 00 00 00 00       	mov    $0x0,%esi
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  8073cb:	8b 1a                	mov    (%edx),%ebx
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  8073cd:	89 d7                	mov    %edx,%edi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  8073cf:	85 db                	test   %ebx,%ebx
  8073d1:	75 8b                	jne    80735e <ip_reass+0x24e>
  8073d3:	e9 09 02 00 00       	jmp    8075e1 <ip_reass+0x4d1>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8073d8:	66 8b 47 06          	mov    0x6(%edi),%ax
  8073dc:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8073df:	66 3b 42 04          	cmp    0x4(%edx),%ax
  8073e3:	76 1c                	jbe    807401 <ip_reass+0x2f1>
  8073e5:	c7 44 24 08 f0 2a 81 	movl   $0x812af0,0x8(%esp)
  8073ec:	00 
  8073ed:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  8073f4:	00 
  8073f5:	c7 04 24 9a 2a 81 00 	movl   $0x812a9a,(%esp)
  8073fc:	e8 7f 7a 00 00       	call   80ee80 <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  807401:	8b 55 08             	mov    0x8(%ebp),%edx
  807404:	89 17                	mov    %edx,(%edi)
      if (iprh_prev->end != iprh->start) {
  807406:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807409:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80740d:	75 2c                	jne    80743b <ip_reass+0x32b>
  80740f:	eb 2f                	jmp    807440 <ip_reass+0x330>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  807411:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807415:	74 1c                	je     807433 <ip_reass+0x323>
  807417:	c7 44 24 08 1c 2b 81 	movl   $0x812b1c,0x8(%esp)
  80741e:	00 
  80741f:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  807426:	00 
  807427:	c7 04 24 9a 2a 81 00 	movl   $0x812a9a,(%esp)
  80742e:	e8 4d 7a 00 00       	call   80ee80 <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  807433:	8b 45 08             	mov    0x8(%ebp),%eax
  807436:	89 46 04             	mov    %eax,0x4(%esi)
  807439:	eb 05                	jmp    807440 <ip_reass+0x330>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
      if (iprh_prev->end != iprh->start) {
        valid = 0;
  80743b:	b9 00 00 00 00       	mov    $0x0,%ecx
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  807440:	f6 46 1e 01          	testb  $0x1,0x1e(%esi)
  807444:	0f 84 6a 01 00 00    	je     8075b4 <ip_reass+0x4a4>
    /* and had no wholes so far */
    if (valid) {
  80744a:	85 c9                	test   %ecx,%ecx
  80744c:	0f 84 6b 01 00 00    	je     8075bd <ip_reass+0x4ad>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  807452:	8b 4e 04             	mov    0x4(%esi),%ecx
  807455:	8b 59 04             	mov    0x4(%ecx),%ebx
  807458:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  80745d:	0f 85 63 01 00 00    	jne    8075c6 <ip_reass+0x4b6>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  807463:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807466:	8b 10                	mov    (%eax),%edx
  807468:	89 c7                	mov    %eax,%edi
  80746a:	eb 14                	jmp    807480 <ip_reass+0x370>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80746c:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  80746f:	8b 50 04             	mov    0x4(%eax),%edx
  807472:	66 39 57 06          	cmp    %dx,0x6(%edi)
  807476:	0f 85 53 01 00 00    	jne    8075cf <ip_reass+0x4bf>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80747c:	8b 10                	mov    (%eax),%edx
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80747e:	89 c7                	mov    %eax,%edi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  807480:	85 d2                	test   %edx,%edx
  807482:	75 e8                	jne    80746c <ip_reass+0x35c>
  807484:	e9 6a 01 00 00       	jmp    8075f3 <ip_reass+0x4e3>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  807489:	c7 44 24 08 0e 2b 81 	movl   $0x812b0e,0x8(%esp)
  807490:	00 
  807491:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  807498:	00 
  807499:	c7 04 24 9a 2a 81 00 	movl   $0x812a9a,(%esp)
  8074a0:	e8 db 79 00 00       	call   80ee80 <_panic>
          LWIP_ASSERT("sanity check",
  8074a5:	39 5d e0             	cmp    %ebx,-0x20(%ebp)
  8074a8:	75 1c                	jne    8074c6 <ip_reass+0x3b6>
  8074aa:	c7 44 24 08 0e 2b 81 	movl   $0x812b0e,0x8(%esp)
  8074b1:	00 
  8074b2:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  8074b9:	00 
  8074ba:	c7 04 24 9a 2a 81 00 	movl   $0x812a9a,(%esp)
  8074c1:	e8 ba 79 00 00       	call   80ee80 <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8074c6:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8074c9:	83 39 00             	cmpl   $0x0,(%ecx)
  8074cc:	74 1c                	je     8074ea <ip_reass+0x3da>
  8074ce:	c7 44 24 08 54 2b 81 	movl   $0x812b54,0x8(%esp)
  8074d5:	00 
  8074d6:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  8074dd:	00 
  8074de:	c7 04 24 9a 2a 81 00 	movl   $0x812a9a,(%esp)
  8074e5:	e8 96 79 00 00       	call   80ee80 <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8074ea:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8074ed:	66 8b 42 06          	mov    0x6(%edx),%ax
  8074f1:	66 3b 46 1c          	cmp    0x1c(%esi),%ax
  8074f5:	0f 84 08 01 00 00    	je     807603 <ip_reass+0x4f3>
  8074fb:	c7 44 24 08 78 2b 81 	movl   $0x812b78,0x8(%esp)
  807502:	00 
  807503:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80750a:	00 
  80750b:	c7 04 24 9a 2a 81 00 	movl   $0x812a9a,(%esp)
  807512:	e8 69 79 00 00       	call   80ee80 <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  807517:	66 8b 1d 44 54 b3 00 	mov    0xb35444,%bx
  80751e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807521:	89 0c 24             	mov    %ecx,(%esp)
  807524:	e8 af dc ff ff       	call   8051d8 <pbuf_clen>
  807529:	0f b6 c0             	movzbl %al,%eax
  80752c:	66 29 c3             	sub    %ax,%bx
  80752f:	66 89 1d 44 54 b3 00 	mov    %bx,0xb35444
  pbuf_free(new_p);
  807536:	8b 45 08             	mov    0x8(%ebp),%eax
  807539:	89 04 24             	mov    %eax,(%esp)
  80753c:	e8 10 d8 ff ff       	call   804d51 <pbuf_free>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  807541:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  807548:	e9 89 00 00 00       	jmp    8075d6 <ip_reass+0x4c6>

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  80754d:	8b 5f 04             	mov    0x4(%edi),%ebx

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  807550:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  807557:	ff 
  807558:	89 3c 24             	mov    %edi,(%esp)
  80755b:	e8 0c d7 ff ff       	call   804c6c <pbuf_header>
      pbuf_cat(p, r);
  807560:	89 7c 24 04          	mov    %edi,0x4(%esp)
  807564:	89 34 24             	mov    %esi,(%esp)
  807567:	e8 8f dc ff ff       	call   8051fb <pbuf_cat>
      r = iprh->next_pbuf;
  80756c:	8b 3b                	mov    (%ebx),%edi
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80756e:	85 ff                	test   %edi,%edi
  807570:	75 db                	jne    80754d <ip_reass+0x43d>
  807572:	8b 75 e0             	mov    -0x20(%ebp),%esi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  807575:	8b 55 d8             	mov    -0x28(%ebp),%edx
  807578:	89 f0                	mov    %esi,%eax
  80757a:	e8 51 f9 ff ff       	call   806ed0 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  80757f:	66 8b 1d 44 54 b3 00 	mov    0xb35444,%bx
  807586:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807589:	89 04 24             	mov    %eax,(%esp)
  80758c:	e8 47 dc ff ff       	call   8051d8 <pbuf_clen>
  807591:	0f b6 c0             	movzbl %al,%eax
  807594:	66 29 c3             	sub    %ax,%bx
  807597:	66 89 1d 44 54 b3 00 	mov    %bx,0xb35444

    /* Return the pbuf chain */
    return p;
  80759e:	eb 36                	jmp    8075d6 <ip_reass+0x4c6>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  8075a0:	8b 55 08             	mov    0x8(%ebp),%edx
  8075a3:	89 14 24             	mov    %edx,(%esp)
  8075a6:	e8 a6 d7 ff ff       	call   804d51 <pbuf_free>
  return NULL;
  8075ab:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8075b2:	eb 22                	jmp    8075d6 <ip_reass+0x4c6>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  8075b4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8075bb:	eb 19                	jmp    8075d6 <ip_reass+0x4c6>
  8075bd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8075c4:	eb 10                	jmp    8075d6 <ip_reass+0x4c6>
  8075c6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8075cd:	eb 07                	jmp    8075d6 <ip_reass+0x4c6>
  8075cf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  8075d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8075d9:	83 c4 3c             	add    $0x3c,%esp
  8075dc:	5b                   	pop    %ebx
  8075dd:	5e                   	pop    %esi
  8075de:	5f                   	pop    %edi
  8075df:	5d                   	pop    %ebp
  8075e0:	c3                   	ret    
  8075e1:	89 f1                	mov    %esi,%ecx
  8075e3:	8b 75 d0             	mov    -0x30(%ebp),%esi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  8075e6:	85 ff                	test   %edi,%edi
  8075e8:	0f 85 ea fd ff ff    	jne    8073d8 <ip_reass+0x2c8>
  8075ee:	e9 1e fe ff ff       	jmp    807411 <ip_reass+0x301>
  8075f3:	89 7d e0             	mov    %edi,-0x20(%ebp)
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  8075f6:	85 c9                	test   %ecx,%ecx
  8075f8:	0f 85 a7 fe ff ff    	jne    8074a5 <ip_reass+0x395>
  8075fe:	e9 86 fe ff ff       	jmp    807489 <ip_reass+0x379>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  807603:	83 c0 14             	add    $0x14,%eax
  807606:	66 89 46 1c          	mov    %ax,0x1c(%esi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80760a:	8b 46 04             	mov    0x4(%esi),%eax
  80760d:	8b 58 04             	mov    0x4(%eax),%ebx
  807610:	8b 3b                	mov    (%ebx),%edi

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  807612:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  807619:	00 
  80761a:	8d 46 08             	lea    0x8(%esi),%eax
  80761d:	89 44 24 04          	mov    %eax,0x4(%esp)
  807621:	89 1c 24             	mov    %ebx,(%esp)
  807624:	e8 dd 80 00 00       	call   80f706 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  807629:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80762d:	89 04 24             	mov    %eax,(%esp)
  807630:	e8 24 06 00 00       	call   807c59 <htons>
  807635:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(fraghdr, 0);
  807639:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_CHKSUM_SET(fraghdr, 0);
  80763f:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  807645:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80764c:	00 
  80764d:	89 1c 24             	mov    %ebx,(%esp)
  807650:	e8 ce 04 00 00       	call   807b23 <inet_chksum>
  807655:	66 89 43 0a          	mov    %ax,0xa(%ebx)

    p = ipr->p;
  807659:	8b 46 04             	mov    0x4(%esi),%eax
  80765c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80765f:	89 75 e0             	mov    %esi,-0x20(%ebp)
  807662:	89 c6                	mov    %eax,%esi

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807664:	e9 05 ff ff ff       	jmp    80756e <ip_reass+0x45e>

00807669 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807669:	55                   	push   %ebp
  80766a:	89 e5                	mov    %esp,%ebp
  80766c:	57                   	push   %edi
  80766d:	56                   	push   %esi
  80766e:	53                   	push   %ebx
  80766f:	83 ec 4c             	sub    $0x4c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  807672:	8b 45 0c             	mov    0xc(%ebp),%eax
  807675:	8b 70 2c             	mov    0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807678:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80767f:	00 
  807680:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807687:	00 
  807688:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80768f:	e8 be d8 ff ff       	call   804f52 <pbuf_alloc>
  807694:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (rambuf == NULL) {
  807697:	85 c0                	test   %eax,%eax
  807699:	0f 84 d2 01 00 00    	je     807871 <ip_frag+0x208>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  80769f:	66 89 70 0a          	mov    %si,0xa(%eax)
  8076a3:	66 89 70 08          	mov    %si,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8076a7:	b8 63 54 b3 00       	mov    $0xb35463,%eax
  8076ac:	83 e0 fc             	and    $0xfffffffc,%eax
  8076af:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8076b2:	8b 55 d8             	mov    -0x28(%ebp),%edx
  8076b5:	89 42 04             	mov    %eax,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8076b8:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8076bf:	00 
  8076c0:	8b 55 08             	mov    0x8(%ebp),%edx
  8076c3:	8b 42 04             	mov    0x4(%edx),%eax
  8076c6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8076ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8076cd:	89 04 24             	mov    %eax,(%esp)
  8076d0:	e8 31 80 00 00       	call   80f706 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8076d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8076d8:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  8076dc:	89 04 24             	mov    %eax,(%esp)
  8076df:	e8 81 05 00 00       	call   807c65 <ntohs>
  ofo = tmp & IP_OFFMASK;
  8076e4:	89 c2                	mov    %eax,%edx
  8076e6:	81 e2 ff 1f 00 00    	and    $0x1fff,%edx
  8076ec:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
  omf = tmp & IP_MF;
  8076f0:	25 00 20 00 00       	and    $0x2000,%eax
  8076f5:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)

  left = p->tot_len - IP_HLEN;
  8076f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8076fc:	8b 58 08             	mov    0x8(%eax),%ebx
  8076ff:	83 eb 14             	sub    $0x14,%ebx

  nfb = (mtu - IP_HLEN) / 8;
  807702:	0f b7 f6             	movzwl %si,%esi
  807705:	83 ee 14             	sub    $0x14,%esi
  807708:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  80770b:	89 f0                	mov    %esi,%eax
  80770d:	85 f6                	test   %esi,%esi
  80770f:	79 03                	jns    807714 <ip_frag+0xab>
  807711:	8d 46 07             	lea    0x7(%esi),%eax
  807714:	c1 e8 03             	shr    $0x3,%eax
  807717:	66 89 45 b8          	mov    %ax,-0x48(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  80771b:	66 c7 45 e0 14 00    	movw   $0x14,-0x20(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807721:	c1 e0 03             	shl    $0x3,%eax
  807724:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807728:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80772b:	83 c2 14             	add    $0x14,%edx
  80772e:	89 55 cc             	mov    %edx,-0x34(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807731:	e9 23 01 00 00       	jmp    807859 <ip_frag+0x1f0>
    last = (left <= mtu - IP_HLEN);
  807736:	0f b7 c3             	movzwl %bx,%eax
  807739:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80773c:	0f 9d c0             	setge  %al
  80773f:	0f b6 f8             	movzbl %al,%edi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  807742:	66 8b 45 e2          	mov    -0x1e(%ebp),%ax
  807746:	25 ff 1f 00 00       	and    $0x1fff,%eax
  80774b:	66 0b 45 d2          	or     -0x2e(%ebp),%ax
  80774f:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    if (!last)
  807753:	66 85 ff             	test   %di,%di
  807756:	75 0c                	jne    807764 <ip_frag+0xfb>
      tmp = tmp | IP_MF;
  807758:	80 cc 20             	or     $0x20,%ah
  80775b:	66 89 45 de          	mov    %ax,-0x22(%ebp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80775f:	8b 75 d0             	mov    -0x30(%ebp),%esi
  807762:	eb 02                	jmp    807766 <ip_frag+0xfd>
  807764:	89 de                	mov    %ebx,%esi

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807766:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80776a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80776e:	0f b7 c6             	movzwl %si,%eax
  807771:	89 44 24 08          	mov    %eax,0x8(%esp)
  807775:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807778:	89 44 24 04          	mov    %eax,0x4(%esp)
  80777c:	8b 55 08             	mov    0x8(%ebp),%edx
  80777f:	89 14 24             	mov    %edx,(%esp)
  807782:	e8 60 dd ff ff       	call   8054e7 <pbuf_copy_partial>
  807787:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  80778b:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  80778f:	89 04 24             	mov    %eax,(%esp)
  807792:	e8 c2 04 00 00       	call   807c59 <htons>
  807797:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80779a:	66 89 42 06          	mov    %ax,0x6(%edx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80779e:	8d 46 14             	lea    0x14(%esi),%eax
  8077a1:	0f b7 c0             	movzwl %ax,%eax
  8077a4:	89 04 24             	mov    %eax,(%esp)
  8077a7:	e8 ad 04 00 00       	call   807c59 <htons>
  8077ac:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8077af:	66 89 42 02          	mov    %ax,0x2(%edx)
    IPH_CHKSUM_SET(iphdr, 0);
  8077b3:	66 c7 42 0a 00 00    	movw   $0x0,0xa(%edx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8077b9:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8077c0:	00 
  8077c1:	89 14 24             	mov    %edx,(%esp)
  8077c4:	e8 5a 03 00 00       	call   807b23 <inet_chksum>
  8077c9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8077cc:	66 89 42 0a          	mov    %ax,0xa(%edx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  8077d0:	66 85 ff             	test   %di,%di
  8077d3:	74 15                	je     8077ea <ip_frag+0x181>
      pbuf_realloc(rambuf, left + IP_HLEN);
  8077d5:	8d 43 14             	lea    0x14(%ebx),%eax
  8077d8:	0f b7 c0             	movzwl %ax,%eax
  8077db:	89 44 24 04          	mov    %eax,0x4(%esp)
  8077df:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8077e2:	89 04 24             	mov    %eax,(%esp)
  8077e5:	e8 39 d6 ff ff       	call   804e23 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8077ea:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8077f1:	00 
  8077f2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8077f9:	00 
  8077fa:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  807801:	e8 4c d7 ff ff       	call   804f52 <pbuf_alloc>
  807806:	89 c7                	mov    %eax,%edi
    if (header != NULL) {
  807808:	85 c0                	test   %eax,%eax
  80780a:	74 3e                	je     80784a <ip_frag+0x1e1>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80780c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80780f:	66 01 45 e0          	add    %ax,-0x20(%ebp)
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
      pbuf_chain(header, rambuf);
  807813:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807816:	89 44 24 04          	mov    %eax,0x4(%esp)
  80781a:	89 3c 24             	mov    %edi,(%esp)
  80781d:	e8 4d da ff ff       	call   80526f <pbuf_chain>
      netif->output(netif, header, dest);
  807822:	8b 55 10             	mov    0x10(%ebp),%edx
  807825:	89 54 24 08          	mov    %edx,0x8(%esp)
  807829:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80782d:	8b 45 0c             	mov    0xc(%ebp),%eax
  807830:	89 04 24             	mov    %eax,(%esp)
  807833:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  807836:	89 3c 24             	mov    %edi,(%esp)
  807839:	e8 13 d5 ff ff       	call   804d51 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  80783e:	66 29 f3             	sub    %si,%bx
    ofo += nfb;
  807841:	8b 45 b8             	mov    -0x48(%ebp),%eax
  807844:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
  807848:	eb 0f                	jmp    807859 <ip_frag+0x1f0>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80784a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80784d:	89 04 24             	mov    %eax,(%esp)
  807850:	e8 fc d4 ff ff       	call   804d51 <pbuf_free>
      return ERR_MEM;
  807855:	b0 ff                	mov    $0xff,%al
  807857:	eb 1a                	jmp    807873 <ip_frag+0x20a>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807859:	66 85 db             	test   %bx,%bx
  80785c:	0f 85 d4 fe ff ff    	jne    807736 <ip_frag+0xcd>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  807862:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807865:	89 04 24             	mov    %eax,(%esp)
  807868:	e8 e4 d4 ff ff       	call   804d51 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  80786d:	b0 00                	mov    $0x0,%al
  80786f:	eb 02                	jmp    807873 <ip_frag+0x20a>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  807871:	b0 ff                	mov    $0xff,%al
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  807873:	83 c4 4c             	add    $0x4c,%esp
  807876:	5b                   	pop    %ebx
  807877:	5e                   	pop    %esi
  807878:	5f                   	pop    %edi
  807879:	5d                   	pop    %ebp
  80787a:	c3                   	ret    
	...

0080787c <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80787c:	55                   	push   %ebp
  80787d:	89 e5                	mov    %esp,%ebp
  80787f:	57                   	push   %edi
  807880:	56                   	push   %esi
  807881:	53                   	push   %ebx
  807882:	83 ec 2c             	sub    $0x2c,%esp
  807885:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  807888:	89 d0                	mov    %edx,%eax
  80788a:	66 d1 e8             	shr    %ax
  80788d:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  807891:	0f b7 c0             	movzwl %ax,%eax
  807894:	d1 e0                	shl    %eax
  807896:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807899:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80789c:	01 c7                	add    %eax,%edi
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  80789e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8078a1:	b9 00 00 00 00       	mov    $0x0,%ecx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8078a6:	eb 14                	jmp    8078bc <lwip_standard_chksum+0x40>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8078a8:	0f b6 30             	movzbl (%eax),%esi
  8078ab:	c1 e6 08             	shl    $0x8,%esi
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  8078ae:	0f b6 58 01          	movzbl 0x1(%eax),%ebx
  8078b2:	09 f3                	or     %esi,%ebx
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  8078b4:	83 c0 02             	add    $0x2,%eax
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  8078b7:	0f b7 db             	movzwl %bx,%ebx
  8078ba:	01 d9                	add    %ebx,%ecx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8078bc:	39 f8                	cmp    %edi,%eax
  8078be:	75 e8                	jne    8078a8 <lwip_standard_chksum+0x2c>
  8078c0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8078c3:	03 5d dc             	add    -0x24(%ebp),%ebx
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  8078c6:	66 8b 45 e2          	mov    -0x1e(%ebp),%ax
  8078ca:	f7 d8                	neg    %eax
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  8078cc:	8d 14 42             	lea    (%edx,%eax,2),%edx
  8078cf:	66 85 d2             	test   %dx,%dx
  8078d2:	74 0b                	je     8078df <lwip_standard_chksum+0x63>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8078d4:	0f b6 03             	movzbl (%ebx),%eax
  8078d7:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  8078da:	0f b7 c0             	movzwl %ax,%eax
  8078dd:	01 c1                	add    %eax,%ecx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8078df:	89 c8                	mov    %ecx,%eax
  8078e1:	c1 e8 10             	shr    $0x10,%eax
  8078e4:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  8078ea:	01 c1                	add    %eax,%ecx
  if ((acc & 0xffff0000) != 0) {
  8078ec:	f7 c1 00 00 ff ff    	test   $0xffff0000,%ecx
  8078f2:	74 0d                	je     807901 <lwip_standard_chksum+0x85>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8078f4:	89 c8                	mov    %ecx,%eax
  8078f6:	c1 e8 10             	shr    $0x10,%eax
  8078f9:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  8078ff:	01 c1                	add    %eax,%ecx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807901:	0f b7 c9             	movzwl %cx,%ecx
  807904:	89 0c 24             	mov    %ecx,(%esp)
  807907:	e8 4d 03 00 00       	call   807c59 <htons>
}
  80790c:	83 c4 2c             	add    $0x2c,%esp
  80790f:	5b                   	pop    %ebx
  807910:	5e                   	pop    %esi
  807911:	5f                   	pop    %edi
  807912:	5d                   	pop    %ebp
  807913:	c3                   	ret    

00807914 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807914:	55                   	push   %ebp
  807915:	89 e5                	mov    %esp,%ebp
  807917:	57                   	push   %edi
  807918:	56                   	push   %esi
  807919:	53                   	push   %ebx
  80791a:	83 ec 2c             	sub    $0x2c,%esp
  80791d:	8a 45 14             	mov    0x14(%ebp),%al
  807920:	88 45 e6             	mov    %al,-0x1a(%ebp)
  807923:	8b 7d 18             	mov    0x18(%ebp),%edi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807926:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807929:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  80792d:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807932:	eb 3f                	jmp    807973 <inet_chksum_pseudo+0x5f>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807934:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807938:	8b 43 04             	mov    0x4(%ebx),%eax
  80793b:	e8 3c ff ff ff       	call   80787c <lwip_standard_chksum>
  807940:	0f b7 c0             	movzwl %ax,%eax
  807943:	01 c6                	add    %eax,%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  807945:	89 f0                	mov    %esi,%eax
  807947:	c1 e8 10             	shr    $0x10,%eax
  80794a:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  807950:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807952:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807956:	74 19                	je     807971 <inet_chksum_pseudo+0x5d>
      swapped = 1 - swapped;
  807958:	b2 01                	mov    $0x1,%dl
  80795a:	2a 55 e7             	sub    -0x19(%ebp),%dl
  80795d:	88 55 e7             	mov    %dl,-0x19(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807960:	89 f0                	mov    %esi,%eax
  807962:	c1 e0 08             	shl    $0x8,%eax
  807965:	25 ff ff 00 00       	and    $0xffff,%eax
  80796a:	89 f2                	mov    %esi,%edx
  80796c:	0f b6 f6             	movzbl %dh,%esi
  80796f:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807971:	8b 1b                	mov    (%ebx),%ebx
  807973:	85 db                	test   %ebx,%ebx
  807975:	75 bd                	jne    807934 <inet_chksum_pseudo+0x20>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807977:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80797b:	74 11                	je     80798e <inet_chksum_pseudo+0x7a>
    acc = SWAP_BYTES_IN_WORD(acc);
  80797d:	89 f0                	mov    %esi,%eax
  80797f:	c1 e0 08             	shl    $0x8,%eax
  807982:	25 ff ff 00 00       	and    $0xffff,%eax
  807987:	89 f2                	mov    %esi,%edx
  807989:	0f b6 f6             	movzbl %dh,%esi
  80798c:	09 c6                	or     %eax,%esi
  }
  acc += (src->addr & 0xffffUL);
  80798e:	8b 45 0c             	mov    0xc(%ebp),%eax
  807991:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807993:	8b 45 10             	mov    0x10(%ebp),%eax
  807996:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807998:	89 d1                	mov    %edx,%ecx
  80799a:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80799d:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  8079a3:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8079a5:	0f b7 c8             	movzwl %ax,%ecx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  8079a8:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  8079aa:	c1 e8 10             	shr    $0x10,%eax
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8079ad:	01 d0                	add    %edx,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  8079af:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons((u16_t)proto);
  8079b1:	0f b6 45 e6          	movzbl -0x1a(%ebp),%eax
  8079b5:	89 04 24             	mov    %eax,(%esp)
  8079b8:	e8 9c 02 00 00       	call   807c59 <htons>
  8079bd:	0f b7 c0             	movzwl %ax,%eax
  8079c0:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  8079c2:	0f b7 ff             	movzwl %di,%edi
  8079c5:	89 3c 24             	mov    %edi,(%esp)
  8079c8:	e8 8c 02 00 00       	call   807c59 <htons>
  8079cd:	0f b7 c0             	movzwl %ax,%eax
  8079d0:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8079d2:	89 f0                	mov    %esi,%eax
  8079d4:	c1 e8 10             	shr    $0x10,%eax
  8079d7:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  8079dd:	01 c6                	add    %eax,%esi
  acc = FOLD_U32T(acc);
  8079df:	89 f0                	mov    %esi,%eax
  8079e1:	c1 e8 10             	shr    $0x10,%eax
  8079e4:	01 f0                	add    %esi,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8079e6:	f7 d0                	not    %eax
}
  8079e8:	83 c4 2c             	add    $0x2c,%esp
  8079eb:	5b                   	pop    %ebx
  8079ec:	5e                   	pop    %esi
  8079ed:	5f                   	pop    %edi
  8079ee:	5d                   	pop    %ebp
  8079ef:	c3                   	ret    

008079f0 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  8079f0:	55                   	push   %ebp
  8079f1:	89 e5                	mov    %esp,%ebp
  8079f3:	57                   	push   %edi
  8079f4:	56                   	push   %esi
  8079f5:	53                   	push   %ebx
  8079f6:	83 ec 2c             	sub    $0x2c,%esp
  8079f9:	8a 45 14             	mov    0x14(%ebp),%al
  8079fc:	88 45 e2             	mov    %al,-0x1e(%ebp)
  8079ff:	8b 4d 18             	mov    0x18(%ebp),%ecx
  807a02:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  807a06:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807a09:	8b 75 08             	mov    0x8(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  807a0c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  807a10:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807a17:	eb 79                	jmp    807a92 <inet_chksum_pseudo_partial+0xa2>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  807a19:	66 8b 46 0a          	mov    0xa(%esi),%ax
  807a1d:	89 df                	mov    %ebx,%edi
  807a1f:	66 39 c3             	cmp    %ax,%bx
  807a22:	76 02                	jbe    807a26 <inet_chksum_pseudo_partial+0x36>
  807a24:	89 c7                	mov    %eax,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  807a26:	0f b7 d7             	movzwl %di,%edx
  807a29:	8b 46 04             	mov    0x4(%esi),%eax
  807a2c:	e8 4b fe ff ff       	call   80787c <lwip_standard_chksum>
    chksum_len -= chklen;
  807a31:	66 29 fb             	sub    %di,%bx
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807a34:	66 81 fb fe 7f       	cmp    $0x7ffe,%bx
  807a39:	76 1c                	jbe    807a57 <inet_chksum_pseudo_partial+0x67>
  807a3b:	c7 44 24 08 a5 2b 81 	movl   $0x812ba5,0x8(%esp)
  807a42:	00 
  807a43:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  807a4a:	00 
  807a4b:	c7 04 24 b0 2b 81 00 	movl   $0x812bb0,(%esp)
  807a52:	e8 29 74 00 00       	call   80ee80 <_panic>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  807a57:	0f b7 c0             	movzwl %ax,%eax
  807a5a:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  807a5d:	89 c2                	mov    %eax,%edx
  807a5f:	c1 ea 10             	shr    $0x10,%edx
  807a62:	25 ff ff 00 00       	and    $0xffff,%eax
  807a67:	01 d0                	add    %edx,%eax
  807a69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  807a6c:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807a70:	74 1e                	je     807a90 <inet_chksum_pseudo_partial+0xa0>
      swapped = 1 - swapped;
  807a72:	b0 01                	mov    $0x1,%al
  807a74:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807a77:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807a7a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807a7d:	c1 e0 08             	shl    $0x8,%eax
  807a80:	25 ff ff 00 00       	and    $0xffff,%eax
  807a85:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807a88:	0f b6 d5             	movzbl %ch,%edx
  807a8b:	09 c2                	or     %eax,%edx
  807a8d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807a90:	8b 36                	mov    (%esi),%esi
  807a92:	85 f6                	test   %esi,%esi
  807a94:	74 0e                	je     807aa4 <inet_chksum_pseudo_partial+0xb4>
  807a96:	66 85 db             	test   %bx,%bx
  807a99:	0f 85 7a ff ff ff    	jne    807a19 <inet_chksum_pseudo_partial+0x29>
  807a9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807aa2:	eb 03                	jmp    807aa7 <inet_chksum_pseudo_partial+0xb7>
  807aa4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807aa7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  807aab:	74 13                	je     807ac0 <inet_chksum_pseudo_partial+0xd0>
    acc = SWAP_BYTES_IN_WORD(acc);
  807aad:	89 c2                	mov    %eax,%edx
  807aaf:	c1 e2 08             	shl    $0x8,%edx
  807ab2:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  807ab8:	0f b6 c4             	movzbl %ah,%eax
  807abb:	09 d0                	or     %edx,%eax
  807abd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807ac0:	8b 45 0c             	mov    0xc(%ebp),%eax
  807ac3:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807ac5:	8b 55 10             	mov    0x10(%ebp),%edx
  807ac8:	8b 1a                	mov    (%edx),%ebx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807aca:	89 c2                	mov    %eax,%edx
  807acc:	c1 ea 10             	shr    $0x10,%edx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  807acf:	25 ff ff 00 00       	and    $0xffff,%eax
  807ad4:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807ad6:	0f b7 d3             	movzwl %bx,%edx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807ad9:	01 d0                	add    %edx,%eax
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  807adb:	c1 eb 10             	shr    $0x10,%ebx
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807ade:	01 c3                	add    %eax,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807ae0:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  807ae3:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
  807ae7:	89 04 24             	mov    %eax,(%esp)
  807aea:	e8 6a 01 00 00       	call   807c59 <htons>
  807aef:	0f b7 c0             	movzwl %ax,%eax
  807af2:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  807af4:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807af8:	89 04 24             	mov    %eax,(%esp)
  807afb:	e8 59 01 00 00       	call   807c59 <htons>
  807b00:	0f b7 c0             	movzwl %ax,%eax
  807b03:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807b05:	89 d8                	mov    %ebx,%eax
  807b07:	c1 e8 10             	shr    $0x10,%eax
  807b0a:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  807b10:	01 d8                	add    %ebx,%eax
  acc = FOLD_U32T(acc);
  807b12:	89 c2                	mov    %eax,%edx
  807b14:	c1 ea 10             	shr    $0x10,%edx
  807b17:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807b19:	f7 d0                	not    %eax
}
  807b1b:	83 c4 2c             	add    $0x2c,%esp
  807b1e:	5b                   	pop    %ebx
  807b1f:	5e                   	pop    %esi
  807b20:	5f                   	pop    %edi
  807b21:	5d                   	pop    %ebp
  807b22:	c3                   	ret    

00807b23 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807b23:	55                   	push   %ebp
  807b24:	89 e5                	mov    %esp,%ebp
  807b26:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807b29:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807b2d:	8b 45 08             	mov    0x8(%ebp),%eax
  807b30:	e8 47 fd ff ff       	call   80787c <lwip_standard_chksum>
  807b35:	f7 d0                	not    %eax
}
  807b37:	c9                   	leave  
  807b38:	c3                   	ret    

00807b39 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807b39:	55                   	push   %ebp
  807b3a:	89 e5                	mov    %esp,%ebp
  807b3c:	56                   	push   %esi
  807b3d:	53                   	push   %ebx
  807b3e:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807b41:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807b44:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  807b48:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807b4d:	eb 3f                	jmp    807b8e <inet_chksum_pbuf+0x55>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807b4f:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807b53:	8b 43 04             	mov    0x4(%ebx),%eax
  807b56:	e8 21 fd ff ff       	call   80787c <lwip_standard_chksum>
  807b5b:	0f b7 c0             	movzwl %ax,%eax
  807b5e:	01 c6                	add    %eax,%esi
    acc = FOLD_U32T(acc);
  807b60:	89 f0                	mov    %esi,%eax
  807b62:	c1 e8 10             	shr    $0x10,%eax
  807b65:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  807b6b:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807b6d:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807b71:	74 19                	je     807b8c <inet_chksum_pbuf+0x53>
      swapped = 1 - swapped;
  807b73:	b0 01                	mov    $0x1,%al
  807b75:	2a 45 f7             	sub    -0x9(%ebp),%al
  807b78:	88 45 f7             	mov    %al,-0x9(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807b7b:	89 f0                	mov    %esi,%eax
  807b7d:	c1 e0 08             	shl    $0x8,%eax
  807b80:	25 ff ff 00 00       	and    $0xffff,%eax
  807b85:	89 f2                	mov    %esi,%edx
  807b87:	0f b6 f6             	movzbl %dh,%esi
  807b8a:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807b8c:	8b 1b                	mov    (%ebx),%ebx
  807b8e:	85 db                	test   %ebx,%ebx
  807b90:	75 bd                	jne    807b4f <inet_chksum_pbuf+0x16>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  807b92:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  807b96:	74 11                	je     807ba9 <inet_chksum_pbuf+0x70>
    acc = SWAP_BYTES_IN_WORD(acc);
  807b98:	89 f0                	mov    %esi,%eax
  807b9a:	c1 e0 08             	shl    $0x8,%eax
  807b9d:	25 ff ff 00 00       	and    $0xffff,%eax
  807ba2:	89 f2                	mov    %esi,%edx
  807ba4:	0f b6 f6             	movzbl %dh,%esi
  807ba7:	09 c6                	or     %eax,%esi
  }
  return (u16_t)~(acc & 0xffffUL);
  807ba9:	89 f0                	mov    %esi,%eax
  807bab:	f7 d0                	not    %eax
}
  807bad:	83 c4 10             	add    $0x10,%esp
  807bb0:	5b                   	pop    %ebx
  807bb1:	5e                   	pop    %esi
  807bb2:	5d                   	pop    %ebp
  807bb3:	c3                   	ret    

00807bb4 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  807bb4:	55                   	push   %ebp
  807bb5:	89 e5                	mov    %esp,%ebp
  807bb7:	57                   	push   %edi
  807bb8:	56                   	push   %esi
  807bb9:	53                   	push   %ebx
  807bba:	83 ec 1c             	sub    $0x1c,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807bbd:	8b 45 08             	mov    0x8(%ebp),%eax
  807bc0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807bc3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  807bc7:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  807bca:	c7 45 dc 3c 5a b3 00 	movl   $0xb35a3c,-0x24(%ebp)
 */
char *
inet_ntoa(struct in_addr addr)
{
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807bd1:	b2 00                	mov    $0x0,%dl
  807bd3:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807bd6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807bd9:	8a 00                	mov    (%eax),%al
  807bdb:	88 45 e2             	mov    %al,-0x1e(%ebp)
      *ap /= (u8_t)10;
  807bde:	0f b6 c0             	movzbl %al,%eax
  807be1:	8d 34 80             	lea    (%eax,%eax,4),%esi
  807be4:	8d 04 f0             	lea    (%eax,%esi,8),%eax
  807be7:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807bea:	66 c1 e8 0b          	shr    $0xb,%ax
  807bee:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  807bf1:	88 01                	mov    %al,(%ecx)
      inv[i++] = '0' + rem;
  807bf3:	0f b6 f2             	movzbl %dl,%esi
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807bf6:	8d 3c 80             	lea    (%eax,%eax,4),%edi
  807bf9:	d1 e7                	shl    %edi
  807bfb:	8a 5d e2             	mov    -0x1e(%ebp),%bl
  807bfe:	89 f9                	mov    %edi,%ecx
  807c00:	28 cb                	sub    %cl,%bl
  807c02:	89 df                	mov    %ebx,%edi
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
  807c04:	8d 4f 30             	lea    0x30(%edi),%ecx
  807c07:	88 4c 35 ed          	mov    %cl,-0x13(%ebp,%esi,1)
  807c0b:	42                   	inc    %edx
    } while(*ap);
  807c0c:	84 c0                	test   %al,%al
  807c0e:	75 c6                	jne    807bd6 <inet_ntoa+0x22>
  807c10:	88 d0                	mov    %dl,%al
  807c12:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  807c15:	8b 7d d8             	mov    -0x28(%ebp),%edi
  807c18:	eb 0b                	jmp    807c25 <inet_ntoa+0x71>
    while(i--)
  807c1a:	48                   	dec    %eax
      *rp++ = inv[i];
  807c1b:	0f b6 f0             	movzbl %al,%esi
  807c1e:	8a 5c 35 ed          	mov    -0x13(%ebp,%esi,1),%bl
  807c22:	88 19                	mov    %bl,(%ecx)
  807c24:	41                   	inc    %ecx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  807c25:	84 c0                	test   %al,%al
  807c27:	75 f1                	jne    807c1a <inet_ntoa+0x66>
  807c29:	89 7d d8             	mov    %edi,-0x28(%ebp)
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  807c2c:	0f b6 d2             	movzbl %dl,%edx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  807c2f:	03 55 dc             	add    -0x24(%ebp),%edx
      *rp++ = inv[i];
    *rp++ = '.';
  807c32:	c6 02 2e             	movb   $0x2e,(%edx)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807c35:	fe 45 e3             	incb   -0x1d(%ebp)
  807c38:	80 7d e3 03          	cmpb   $0x3,-0x1d(%ebp)
  807c3c:	77 0b                	ja     807c49 <inet_ntoa+0x95>
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807c3e:	42                   	inc    %edx
  807c3f:	89 55 dc             	mov    %edx,-0x24(%ebp)
    ap++;
  807c42:	ff 45 d8             	incl   -0x28(%ebp)
  807c45:	88 c2                	mov    %al,%dl
  807c47:	eb 8d                	jmp    807bd6 <inet_ntoa+0x22>
  }
  *--rp = 0;
  807c49:	c6 02 00             	movb   $0x0,(%edx)
  return str;
}
  807c4c:	b8 3c 5a b3 00       	mov    $0xb35a3c,%eax
  807c51:	83 c4 1c             	add    $0x1c,%esp
  807c54:	5b                   	pop    %ebx
  807c55:	5e                   	pop    %esi
  807c56:	5f                   	pop    %edi
  807c57:	5d                   	pop    %ebp
  807c58:	c3                   	ret    

00807c59 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807c59:	55                   	push   %ebp
  807c5a:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807c5c:	8b 45 08             	mov    0x8(%ebp),%eax
  807c5f:	66 c1 c0 08          	rol    $0x8,%ax
}
  807c63:	5d                   	pop    %ebp
  807c64:	c3                   	ret    

00807c65 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807c65:	55                   	push   %ebp
  807c66:	89 e5                	mov    %esp,%ebp
  807c68:	83 ec 04             	sub    $0x4,%esp
  return htons(n);
  807c6b:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807c6f:	89 04 24             	mov    %eax,(%esp)
  807c72:	e8 e2 ff ff ff       	call   807c59 <htons>
}
  807c77:	c9                   	leave  
  807c78:	c3                   	ret    

00807c79 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  807c79:	55                   	push   %ebp
  807c7a:	89 e5                	mov    %esp,%ebp
  807c7c:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  807c7f:	89 d1                	mov    %edx,%ecx
  807c81:	c1 e9 18             	shr    $0x18,%ecx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807c84:	89 d0                	mov    %edx,%eax
  807c86:	c1 e0 18             	shl    $0x18,%eax
  807c89:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  807c8b:	89 d1                	mov    %edx,%ecx
  807c8d:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  807c93:	c1 e1 08             	shl    $0x8,%ecx
  807c96:	09 c8                	or     %ecx,%eax
    ((n & 0xff0000UL) >> 8) |
  807c98:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  807c9e:	c1 ea 08             	shr    $0x8,%edx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807ca1:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  807ca3:	5d                   	pop    %ebp
  807ca4:	c3                   	ret    

00807ca5 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  807ca5:	55                   	push   %ebp
  807ca6:	89 e5                	mov    %esp,%ebp
  807ca8:	57                   	push   %edi
  807ca9:	56                   	push   %esi
  807caa:	53                   	push   %ebx
  807cab:	83 ec 24             	sub    $0x24,%esp
  807cae:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  807cb1:	0f be 10             	movsbl (%eax),%edx
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  807cb4:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  807cb7:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807cba:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  807cbd:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  807cc0:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807cc3:	80 f9 09             	cmp    $0x9,%cl
  807cc6:	0f 87 8f 01 00 00    	ja     807e5b <inet_aton+0x1b6>
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
  807ccc:	83 fa 30             	cmp    $0x30,%edx
  807ccf:	75 28                	jne    807cf9 <inet_aton+0x54>
      c = *++cp;
  807cd1:	0f be 50 01          	movsbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807cd5:	83 fa 78             	cmp    $0x78,%edx
  807cd8:	74 0f                	je     807ce9 <inet_aton+0x44>
  807cda:	83 fa 58             	cmp    $0x58,%edx
  807cdd:	74 0a                	je     807ce9 <inet_aton+0x44>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
  807cdf:	40                   	inc    %eax
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
  807ce0:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  807ce7:	eb 17                	jmp    807d00 <inet_aton+0x5b>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  807ce9:	0f be 50 02          	movsbl 0x2(%eax),%edx
  807ced:	8d 40 02             	lea    0x2(%eax),%eax
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  807cf0:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
        c = *++cp;
  807cf7:	eb 07                	jmp    807d00 <inet_aton+0x5b>
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
  807cf9:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
  807d00:	40                   	inc    %eax
  807d01:	be 00 00 00 00       	mov    $0x0,%esi
  807d06:	eb 01                	jmp    807d09 <inet_aton+0x64>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  807d08:	40                   	inc    %eax
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
  807d09:	8d 78 ff             	lea    -0x1(%eax),%edi
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  807d0c:	88 d1                	mov    %dl,%cl
  807d0e:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  807d11:	80 fb 09             	cmp    $0x9,%bl
  807d14:	77 0d                	ja     807d23 <inet_aton+0x7e>
        val = (val * base) + (int)(c - '0');
  807d16:	0f af 75 dc          	imul   -0x24(%ebp),%esi
  807d1a:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  807d1e:	0f be 10             	movsbl (%eax),%edx
  807d21:	eb e5                	jmp    807d08 <inet_aton+0x63>
      } else if (base == 16 && isxdigit(c)) {
  807d23:	83 7d dc 10          	cmpl   $0x10,-0x24(%ebp)
  807d27:	75 30                	jne    807d59 <inet_aton+0xb4>
  807d29:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  807d2c:	88 5d da             	mov    %bl,-0x26(%ebp)
  807d2f:	80 fb 05             	cmp    $0x5,%bl
  807d32:	76 08                	jbe    807d3c <inet_aton+0x97>
  807d34:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  807d37:	80 fb 05             	cmp    $0x5,%bl
  807d3a:	77 23                	ja     807d5f <inet_aton+0xba>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807d3c:	89 f1                	mov    %esi,%ecx
  807d3e:	c1 e1 04             	shl    $0x4,%ecx
  807d41:	8d 72 0a             	lea    0xa(%edx),%esi
  807d44:	80 7d da 1a          	cmpb   $0x1a,-0x26(%ebp)
  807d48:	19 d2                	sbb    %edx,%edx
  807d4a:	83 e2 20             	and    $0x20,%edx
  807d4d:	83 c2 41             	add    $0x41,%edx
  807d50:	29 d6                	sub    %edx,%esi
  807d52:	09 ce                	or     %ecx,%esi
        c = *++cp;
  807d54:	0f be 10             	movsbl (%eax),%edx
  807d57:	eb af                	jmp    807d08 <inet_aton+0x63>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
  807d59:	89 d0                	mov    %edx,%eax
  807d5b:	89 f3                	mov    %esi,%ebx
  807d5d:	eb 04                	jmp    807d63 <inet_aton+0xbe>
  807d5f:	89 d0                	mov    %edx,%eax
  807d61:	89 f3                	mov    %esi,%ebx
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
    if (c == '.') {
  807d63:	83 f8 2e             	cmp    $0x2e,%eax
  807d66:	75 23                	jne    807d8b <inet_aton+0xe6>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807d68:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807d6b:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  807d6e:	0f 83 ee 00 00 00    	jae    807e62 <inet_aton+0x1bd>
        return (0);
      *pp++ = val;
  807d74:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807d77:	89 1a                	mov    %ebx,(%edx)
  807d79:	83 c2 04             	add    $0x4,%edx
  807d7c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      c = *++cp;
  807d7f:	8d 47 01             	lea    0x1(%edi),%eax
  807d82:	0f be 57 01          	movsbl 0x1(%edi),%edx
    } else
      break;
  }
  807d86:	e9 35 ff ff ff       	jmp    807cc0 <inet_aton+0x1b>
  807d8b:	89 f3                	mov    %esi,%ebx
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
    if (c == '.') {
  807d8d:	89 f0                	mov    %esi,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807d8f:	85 d2                	test   %edx,%edx
  807d91:	74 33                	je     807dc6 <inet_aton+0x121>
  807d93:	80 f9 1f             	cmp    $0x1f,%cl
  807d96:	0f 86 cd 00 00 00    	jbe    807e69 <inet_aton+0x1c4>
  807d9c:	84 d2                	test   %dl,%dl
  807d9e:	0f 88 cc 00 00 00    	js     807e70 <inet_aton+0x1cb>
  807da4:	83 fa 20             	cmp    $0x20,%edx
  807da7:	74 1d                	je     807dc6 <inet_aton+0x121>
  807da9:	83 fa 0c             	cmp    $0xc,%edx
  807dac:	74 18                	je     807dc6 <inet_aton+0x121>
  807dae:	83 fa 0a             	cmp    $0xa,%edx
  807db1:	74 13                	je     807dc6 <inet_aton+0x121>
  807db3:	83 fa 0d             	cmp    $0xd,%edx
  807db6:	74 0e                	je     807dc6 <inet_aton+0x121>
  807db8:	83 fa 09             	cmp    $0x9,%edx
  807dbb:	74 09                	je     807dc6 <inet_aton+0x121>
  807dbd:	83 fa 0b             	cmp    $0xb,%edx
  807dc0:	0f 85 b1 00 00 00    	jne    807e77 <inet_aton+0x1d2>
    return (0);
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  807dc6:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  807dc9:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  807dcc:	29 d1                	sub    %edx,%ecx
  807dce:	89 ca                	mov    %ecx,%edx
  807dd0:	c1 fa 02             	sar    $0x2,%edx
  807dd3:	42                   	inc    %edx
  switch (n) {
  807dd4:	83 fa 02             	cmp    $0x2,%edx
  807dd7:	74 1b                	je     807df4 <inet_aton+0x14f>
  807dd9:	83 fa 02             	cmp    $0x2,%edx
  807ddc:	7f 0a                	jg     807de8 <inet_aton+0x143>
  807dde:	85 d2                	test   %edx,%edx
  807de0:	0f 84 98 00 00 00    	je     807e7e <inet_aton+0x1d9>
  807de6:	eb 59                	jmp    807e41 <inet_aton+0x19c>
  807de8:	83 fa 03             	cmp    $0x3,%edx
  807deb:	74 1c                	je     807e09 <inet_aton+0x164>
  807ded:	83 fa 04             	cmp    $0x4,%edx
  807df0:	75 4f                	jne    807e41 <inet_aton+0x19c>
  807df2:	eb 2e                	jmp    807e22 <inet_aton+0x17d>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  807df4:	3d ff ff ff 00       	cmp    $0xffffff,%eax
  807df9:	0f 87 86 00 00 00    	ja     807e85 <inet_aton+0x1e0>
      return (0);
    val |= parts[0] << 24;
  807dff:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  807e02:	c1 e3 18             	shl    $0x18,%ebx
  807e05:	09 c3                	or     %eax,%ebx
    break;
  807e07:	eb 38                	jmp    807e41 <inet_aton+0x19c>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  807e09:	3d ff ff 00 00       	cmp    $0xffff,%eax
  807e0e:	77 7c                	ja     807e8c <inet_aton+0x1e7>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  807e10:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  807e13:	c1 e3 10             	shl    $0x10,%ebx
  807e16:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807e19:	c1 e2 18             	shl    $0x18,%edx
  807e1c:	09 d3                	or     %edx,%ebx
  807e1e:	09 c3                	or     %eax,%ebx
    break;
  807e20:	eb 1f                	jmp    807e41 <inet_aton+0x19c>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  807e22:	3d ff 00 00 00       	cmp    $0xff,%eax
  807e27:	77 6a                	ja     807e93 <inet_aton+0x1ee>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807e29:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  807e2c:	c1 e3 10             	shl    $0x10,%ebx
  807e2f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807e32:	c1 e2 18             	shl    $0x18,%edx
  807e35:	09 d3                	or     %edx,%ebx
  807e37:	8b 55 ec             	mov    -0x14(%ebp),%edx
  807e3a:	c1 e2 08             	shl    $0x8,%edx
  807e3d:	09 d3                	or     %edx,%ebx
  807e3f:	09 c3                	or     %eax,%ebx
    break;
  }
  if (addr)
  807e41:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807e45:	74 53                	je     807e9a <inet_aton+0x1f5>
    addr->s_addr = htonl(val);
  807e47:	89 1c 24             	mov    %ebx,(%esp)
  807e4a:	e8 2a fe ff ff       	call   807c79 <htonl>
  807e4f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  807e52:	89 03                	mov    %eax,(%ebx)
  return (1);
  807e54:	b8 01 00 00 00       	mov    $0x1,%eax
  807e59:	eb 44                	jmp    807e9f <inet_aton+0x1fa>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  807e5b:	b8 00 00 00 00       	mov    $0x0,%eax
  807e60:	eb 3d                	jmp    807e9f <inet_aton+0x1fa>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  807e62:	b8 00 00 00 00       	mov    $0x0,%eax
  807e67:	eb 36                	jmp    807e9f <inet_aton+0x1fa>
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
    return (0);
  807e69:	b8 00 00 00 00       	mov    $0x0,%eax
  807e6e:	eb 2f                	jmp    807e9f <inet_aton+0x1fa>
  807e70:	b8 00 00 00 00       	mov    $0x0,%eax
  807e75:	eb 28                	jmp    807e9f <inet_aton+0x1fa>
  807e77:	b8 00 00 00 00       	mov    $0x0,%eax
  807e7c:	eb 21                	jmp    807e9f <inet_aton+0x1fa>
   */
  n = pp - parts + 1;
  switch (n) {

  case 0:
    return (0);       /* initial nondigit */
  807e7e:	b8 00 00 00 00       	mov    $0x0,%eax
  807e83:	eb 1a                	jmp    807e9f <inet_aton+0x1fa>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  807e85:	b8 00 00 00 00       	mov    $0x0,%eax
  807e8a:	eb 13                	jmp    807e9f <inet_aton+0x1fa>
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  807e8c:	b8 00 00 00 00       	mov    $0x0,%eax
  807e91:	eb 0c                	jmp    807e9f <inet_aton+0x1fa>
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  807e93:	b8 00 00 00 00       	mov    $0x0,%eax
  807e98:	eb 05                	jmp    807e9f <inet_aton+0x1fa>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  807e9a:	b8 01 00 00 00       	mov    $0x1,%eax
}
  807e9f:	83 c4 24             	add    $0x24,%esp
  807ea2:	5b                   	pop    %ebx
  807ea3:	5e                   	pop    %esi
  807ea4:	5f                   	pop    %edi
  807ea5:	5d                   	pop    %ebp
  807ea6:	c3                   	ret    

00807ea7 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  807ea7:	55                   	push   %ebp
  807ea8:	89 e5                	mov    %esp,%ebp
  807eaa:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  807ead:	8d 45 fc             	lea    -0x4(%ebp),%eax
  807eb0:	89 44 24 04          	mov    %eax,0x4(%esp)
  807eb4:	8b 45 08             	mov    0x8(%ebp),%eax
  807eb7:	89 04 24             	mov    %eax,(%esp)
  807eba:	e8 e6 fd ff ff       	call   807ca5 <inet_aton>
  807ebf:	85 c0                	test   %eax,%eax
  807ec1:	74 05                	je     807ec8 <inet_addr+0x21>
    return (val.s_addr);
  807ec3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  807ec6:	eb 05                	jmp    807ecd <inet_addr+0x26>
  }
  return (INADDR_NONE);
  807ec8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  807ecd:	c9                   	leave  
  807ece:	c3                   	ret    

00807ecf <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807ecf:	55                   	push   %ebp
  807ed0:	89 e5                	mov    %esp,%ebp
  807ed2:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  807ed5:	8b 45 08             	mov    0x8(%ebp),%eax
  807ed8:	89 04 24             	mov    %eax,(%esp)
  807edb:	e8 99 fd ff ff       	call   807c79 <htonl>
}
  807ee0:	c9                   	leave  
  807ee1:	c3                   	ret    
	...

00807ee4 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807ee4:	55                   	push   %ebp
  807ee5:	89 e5                	mov    %esp,%ebp
  807ee7:	57                   	push   %edi
  807ee8:	56                   	push   %esi
  807ee9:	53                   	push   %ebx
  807eea:	83 ec 4c             	sub    $0x4c,%esp
  807eed:	8b 45 10             	mov    0x10(%ebp),%eax
  807ef0:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
  807ef4:	8a 55 14             	mov    0x14(%ebp),%dl
  807ef7:	88 55 e0             	mov    %dl,-0x20(%ebp)
  807efa:	8a 4d 18             	mov    0x18(%ebp),%cl
  807efd:	88 4d b8             	mov    %cl,-0x48(%ebp)
  807f00:	8a 45 20             	mov    0x20(%ebp),%al
  807f03:	88 45 e1             	mov    %al,-0x1f(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807f06:	66 83 7d cc 00       	cmpw   $0x0,-0x34(%ebp)
  807f0b:	74 20                	je     807f2d <tcp_enqueue+0x49>
  807f0d:	84 c0                	test   %al,%al
  807f0f:	74 1c                	je     807f2d <tcp_enqueue+0x49>
  807f11:	c7 44 24 08 d4 2b 81 	movl   $0x812bd4,0x8(%esp)
  807f18:	00 
  807f19:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  807f20:	00 
  807f21:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  807f28:	e8 53 6f 00 00       	call   80ee80 <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807f2d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807f31:	74 22                	je     807f55 <tcp_enqueue+0x71>
  807f33:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807f37:	74 1c                	je     807f55 <tcp_enqueue+0x71>
  807f39:	c7 44 24 08 14 2c 81 	movl   $0x812c14,0x8(%esp)
  807f40:	00 
  807f41:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  807f48:	00 
  807f49:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  807f50:	e8 2b 6f 00 00       	call   80ee80 <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807f55:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  807f58:	8b 55 08             	mov    0x8(%ebp),%edx
  807f5b:	66 3b 4a 6e          	cmp    0x6e(%edx),%cx
  807f5f:	76 0b                	jbe    807f6c <tcp_enqueue+0x88>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  807f61:	80 4a 20 80          	orb    $0x80,0x20(%edx)
    return ERR_MEM;
  807f65:	b0 ff                	mov    $0xff,%al
  807f67:	e9 cc 05 00 00       	jmp    808538 <tcp_enqueue+0x654>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807f6c:	8b 45 08             	mov    0x8(%ebp),%eax
  807f6f:	8b 40 68             	mov    0x68(%eax),%eax
  807f72:	89 45 d8             	mov    %eax,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  807f75:	8b 55 08             	mov    0x8(%ebp),%edx
  807f78:	8b 52 70             	mov    0x70(%edx),%edx
  807f7b:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807f7f:	66 83 fa 1f          	cmp    $0x1f,%dx
  807f83:	76 0e                	jbe    807f93 <tcp_enqueue+0xaf>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  807f85:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807f88:	80 49 20 80          	orb    $0x80,0x20(%ecx)
    return ERR_MEM;
  807f8c:	b0 ff                	mov    $0xff,%al
  807f8e:	e9 a5 05 00 00       	jmp    808538 <tcp_enqueue+0x654>
  }
  if (queuelen != 0) {
  807f93:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807f98:	74 33                	je     807fcd <tcp_enqueue+0xe9>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807f9a:	8b 45 08             	mov    0x8(%ebp),%eax
  807f9d:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  807fa1:	0f 85 a3 05 00 00    	jne    80854a <tcp_enqueue+0x666>
  807fa7:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  807fab:	0f 85 99 05 00 00    	jne    80854a <tcp_enqueue+0x666>
  807fb1:	c7 44 24 08 5c 2c 81 	movl   $0x812c5c,0x8(%esp)
  807fb8:	00 
  807fb9:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  807fc0:	00 
  807fc1:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  807fc8:	e8 b3 6e 00 00       	call   80ee80 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807fcd:	8b 55 08             	mov    0x8(%ebp),%edx
  807fd0:	83 7a 78 00          	cmpl   $0x0,0x78(%edx)
  807fd4:	75 0a                	jne    807fe0 <tcp_enqueue+0xfc>
  807fd6:	83 7a 74 00          	cmpl   $0x0,0x74(%edx)
  807fda:	0f 84 6a 05 00 00    	je     80854a <tcp_enqueue+0x666>
  807fe0:	c7 44 24 08 98 2c 81 	movl   $0x812c98,0x8(%esp)
  807fe7:	00 
  807fe8:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  807fef:	00 
  807ff0:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  807ff7:	e8 84 6e 00 00       	call   80ee80 <_panic>

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807ffc:	89 f7                	mov    %esi,%edi
  807ffe:	eb 02                	jmp    808002 <tcp_enqueue+0x11e>
  808000:	89 f7                	mov    %esi,%edi

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  808002:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808005:	8b 59 34             	mov    0x34(%ecx),%ebx

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  808008:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80800f:	e8 52 c9 ff ff       	call   804966 <memp_malloc>
  808014:	89 c6                	mov    %eax,%esi
    if (seg == NULL) {
  808016:	85 c0                	test   %eax,%eax
  808018:	0f 84 b6 04 00 00    	je     8084d4 <tcp_enqueue+0x5f0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  80801e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  808024:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80802b:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80802f:	74 24                	je     808055 <tcp_enqueue+0x171>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  808031:	85 ff                	test   %edi,%edi
  808033:	75 1c                	jne    808051 <tcp_enqueue+0x16d>
  808035:	c7 44 24 08 8e 2d 81 	movl   $0x812d8e,0x8(%esp)
  80803c:	00 
  80803d:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  808044:	00 
  808045:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  80804c:	e8 2f 6e 00 00       	call   80ee80 <_panic>
      useg->next = seg;
  808051:	89 07                	mov    %eax,(%edi)
  808053:	eb 03                	jmp    808058 <tcp_enqueue+0x174>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  808055:	89 45 d0             	mov    %eax,-0x30(%ebp)
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  808058:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80805b:	66 39 df             	cmp    %bx,%di
  80805e:	76 02                	jbe    808062 <tcp_enqueue+0x17e>
  808060:	89 df                	mov    %ebx,%edi
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  808062:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  808066:	74 6a                	je     8080d2 <tcp_enqueue+0x1ee>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  808068:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80806f:	00 
  808070:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
  808074:	89 44 24 04          	mov    %eax,0x4(%esp)
  808078:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80807f:	e8 ce ce ff ff       	call   804f52 <pbuf_alloc>
  808084:	89 46 04             	mov    %eax,0x4(%esi)
  808087:	85 c0                	test   %eax,%eax
  808089:	0f 84 45 04 00 00    	je     8084d4 <tcp_enqueue+0x5f0>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80808f:	0f b6 55 e1          	movzbl -0x1f(%ebp),%edx
  808093:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  808097:	73 1c                	jae    8080b5 <tcp_enqueue+0x1d1>
  808099:	c7 44 24 08 cc 2c 81 	movl   $0x812ccc,0x8(%esp)
  8080a0:	00 
  8080a1:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  8080a8:	00 
  8080a9:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  8080b0:	e8 cb 6d 00 00       	call   80ee80 <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  8080b5:	89 04 24             	mov    %eax,(%esp)
  8080b8:	e8 1b d1 ff ff       	call   8051d8 <pbuf_clen>
  8080bd:	0f b6 c0             	movzbl %al,%eax
  8080c0:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      seg->dataptr = seg->p->payload;
  8080c4:	8b 46 04             	mov    0x4(%esi),%eax
  8080c7:	8b 40 04             	mov    0x4(%eax),%eax
  8080ca:	89 46 08             	mov    %eax,0x8(%esi)
  8080cd:	e9 15 01 00 00       	jmp    8081e7 <tcp_enqueue+0x303>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  8080d2:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  8080d6:	0f 84 87 00 00 00    	je     808163 <tcp_enqueue+0x27f>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  8080dc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8080e3:	00 
  8080e4:	0f b7 c7             	movzwl %di,%eax
  8080e7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8080eb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8080f2:	e8 5b ce ff ff       	call   804f52 <pbuf_alloc>
  8080f7:	89 46 04             	mov    %eax,0x4(%esi)
  8080fa:	85 c0                	test   %eax,%eax
  8080fc:	0f 84 d2 03 00 00    	je     8084d4 <tcp_enqueue+0x5f0>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  808102:	66 3b 78 0a          	cmp    0xa(%eax),%di
  808106:	76 1c                	jbe    808124 <tcp_enqueue+0x240>
  808108:	c7 44 24 08 f4 2c 81 	movl   $0x812cf4,0x8(%esp)
  80810f:	00 
  808110:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  808117:	00 
  808118:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  80811f:	e8 5c 6d 00 00       	call   80ee80 <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  808124:	89 04 24             	mov    %eax,(%esp)
  808127:	e8 ac d0 ff ff       	call   8051d8 <pbuf_clen>
  80812c:	0f b6 c0             	movzbl %al,%eax
  80812f:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      if (arg != NULL) {
  808133:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808137:	74 1c                	je     808155 <tcp_enqueue+0x271>
        MEMCPY(seg->p->payload, ptr, seglen);
  808139:	0f b7 c7             	movzwl %di,%eax
  80813c:	89 44 24 08          	mov    %eax,0x8(%esp)
  808140:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808143:	89 44 24 04          	mov    %eax,0x4(%esp)
  808147:	8b 46 04             	mov    0x4(%esi),%eax
  80814a:	8b 40 04             	mov    0x4(%eax),%eax
  80814d:	89 04 24             	mov    %eax,(%esp)
  808150:	e8 b1 75 00 00       	call   80f706 <memcpy>
      }
      seg->dataptr = seg->p->payload;
  808155:	8b 46 04             	mov    0x4(%esi),%eax
  808158:	8b 40 04             	mov    0x4(%eax),%eax
  80815b:	89 46 08             	mov    %eax,0x8(%esi)
  80815e:	e9 84 00 00 00       	jmp    8081e7 <tcp_enqueue+0x303>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  808163:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80816a:	00 
  80816b:	0f b7 c7             	movzwl %di,%eax
  80816e:	89 44 24 04          	mov    %eax,0x4(%esp)
  808172:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808179:	e8 d4 cd ff ff       	call   804f52 <pbuf_alloc>
  80817e:	89 c3                	mov    %eax,%ebx
  808180:	85 c0                	test   %eax,%eax
  808182:	0f 84 4c 03 00 00    	je     8084d4 <tcp_enqueue+0x5f0>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
      /* reference the non-volatile payload data */
      p->payload = ptr;
  808188:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80818b:	89 50 04             	mov    %edx,0x4(%eax)
      seg->dataptr = ptr;
  80818e:	89 56 08             	mov    %edx,0x8(%esi)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  808191:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808198:	00 
  808199:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8081a0:	00 
  8081a1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8081a8:	e8 a5 cd ff ff       	call   804f52 <pbuf_alloc>
  8081ad:	89 46 04             	mov    %eax,0x4(%esi)
  8081b0:	85 c0                	test   %eax,%eax
  8081b2:	75 0d                	jne    8081c1 <tcp_enqueue+0x2dd>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  8081b4:	89 1c 24             	mov    %ebx,(%esp)
  8081b7:	e8 95 cb ff ff       	call   804d51 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  8081bc:	e9 13 03 00 00       	jmp    8084d4 <tcp_enqueue+0x5f0>
      }
      queuelen += pbuf_clen(seg->p);
  8081c1:	89 04 24             	mov    %eax,(%esp)
  8081c4:	e8 0f d0 ff ff       	call   8051d8 <pbuf_clen>
  8081c9:	0f b6 c0             	movzbl %al,%eax
  8081cc:	66 8b 4d e2          	mov    -0x1e(%ebp),%cx
  8081d0:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
  8081d4:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  8081d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8081dc:	8b 46 04             	mov    0x4(%esi),%eax
  8081df:	89 04 24             	mov    %eax,(%esp)
  8081e2:	e8 14 d0 ff ff       	call   8051fb <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  8081e7:	66 83 7d e2 20       	cmpw   $0x20,-0x1e(%ebp)
  8081ec:	0f 87 e2 02 00 00    	ja     8084d4 <tcp_enqueue+0x5f0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  8081f2:	66 89 7e 0c          	mov    %di,0xc(%esi)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  8081f6:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8081fd:	00 
  8081fe:	8b 46 04             	mov    0x4(%esi),%eax
  808201:	89 04 24             	mov    %eax,(%esp)
  808204:	e8 63 ca ff ff       	call   804c6c <pbuf_header>
  808209:	84 c0                	test   %al,%al
  80820b:	0f 85 c3 02 00 00    	jne    8084d4 <tcp_enqueue+0x5f0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  808211:	8b 46 04             	mov    0x4(%esi),%eax
  808214:	8b 58 04             	mov    0x4(%eax),%ebx
  808217:	89 5e 10             	mov    %ebx,0x10(%esi)
    seg->tcphdr->src = htons(pcb->local_port);
  80821a:	8b 55 08             	mov    0x8(%ebp),%edx
  80821d:	0f b7 42 1c          	movzwl 0x1c(%edx),%eax
  808221:	89 04 24             	mov    %eax,(%esp)
  808224:	e8 30 fa ff ff       	call   807c59 <htons>
  808229:	66 89 03             	mov    %ax,(%ebx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  80822c:	8b 5e 10             	mov    0x10(%esi),%ebx
  80822f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808232:	0f b7 41 1e          	movzwl 0x1e(%ecx),%eax
  808236:	89 04 24             	mov    %eax,(%esp)
  808239:	e8 1b fa ff ff       	call   807c59 <htons>
  80823e:	66 89 43 02          	mov    %ax,0x2(%ebx)
    seg->tcphdr->seqno = htonl(seqno);
  808242:	8b 5e 10             	mov    0x10(%esi),%ebx
  808245:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808248:	89 04 24             	mov    %eax,(%esp)
  80824b:	e8 29 fa ff ff       	call   807c79 <htonl>
  808250:	89 43 04             	mov    %eax,0x4(%ebx)
    seg->tcphdr->urgp = 0;
  808253:	8b 46 10             	mov    0x10(%esi),%eax
  808256:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80825c:	8b 5e 10             	mov    0x10(%esi),%ebx
  80825f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808263:	89 04 24             	mov    %eax,(%esp)
  808266:	e8 fa f9 ff ff       	call   807c65 <ntohs>
  80826b:	83 e0 c0             	and    $0xffffffc0,%eax
  80826e:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  808272:	09 c2                	or     %eax,%edx
  808274:	0f b7 d2             	movzwl %dx,%edx
  808277:	89 14 24             	mov    %edx,(%esp)
  80827a:	e8 da f9 ff ff       	call   807c59 <htons>
  80827f:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  808283:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  808287:	75 23                	jne    8082ac <tcp_enqueue+0x3c8>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  808289:	8b 5e 10             	mov    0x10(%esi),%ebx
  80828c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808290:	89 04 24             	mov    %eax,(%esp)
  808293:	e8 cd f9 ff ff       	call   807c65 <ntohs>
  808298:	83 e0 3f             	and    $0x3f,%eax
  80829b:	80 cc 50             	or     $0x50,%ah
  80829e:	89 04 24             	mov    %eax,(%esp)
  8082a1:	e8 b3 f9 ff ff       	call   807c59 <htons>
  8082a6:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  8082aa:	eb 3f                	jmp    8082eb <tcp_enqueue+0x407>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8082ac:	8b 5e 10             	mov    0x10(%esi),%ebx
  8082af:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8082b3:	89 04 24             	mov    %eax,(%esp)
  8082b6:	e8 aa f9 ff ff       	call   807c65 <ntohs>
  8082bb:	83 e0 3f             	and    $0x3f,%eax
  8082be:	66 0b 45 ce          	or     -0x32(%ebp),%ax
  8082c2:	0f b7 c0             	movzwl %ax,%eax
  8082c5:	89 04 24             	mov    %eax,(%esp)
  8082c8:	e8 8c f9 ff ff       	call   807c59 <htons>
  8082cd:	66 89 43 0c          	mov    %ax,0xc(%ebx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  8082d1:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
  8082d5:	89 44 24 08          	mov    %eax,0x8(%esp)
  8082d9:	8b 55 1c             	mov    0x1c(%ebp),%edx
  8082dc:	89 54 24 04          	mov    %edx,0x4(%esp)
  8082e0:	8b 46 08             	mov    0x8(%esi),%eax
  8082e3:	89 04 24             	mov    %eax,(%esp)
  8082e6:	e8 1b 74 00 00       	call   80f706 <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  8082eb:	66 29 7d e4          	sub    %di,-0x1c(%ebp)
    seqno += seglen;
  8082ef:	0f b7 c7             	movzwl %di,%eax
  8082f2:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  8082f5:	01 45 d4             	add    %eax,-0x2c(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  8082f8:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  8082fc:	0f 84 fa fc ff ff    	je     807ffc <tcp_enqueue+0x118>
  808302:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  808307:	0f 85 f3 fc ff ff    	jne    808000 <tcp_enqueue+0x11c>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80830d:	89 75 dc             	mov    %esi,-0x24(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  808310:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808313:	8b 59 74             	mov    0x74(%ecx),%ebx
  808316:	85 db                	test   %ebx,%ebx
  808318:	75 07                	jne    808321 <tcp_enqueue+0x43d>
  80831a:	e9 0b 01 00 00       	jmp    80842a <tcp_enqueue+0x546>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  80831f:	89 c3                	mov    %eax,%ebx
  808321:	8b 03                	mov    (%ebx),%eax
  808323:	85 c0                	test   %eax,%eax
  808325:	75 f8                	jne    80831f <tcp_enqueue+0x43b>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808327:	85 db                	test   %ebx,%ebx
  808329:	0f 84 fb 00 00 00    	je     80842a <tcp_enqueue+0x546>
    TCP_TCPLEN(useg) != 0 &&
  80832f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808333:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808336:	8b 43 10             	mov    0x10(%ebx),%eax
  808339:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80833d:	89 04 24             	mov    %eax,(%esp)
  808340:	e8 20 f9 ff ff       	call   807c65 <ntohs>
  808345:	a8 01                	test   $0x1,%al
  808347:	75 1a                	jne    808363 <tcp_enqueue+0x47f>
  808349:	8b 43 10             	mov    0x10(%ebx),%eax
  80834c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808350:	89 04 24             	mov    %eax,(%esp)
  808353:	e8 0d f9 ff ff       	call   807c65 <ntohs>
  808358:	83 e0 02             	and    $0x2,%eax
  80835b:	0f 95 c0             	setne  %al
  80835e:	0f b6 c0             	movzbl %al,%eax
  808361:	eb 05                	jmp    808368 <tcp_enqueue+0x484>
  808363:	b8 01 00 00 00       	mov    $0x1,%eax
  808368:	03 45 e4             	add    -0x1c(%ebp),%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80836b:	85 c0                	test   %eax,%eax
  80836d:	0f 84 cd 01 00 00    	je     808540 <tcp_enqueue+0x65c>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  808373:	8b 43 10             	mov    0x10(%ebx),%eax
  808376:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80837a:	89 04 24             	mov    %eax,(%esp)
  80837d:	e8 e3 f8 ff ff       	call   807c65 <ntohs>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  808382:	a8 03                	test   $0x3,%al
  808384:	0f 85 b6 01 00 00    	jne    808540 <tcp_enqueue+0x65c>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  80838a:	f6 45 e0 03          	testb  $0x3,-0x20(%ebp)
  80838e:	0f 85 ac 01 00 00    	jne    808540 <tcp_enqueue+0x65c>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  808394:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808398:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80839b:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80839f:	01 c2                	add    %eax,%edx
  8083a1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8083a4:	0f b7 41 34          	movzwl 0x34(%ecx),%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  8083a8:	39 c2                	cmp    %eax,%edx
  8083aa:	0f 8f 90 01 00 00    	jg     808540 <tcp_enqueue+0x65c>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  8083b0:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  8083b7:	ff 
  8083b8:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8083bb:	8b 42 04             	mov    0x4(%edx),%eax
  8083be:	89 04 24             	mov    %eax,(%esp)
  8083c1:	e8 a6 c8 ff ff       	call   804c6c <pbuf_header>
  8083c6:	84 c0                	test   %al,%al
  8083c8:	74 1c                	je     8083e6 <tcp_enqueue+0x502>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8083ca:	c7 44 24 08 9b 2d 81 	movl   $0x812d9b,0x8(%esp)
  8083d1:	00 
  8083d2:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  8083d9:	00 
  8083da:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  8083e1:	e8 9a 6a 00 00       	call   80ee80 <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  8083e6:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  8083e9:	8b 41 04             	mov    0x4(%ecx),%eax
  8083ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8083f0:	8b 43 04             	mov    0x4(%ebx),%eax
  8083f3:	89 04 24             	mov    %eax,(%esp)
  8083f6:	e8 00 ce ff ff       	call   8051fb <pbuf_cat>
    useg->len += queue->len;
  8083fb:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8083fe:	8b 42 0c             	mov    0xc(%edx),%eax
  808401:	66 01 43 0c          	add    %ax,0xc(%ebx)
    useg->next = queue->next;
  808405:	8b 02                	mov    (%edx),%eax
  808407:	89 03                	mov    %eax,(%ebx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  808409:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80840c:	39 ca                	cmp    %ecx,%edx
  80840e:	75 05                	jne    808415 <tcp_enqueue+0x531>
      seg = NULL;
  808410:	be 00 00 00 00       	mov    $0x0,%esi
    }
    memp_free(MEMP_TCP_SEG, queue);
  808415:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808418:	89 44 24 04          	mov    %eax,0x4(%esp)
  80841c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808423:	e8 9e c5 ff ff       	call   8049c6 <memp_free>
  808428:	eb 09                	jmp    808433 <tcp_enqueue+0x54f>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80842a:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80842d:	8b 55 08             	mov    0x8(%ebp),%edx
  808430:	89 4a 74             	mov    %ecx,0x74(%edx)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  808433:	f6 45 e0 02          	testb  $0x2,-0x20(%ebp)
  808437:	75 0c                	jne    808445 <tcp_enqueue+0x561>
  808439:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80843d:	0f 85 40 01 00 00    	jne    808583 <tcp_enqueue+0x69f>
  808443:	eb 11                	jmp    808456 <tcp_enqueue+0x572>
    ++len;
  808445:	66 ff 45 cc          	incw   -0x34(%ebp)
  }
  if (flags & TCP_FIN) {
  808449:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80844d:	74 07                	je     808456 <tcp_enqueue+0x572>
    pcb->flags |= TF_FIN;
  80844f:	8b 45 08             	mov    0x8(%ebp),%eax
  808452:	80 48 20 20          	orb    $0x20,0x20(%eax)
  }
  pcb->snd_lbb += len;
  808456:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
  80845a:	8b 55 08             	mov    0x8(%ebp),%edx
  80845d:	01 42 68             	add    %eax,0x68(%edx)

  pcb->snd_buf -= len;
  808460:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  808463:	66 29 4a 6e          	sub    %cx,0x6e(%edx)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  808467:	66 8b 45 e2          	mov    -0x1e(%ebp),%ax
  80846b:	66 89 42 70          	mov    %ax,0x70(%edx)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  80846f:	66 85 c0             	test   %ax,%ax
  808472:	74 28                	je     80849c <tcp_enqueue+0x5b8>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  808474:	83 7a 78 00          	cmpl   $0x0,0x78(%edx)
  808478:	75 22                	jne    80849c <tcp_enqueue+0x5b8>
  80847a:	83 7a 74 00          	cmpl   $0x0,0x74(%edx)
  80847e:	75 1c                	jne    80849c <tcp_enqueue+0x5b8>
  808480:	c7 44 24 08 28 2d 81 	movl   $0x812d28,0x8(%esp)
  808487:	00 
  808488:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  80848f:	00 
  808490:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  808497:	e8 e4 69 00 00       	call   80ee80 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80849c:	85 f6                	test   %esi,%esi
  80849e:	74 7e                	je     80851e <tcp_enqueue+0x63a>
  8084a0:	66 85 ff             	test   %di,%di
  8084a3:	74 7d                	je     808522 <tcp_enqueue+0x63e>
  8084a5:	8b 5e 10             	mov    0x10(%esi),%ebx
  8084a8:	85 db                	test   %ebx,%ebx
  8084aa:	74 7a                	je     808526 <tcp_enqueue+0x642>
  8084ac:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  8084b0:	75 78                	jne    80852a <tcp_enqueue+0x646>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  8084b2:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8084b6:	89 04 24             	mov    %eax,(%esp)
  8084b9:	e8 a7 f7 ff ff       	call   807c65 <ntohs>
  8084be:	83 c8 08             	or     $0x8,%eax
  8084c1:	0f b7 c0             	movzwl %ax,%eax
  8084c4:	89 04 24             	mov    %eax,(%esp)
  8084c7:	e8 8d f7 ff ff       	call   807c59 <htons>
  8084cc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  }

  return ERR_OK;
  8084d0:	b0 00                	mov    $0x0,%al
  8084d2:	eb 64                	jmp    808538 <tcp_enqueue+0x654>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  8084d4:	8b 55 08             	mov    0x8(%ebp),%edx
  8084d7:	80 4a 20 80          	orb    $0x80,0x20(%edx)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  8084db:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  8084df:	74 0b                	je     8084ec <tcp_enqueue+0x608>
    tcp_segs_free(queue);
  8084e1:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  8084e4:	89 0c 24             	mov    %ecx,(%esp)
  8084e7:	e8 20 d8 ff ff       	call   805d0c <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  8084ec:	8b 45 08             	mov    0x8(%ebp),%eax
  8084ef:	66 83 78 70 00       	cmpw   $0x0,0x70(%eax)
  8084f4:	74 38                	je     80852e <tcp_enqueue+0x64a>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  8084f6:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  8084fa:	75 36                	jne    808532 <tcp_enqueue+0x64e>
  8084fc:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  808500:	75 34                	jne    808536 <tcp_enqueue+0x652>
  808502:	c7 44 24 08 28 2d 81 	movl   $0x812d28,0x8(%esp)
  808509:	00 
  80850a:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  808511:	00 
  808512:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  808519:	e8 62 69 00 00       	call   80ee80 <_panic>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  80851e:	b0 00                	mov    $0x0,%al
  808520:	eb 16                	jmp    808538 <tcp_enqueue+0x654>
  808522:	b0 00                	mov    $0x0,%al
  808524:	eb 12                	jmp    808538 <tcp_enqueue+0x654>
  808526:	b0 00                	mov    $0x0,%al
  808528:	eb 0e                	jmp    808538 <tcp_enqueue+0x654>
  80852a:	b0 00                	mov    $0x0,%al
  80852c:	eb 0a                	jmp    808538 <tcp_enqueue+0x654>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  80852e:	b0 ff                	mov    $0xff,%al
  808530:	eb 06                	jmp    808538 <tcp_enqueue+0x654>
  808532:	b0 ff                	mov    $0xff,%al
  808534:	eb 02                	jmp    808538 <tcp_enqueue+0x654>
  808536:	b0 ff                	mov    $0xff,%al
}
  808538:	83 c4 4c             	add    $0x4c,%esp
  80853b:	5b                   	pop    %ebx
  80853c:	5e                   	pop    %esi
  80853d:	5f                   	pop    %edi
  80853e:	5d                   	pop    %ebp
  80853f:	c3                   	ret    
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  808540:	8b 55 d0             	mov    -0x30(%ebp),%edx
  808543:	89 13                	mov    %edx,(%ebx)
  808545:	e9 e9 fe ff ff       	jmp    808433 <tcp_enqueue+0x54f>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80854a:	8a 45 e1             	mov    -0x1f(%ebp),%al
  80854d:	c0 e8 02             	shr    $0x2,%al
  808550:	c1 e0 0c             	shl    $0xc,%eax
  808553:	05 00 50 00 00       	add    $0x5000,%eax
  808558:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
  80855c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80855f:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  808562:	8b 45 cc             	mov    -0x34(%ebp),%eax
  808565:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  808569:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  808570:	bf 00 00 00 00       	mov    $0x0,%edi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  808575:	8a 55 b8             	mov    -0x48(%ebp),%dl
  808578:	83 e2 01             	and    $0x1,%edx
  80857b:	89 55 c8             	mov    %edx,-0x38(%ebp)
  80857e:	e9 7f fa ff ff       	jmp    808002 <tcp_enqueue+0x11e>
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    ++len;
  808583:	66 ff 45 cc          	incw   -0x34(%ebp)
  808587:	e9 c3 fe ff ff       	jmp    80844f <tcp_enqueue+0x56b>

0080858c <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  80858c:	55                   	push   %ebp
  80858d:	89 e5                	mov    %esp,%ebp
  80858f:	53                   	push   %ebx
  808590:	83 ec 24             	sub    $0x24,%esp
  808593:	8b 55 08             	mov    0x8(%ebp),%edx
  808596:	8b 4d 10             	mov    0x10(%ebp),%ecx
  808599:	8a 5d 14             	mov    0x14(%ebp),%bl
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  80859c:	8b 42 10             	mov    0x10(%edx),%eax
  80859f:	83 f8 04             	cmp    $0x4,%eax
  8085a2:	74 0f                	je     8085b3 <tcp_write+0x27>
  8085a4:	83 f8 07             	cmp    $0x7,%eax
  8085a7:	74 0a                	je     8085b3 <tcp_write+0x27>
     pcb->state == CLOSE_WAIT ||
  8085a9:	83 f8 02             	cmp    $0x2,%eax
  8085ac:	74 05                	je     8085b3 <tcp_write+0x27>
     pcb->state == SYN_SENT ||
  8085ae:	83 f8 03             	cmp    $0x3,%eax
  8085b1:	75 3c                	jne    8085ef <tcp_write+0x63>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  8085b3:	66 85 c9             	test   %cx,%cx
  8085b6:	74 3b                	je     8085f3 <tcp_write+0x67>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  8085b8:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  8085bf:	00 
  8085c0:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8085c7:	00 
  8085c8:	0f b6 db             	movzbl %bl,%ebx
  8085cb:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  8085cf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8085d6:	00 
  8085d7:	0f b7 c9             	movzwl %cx,%ecx
  8085da:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8085de:	8b 45 0c             	mov    0xc(%ebp),%eax
  8085e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8085e5:	89 14 24             	mov    %edx,(%esp)
  8085e8:	e8 f7 f8 ff ff       	call   807ee4 <tcp_enqueue>
  8085ed:	eb 06                	jmp    8085f5 <tcp_write+0x69>
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  8085ef:	b0 f8                	mov    $0xf8,%al
  8085f1:	eb 02                	jmp    8085f5 <tcp_write+0x69>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  8085f3:	b0 00                	mov    $0x0,%al
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  8085f5:	83 c4 24             	add    $0x24,%esp
  8085f8:	5b                   	pop    %ebx
  8085f9:	5d                   	pop    %ebp
  8085fa:	c3                   	ret    

008085fb <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  8085fb:	55                   	push   %ebp
  8085fc:	89 e5                	mov    %esp,%ebp
  8085fe:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  808601:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  808608:	00 
  808609:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  808610:	00 
  808611:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  808618:	00 
  808619:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80861d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808621:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808628:	00 
  808629:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808630:	00 
  808631:	8b 45 08             	mov    0x8(%ebp),%eax
  808634:	89 04 24             	mov    %eax,(%esp)
  808637:	e8 a8 f8 ff ff       	call   807ee4 <tcp_enqueue>
}
  80863c:	c9                   	leave  
  80863d:	c3                   	ret    

0080863e <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80863e:	55                   	push   %ebp
  80863f:	89 e5                	mov    %esp,%ebp
  808641:	57                   	push   %edi
  808642:	56                   	push   %esi
  808643:	53                   	push   %ebx
  808644:	83 ec 3c             	sub    $0x3c,%esp
  808647:	8b 75 08             	mov    0x8(%ebp),%esi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80864a:	39 35 98 c2 b3 00    	cmp    %esi,0xb3c298
  808650:	0f 84 5a 04 00 00    	je     808ab0 <tcp_output+0x472>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  808656:	66 8b 56 4e          	mov    0x4e(%esi),%dx
  80865a:	8b 46 5c             	mov    0x5c(%esi),%eax
  80865d:	66 39 d0             	cmp    %dx,%ax
  808660:	76 02                	jbe    808664 <tcp_output+0x26>
  808662:	89 d0                	mov    %edx,%eax
  808664:	0f b7 c0             	movzwl %ax,%eax
  808667:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  80866a:	8b 5e 74             	mov    0x74(%esi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80866d:	8b 7e 78             	mov    0x78(%esi),%edi
  if (useg != NULL) {
  808670:	85 ff                	test   %edi,%edi
  808672:	75 04                	jne    808678 <tcp_output+0x3a>
  808674:	eb 08                	jmp    80867e <tcp_output+0x40>
    for (; useg->next != NULL; useg = useg->next);
  808676:	89 c7                	mov    %eax,%edi
  808678:	8b 07                	mov    (%edi),%eax
  80867a:	85 c0                	test   %eax,%eax
  80867c:	75 f8                	jne    808676 <tcp_output+0x38>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80867e:	f6 46 20 02          	testb  $0x2,0x20(%esi)
  808682:	0f 84 ba 03 00 00    	je     808a42 <tcp_output+0x404>
  808688:	85 db                	test   %ebx,%ebx
  80868a:	74 20                	je     8086ac <tcp_output+0x6e>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80868c:	8b 43 10             	mov    0x10(%ebx),%eax
  80868f:	8b 40 04             	mov    0x4(%eax),%eax
  808692:	89 04 24             	mov    %eax,(%esp)
  808695:	e8 35 f8 ff ff       	call   807ecf <ntohl>
  80869a:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80869e:	2b 56 48             	sub    0x48(%esi),%edx
  8086a1:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  8086a3:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  8086a6:	0f 83 96 03 00 00    	jae    808a42 <tcp_output+0x404>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8086ac:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8086b3:	00 
  8086b4:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8086bb:	00 
  8086bc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8086c3:	e8 8a c8 ff ff       	call   804f52 <pbuf_alloc>
  8086c8:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  8086ca:	85 c0                	test   %eax,%eax
  8086cc:	0f 84 e2 03 00 00    	je     808ab4 <tcp_output+0x476>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8086d2:	80 66 20 fc          	andb   $0xfc,0x20(%esi)

    tcphdr = p->payload;
  8086d6:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  8086d9:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8086dd:	89 04 24             	mov    %eax,(%esp)
  8086e0:	e8 74 f5 ff ff       	call   807c59 <htons>
  8086e5:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  8086e8:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8086ec:	89 04 24             	mov    %eax,(%esp)
  8086ef:	e8 65 f5 ff ff       	call   807c59 <htons>
  8086f4:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8086f8:	8b 46 54             	mov    0x54(%esi),%eax
  8086fb:	89 04 24             	mov    %eax,(%esp)
  8086fe:	e8 76 f5 ff ff       	call   807c79 <htonl>
  808703:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  808706:	8b 46 24             	mov    0x24(%esi),%eax
  808709:	89 04 24             	mov    %eax,(%esp)
  80870c:	e8 68 f5 ff ff       	call   807c79 <htonl>
  808711:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  808714:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808718:	89 04 24             	mov    %eax,(%esp)
  80871b:	e8 45 f5 ff ff       	call   807c65 <ntohs>
  808720:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808725:	83 c8 10             	or     $0x10,%eax
  808728:	89 04 24             	mov    %eax,(%esp)
  80872b:	e8 29 f5 ff ff       	call   807c59 <htons>
  808730:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808734:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808738:	89 04 24             	mov    %eax,(%esp)
  80873b:	e8 19 f5 ff ff       	call   807c59 <htons>
  808740:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  808744:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80874a:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80874e:	89 04 24             	mov    %eax,(%esp)
  808751:	e8 0f f5 ff ff       	call   807c65 <ntohs>
  808756:	83 e0 3f             	and    $0x3f,%eax
  808759:	80 cc 50             	or     $0x50,%ah
  80875c:	89 04 24             	mov    %eax,(%esp)
  80875f:	e8 f5 f4 ff ff       	call   807c59 <htons>
  808764:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  808768:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80876e:	8d 46 04             	lea    0x4(%esi),%eax
  808771:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808774:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808778:	89 44 24 10          	mov    %eax,0x10(%esp)
  80877c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808783:	00 
  808784:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808787:	89 54 24 08          	mov    %edx,0x8(%esp)
  80878b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80878f:	89 3c 24             	mov    %edi,(%esp)
  808792:	e8 7d f1 ff ff       	call   807914 <inet_chksum_pseudo>
  808797:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80879b:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  8087a2:	00 
  8087a3:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  8087a7:	89 44 24 10          	mov    %eax,0x10(%esp)
  8087ab:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8087af:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8087b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8087b6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8087ba:	89 74 24 04          	mov    %esi,0x4(%esp)
  8087be:	89 3c 24             	mov    %edi,(%esp)
  8087c1:	e8 a1 e6 ff ff       	call   806e67 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  8087c6:	89 3c 24             	mov    %edi,(%esp)
  8087c9:	e8 83 c5 ff ff       	call   804d51 <pbuf_free>

    return ERR_OK;
  8087ce:	b0 00                	mov    $0x0,%al
  8087d0:	e9 e1 02 00 00       	jmp    808ab6 <tcp_output+0x478>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  8087d5:	8b 43 10             	mov    0x10(%ebx),%eax
  8087d8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8087dc:	89 04 24             	mov    %eax,(%esp)
  8087df:	e8 81 f4 ff ff       	call   807c65 <ntohs>
  8087e4:	a8 04                	test   $0x4,%al
  8087e6:	74 1c                	je     808804 <tcp_output+0x1c6>
  8087e8:	c7 44 24 08 af 2d 81 	movl   $0x812daf,0x8(%esp)
  8087ef:	00 
  8087f0:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  8087f7:	00 
  8087f8:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  8087ff:	e8 7c 66 00 00       	call   80ee80 <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808804:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  808808:	74 1c                	je     808826 <tcp_output+0x1e8>
  80880a:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  80880e:	a8 40                	test   $0x40,%al
  808810:	75 14                	jne    808826 <tcp_output+0x1e8>
  808812:	8b 56 74             	mov    0x74(%esi),%edx
  808815:	85 d2                	test   %edx,%edx
  808817:	0f 84 a1 02 00 00    	je     808abe <tcp_output+0x480>
  80881d:	83 3a 00             	cmpl   $0x0,(%edx)
  808820:	0f 84 98 02 00 00    	je     808abe <tcp_output+0x480>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  808826:	8b 03                	mov    (%ebx),%eax
  808828:	89 46 74             	mov    %eax,0x74(%esi)

    if (pcb->state != SYN_SENT) {
  80882b:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  80882f:	74 25                	je     808856 <tcp_output+0x218>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  808831:	8b 7b 10             	mov    0x10(%ebx),%edi
  808834:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  808838:	89 04 24             	mov    %eax,(%esp)
  80883b:	e8 25 f4 ff ff       	call   807c65 <ntohs>
  808840:	83 c8 10             	or     $0x10,%eax
  808843:	0f b7 c0             	movzwl %ax,%eax
  808846:	89 04 24             	mov    %eax,(%esp)
  808849:	e8 0b f4 ff ff       	call   807c59 <htons>
  80884e:	66 89 47 0c          	mov    %ax,0xc(%edi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808852:	80 66 20 fc          	andb   $0xfc,0x20(%esi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  808856:	8b 7b 10             	mov    0x10(%ebx),%edi
  808859:	8b 46 24             	mov    0x24(%esi),%eax
  80885c:	89 04 24             	mov    %eax,(%esp)
  80885f:	e8 15 f4 ff ff       	call   807c79 <htonl>
  808864:	89 47 08             	mov    %eax,0x8(%edi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808867:	8b 7b 10             	mov    0x10(%ebx),%edi
  80886a:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80886e:	89 04 24             	mov    %eax,(%esp)
  808871:	e8 e3 f3 ff ff       	call   807c59 <htons>
  808876:	66 89 47 0e          	mov    %ax,0xe(%edi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80887a:	85 f6                	test   %esi,%esi
  80887c:	74 05                	je     808883 <tcp_output+0x245>
  80887e:	83 3e 00             	cmpl   $0x0,(%esi)
  808881:	75 24                	jne    8088a7 <tcp_output+0x269>
    netif = ip_route(&(pcb->remote_ip));
  808883:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808886:	89 14 24             	mov    %edx,(%esp)
  808889:	e8 52 e1 ff ff       	call   8069e0 <ip_route>
    if (netif == NULL) {
  80888e:	85 c0                	test   %eax,%eax
  808890:	0f 84 bf 00 00 00    	je     808955 <tcp_output+0x317>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  808896:	83 f8 fc             	cmp    $0xfffffffc,%eax
  808899:	74 05                	je     8088a0 <tcp_output+0x262>
  80889b:	8b 40 04             	mov    0x4(%eax),%eax
  80889e:	eb 05                	jmp    8088a5 <tcp_output+0x267>
  8088a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8088a5:	89 06                	mov    %eax,(%esi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  8088a7:	66 83 7e 32 ff       	cmpw   $0xffffffff,0x32(%esi)
  8088ac:	75 06                	jne    8088b4 <tcp_output+0x276>
    pcb->rtime = 0;
  8088ae:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

  if (pcb->rttest == 0) {
  8088b4:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
  8088b8:	75 19                	jne    8088d3 <tcp_output+0x295>
    pcb->rttest = tcp_ticks;
  8088ba:	a1 80 c2 b3 00       	mov    0xb3c280,%eax
  8088bf:	89 46 38             	mov    %eax,0x38(%esi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8088c2:	8b 43 10             	mov    0x10(%ebx),%eax
  8088c5:	8b 40 04             	mov    0x4(%eax),%eax
  8088c8:	89 04 24             	mov    %eax,(%esp)
  8088cb:	e8 ff f5 ff ff       	call   807ecf <ntohl>
  8088d0:	89 46 3c             	mov    %eax,0x3c(%esi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  8088d3:	8b 43 04             	mov    0x4(%ebx),%eax
  8088d6:	8b 53 10             	mov    0x10(%ebx),%edx
  8088d9:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  8088dd:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  8088e1:	8b 43 04             	mov    0x4(%ebx),%eax
  8088e4:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  8088e8:	8b 43 04             	mov    0x4(%ebx),%eax
  8088eb:	8b 53 10             	mov    0x10(%ebx),%edx
  8088ee:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  8088f1:	8b 43 10             	mov    0x10(%ebx),%eax
  8088f4:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8088fa:	8b 7b 10             	mov    0x10(%ebx),%edi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  8088fd:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808900:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808904:	89 54 24 10          	mov    %edx,0x10(%esp)
  808908:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80890f:	00 
  808910:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808913:	89 54 24 08          	mov    %edx,0x8(%esp)
  808917:	89 74 24 04          	mov    %esi,0x4(%esp)
  80891b:	89 04 24             	mov    %eax,(%esp)
  80891e:	e8 f1 ef ff ff       	call   807914 <inet_chksum_pseudo>
  808923:	66 89 47 10          	mov    %ax,0x10(%edi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808927:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80892e:	00 
  80892f:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  808933:	89 44 24 10          	mov    %eax,0x10(%esp)
  808937:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80893b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80893f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808942:	89 44 24 08          	mov    %eax,0x8(%esp)
  808946:	89 74 24 04          	mov    %esi,0x4(%esp)
  80894a:	8b 43 04             	mov    0x4(%ebx),%eax
  80894d:	89 04 24             	mov    %eax,(%esp)
  808950:	e8 12 e5 ff ff       	call   806e67 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808955:	8b 43 10             	mov    0x10(%ebx),%eax
  808958:	8b 40 04             	mov    0x4(%eax),%eax
  80895b:	89 04 24             	mov    %eax,(%esp)
  80895e:	e8 6c f5 ff ff       	call   807ecf <ntohl>
  808963:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808966:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80896a:	8b 43 10             	mov    0x10(%ebx),%eax
  80896d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808971:	89 04 24             	mov    %eax,(%esp)
  808974:	e8 ec f2 ff ff       	call   807c65 <ntohs>
  808979:	a8 01                	test   $0x1,%al
  80897b:	75 1a                	jne    808997 <tcp_output+0x359>
  80897d:	8b 43 10             	mov    0x10(%ebx),%eax
  808980:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808984:	89 04 24             	mov    %eax,(%esp)
  808987:	e8 d9 f2 ff ff       	call   807c65 <ntohs>
  80898c:	83 e0 02             	and    $0x2,%eax
  80898f:	0f 95 c0             	setne  %al
  808992:	0f b6 c0             	movzbl %al,%eax
  808995:	eb 05                	jmp    80899c <tcp_output+0x35e>
  808997:	b8 01 00 00 00       	mov    $0x1,%eax
  80899c:	01 c7                	add    %eax,%edi
  80899e:	03 7d e0             	add    -0x20(%ebp),%edi
  8089a1:	89 7e 54             	mov    %edi,0x54(%esi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8089a4:	39 7e 58             	cmp    %edi,0x58(%esi)
  8089a7:	79 03                	jns    8089ac <tcp_output+0x36e>
      pcb->snd_max = pcb->snd_nxt;
  8089a9:	89 7e 58             	mov    %edi,0x58(%esi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  8089ac:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  8089b0:	8b 43 10             	mov    0x10(%ebx),%eax
  8089b3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8089b7:	89 04 24             	mov    %eax,(%esp)
  8089ba:	e8 a6 f2 ff ff       	call   807c65 <ntohs>
  8089bf:	a8 01                	test   $0x1,%al
  8089c1:	75 1a                	jne    8089dd <tcp_output+0x39f>
  8089c3:	8b 43 10             	mov    0x10(%ebx),%eax
  8089c6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8089ca:	89 04 24             	mov    %eax,(%esp)
  8089cd:	e8 93 f2 ff ff       	call   807c65 <ntohs>
  8089d2:	83 e0 02             	and    $0x2,%eax
  8089d5:	0f 95 c0             	setne  %al
  8089d8:	0f b6 c0             	movzbl %al,%eax
  8089db:	eb 05                	jmp    8089e2 <tcp_output+0x3a4>
  8089dd:	b8 01 00 00 00       	mov    $0x1,%eax
  8089e2:	01 c7                	add    %eax,%edi
  8089e4:	85 ff                	test   %edi,%edi
  8089e6:	7e 4d                	jle    808a35 <tcp_output+0x3f7>
      seg->next = NULL;
  8089e8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  8089ee:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  8089f2:	75 08                	jne    8089fc <tcp_output+0x3be>
        pcb->unacked = seg;
  8089f4:	89 5e 78             	mov    %ebx,0x78(%esi)
  8089f7:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  8089fa:	eb 41                	jmp    808a3d <tcp_output+0x3ff>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8089fc:	8b 43 10             	mov    0x10(%ebx),%eax
  8089ff:	8b 40 04             	mov    0x4(%eax),%eax
  808a02:	89 04 24             	mov    %eax,(%esp)
  808a05:	e8 c5 f4 ff ff       	call   807ecf <ntohl>
  808a0a:	89 c7                	mov    %eax,%edi
  808a0c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808a0f:	8b 42 10             	mov    0x10(%edx),%eax
  808a12:	8b 40 04             	mov    0x4(%eax),%eax
  808a15:	89 04 24             	mov    %eax,(%esp)
  808a18:	e8 b2 f4 ff ff       	call   807ecf <ntohl>
  808a1d:	39 c7                	cmp    %eax,%edi
  808a1f:	79 0a                	jns    808a2b <tcp_output+0x3ed>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  808a21:	8b 46 78             	mov    0x78(%esi),%eax
  808a24:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  808a26:	89 5e 78             	mov    %ebx,0x78(%esi)
  808a29:	eb 12                	jmp    808a3d <tcp_output+0x3ff>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  808a2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808a2e:	89 18                	mov    %ebx,(%eax)
  808a30:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808a33:	eb 08                	jmp    808a3d <tcp_output+0x3ff>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  808a35:	89 1c 24             	mov    %ebx,(%esp)
  808a38:	e8 88 d2 ff ff       	call   805cc5 <tcp_seg_free>
    }
    seg = pcb->unsent;
  808a3d:	8b 5e 74             	mov    0x74(%esi),%ebx
  808a40:	eb 09                	jmp    808a4b <tcp_output+0x40d>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808a42:	8d 56 04             	lea    0x4(%esi),%edx
  808a45:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808a48:	89 7d dc             	mov    %edi,-0x24(%ebp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808a4b:	85 db                	test   %ebx,%ebx
  808a4d:	74 59                	je     808aa8 <tcp_output+0x46a>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808a4f:	8b 43 10             	mov    0x10(%ebx),%eax
  808a52:	8b 40 04             	mov    0x4(%eax),%eax
  808a55:	89 04 24             	mov    %eax,(%esp)
  808a58:	e8 72 f4 ff ff       	call   807ecf <ntohl>
  808a5d:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808a61:	2b 56 48             	sub    0x48(%esi),%edx
  808a64:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808a66:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  808a69:	0f 83 66 fd ff ff    	jae    8087d5 <tcp_output+0x197>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808a6f:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  808a76:	75 30                	jne    808aa8 <tcp_output+0x46a>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808a78:	8b 43 10             	mov    0x10(%ebx),%eax
  808a7b:	8b 40 04             	mov    0x4(%eax),%eax
  808a7e:	89 04 24             	mov    %eax,(%esp)
  808a81:	e8 49 f4 ff ff       	call   807ecf <ntohl>
  808a86:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808a8a:	2b 56 48             	sub    0x48(%esi),%edx
  808a8d:	01 c2                	add    %eax,%edx
  808a8f:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808a93:	39 c2                	cmp    %eax,%edx
  808a95:	76 11                	jbe    808aa8 <tcp_output+0x46a>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  808a97:	c7 86 a0 00 00 00 00 	movl   $0x0,0xa0(%esi)
  808a9e:	00 00 00 
    pcb->persist_backoff = 1;
  808aa1:	c6 86 a4 00 00 00 01 	movb   $0x1,0xa4(%esi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  808aa8:	80 66 20 7f          	andb   $0x7f,0x20(%esi)
  return ERR_OK;
  808aac:	b0 00                	mov    $0x0,%al
  808aae:	eb 06                	jmp    808ab6 <tcp_output+0x478>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  808ab0:	b0 00                	mov    $0x0,%al
  808ab2:	eb 02                	jmp    808ab6 <tcp_output+0x478>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  808ab4:	b0 fe                	mov    $0xfe,%al
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  808ab6:	83 c4 3c             	add    $0x3c,%esp
  808ab9:	5b                   	pop    %ebx
  808aba:	5e                   	pop    %esi
  808abb:	5f                   	pop    %edi
  808abc:	5d                   	pop    %ebp
  808abd:	c3                   	ret    
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808abe:	a8 a0                	test   $0xa0,%al
  808ac0:	0f 85 60 fd ff ff    	jne    808826 <tcp_output+0x1e8>
  808ac6:	eb a7                	jmp    808a6f <tcp_output+0x431>

00808ac8 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808ac8:	55                   	push   %ebp
  808ac9:	89 e5                	mov    %esp,%ebp
  808acb:	57                   	push   %edi
  808acc:	56                   	push   %esi
  808acd:	53                   	push   %ebx
  808ace:	83 ec 3c             	sub    $0x3c,%esp
  808ad1:	8b 7d 18             	mov    0x18(%ebp),%edi
  808ad4:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808ad7:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808adb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808ae2:	00 
  808ae3:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808aea:	00 
  808aeb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808af2:	e8 5b c4 ff ff       	call   804f52 <pbuf_alloc>
  808af7:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  808af9:	85 c0                	test   %eax,%eax
  808afb:	0f 84 1a 01 00 00    	je     808c1b <tcp_rst+0x153>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808b01:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808b06:	77 1c                	ja     808b24 <tcp_rst+0x5c>
  808b08:	c7 44 24 08 48 2d 81 	movl   $0x812d48,0x8(%esp)
  808b0f:	00 
  808b10:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  808b17:	00 
  808b18:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  808b1f:	e8 5c 63 00 00       	call   80ee80 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808b24:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  808b27:	0f b7 ff             	movzwl %di,%edi
  808b2a:	89 3c 24             	mov    %edi,(%esp)
  808b2d:	e8 27 f1 ff ff       	call   807c59 <htons>
  808b32:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  808b35:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  808b39:	89 04 24             	mov    %eax,(%esp)
  808b3c:	e8 18 f1 ff ff       	call   807c59 <htons>
  808b41:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  808b45:	8b 45 08             	mov    0x8(%ebp),%eax
  808b48:	89 04 24             	mov    %eax,(%esp)
  808b4b:	e8 29 f1 ff ff       	call   807c79 <htonl>
  808b50:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808b53:	8b 45 0c             	mov    0xc(%ebp),%eax
  808b56:	89 04 24             	mov    %eax,(%esp)
  808b59:	e8 1b f1 ff ff       	call   807c79 <htonl>
  808b5e:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808b61:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808b65:	89 04 24             	mov    %eax,(%esp)
  808b68:	e8 f8 f0 ff ff       	call   807c65 <ntohs>
  808b6d:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808b72:	83 c8 14             	or     $0x14,%eax
  808b75:	89 04 24             	mov    %eax,(%esp)
  808b78:	e8 dc f0 ff ff       	call   807c59 <htons>
  808b7d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808b81:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808b88:	e8 cc f0 ff ff       	call   807c59 <htons>
  808b8d:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808b91:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808b97:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808b9b:	89 04 24             	mov    %eax,(%esp)
  808b9e:	e8 c2 f0 ff ff       	call   807c65 <ntohs>
  808ba3:	83 e0 3f             	and    $0x3f,%eax
  808ba6:	80 cc 50             	or     $0x50,%ah
  808ba9:	89 04 24             	mov    %eax,(%esp)
  808bac:	e8 a8 f0 ff ff       	call   807c59 <htons>
  808bb1:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808bb5:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808bbb:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808bbf:	89 44 24 10          	mov    %eax,0x10(%esp)
  808bc3:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808bca:	00 
  808bcb:	8b 45 14             	mov    0x14(%ebp),%eax
  808bce:	89 44 24 08          	mov    %eax,0x8(%esp)
  808bd2:	8b 45 10             	mov    0x10(%ebp),%eax
  808bd5:	89 44 24 04          	mov    %eax,0x4(%esp)
  808bd9:	89 34 24             	mov    %esi,(%esp)
  808bdc:	e8 33 ed ff ff       	call   807914 <inet_chksum_pseudo>
  808be1:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  808be5:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808bec:	00 
  808bed:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808bf4:	00 
  808bf5:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  808bfc:	00 
  808bfd:	8b 45 14             	mov    0x14(%ebp),%eax
  808c00:	89 44 24 08          	mov    %eax,0x8(%esp)
  808c04:	8b 45 10             	mov    0x10(%ebp),%eax
  808c07:	89 44 24 04          	mov    %eax,0x4(%esp)
  808c0b:	89 34 24             	mov    %esi,(%esp)
  808c0e:	e8 54 e2 ff ff       	call   806e67 <ip_output>
  pbuf_free(p);
  808c13:	89 34 24             	mov    %esi,(%esp)
  808c16:	e8 36 c1 ff ff       	call   804d51 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  808c1b:	83 c4 3c             	add    $0x3c,%esp
  808c1e:	5b                   	pop    %ebx
  808c1f:	5e                   	pop    %esi
  808c20:	5f                   	pop    %edi
  808c21:	5d                   	pop    %ebp
  808c22:	c3                   	ret    

00808c23 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  808c23:	55                   	push   %ebp
  808c24:	89 e5                	mov    %esp,%ebp
  808c26:	53                   	push   %ebx
  808c27:	83 ec 14             	sub    $0x14,%esp
  808c2a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808c2d:	8b 53 78             	mov    0x78(%ebx),%edx
  808c30:	85 d2                	test   %edx,%edx
  808c32:	75 04                	jne    808c38 <tcp_rexmit_rto+0x15>
  808c34:	eb 3d                	jmp    808c73 <tcp_rexmit_rto+0x50>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  808c36:	89 c2                	mov    %eax,%edx
  808c38:	8b 02                	mov    (%edx),%eax
  808c3a:	85 c0                	test   %eax,%eax
  808c3c:	75 f8                	jne    808c36 <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  808c3e:	8b 43 74             	mov    0x74(%ebx),%eax
  808c41:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  808c43:	8b 43 78             	mov    0x78(%ebx),%eax
  808c46:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  808c49:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808c50:	8b 40 10             	mov    0x10(%eax),%eax
  808c53:	8b 40 04             	mov    0x4(%eax),%eax
  808c56:	89 04 24             	mov    %eax,(%esp)
  808c59:	e8 71 f2 ff ff       	call   807ecf <ntohl>
  808c5e:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  808c61:	fe 43 46             	incb   0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  808c64:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808c6b:	89 1c 24             	mov    %ebx,(%esp)
  808c6e:	e8 cb f9 ff ff       	call   80863e <tcp_output>
}
  808c73:	83 c4 14             	add    $0x14,%esp
  808c76:	5b                   	pop    %ebx
  808c77:	5d                   	pop    %ebp
  808c78:	c3                   	ret    

00808c79 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808c79:	55                   	push   %ebp
  808c7a:	89 e5                	mov    %esp,%ebp
  808c7c:	53                   	push   %ebx
  808c7d:	83 ec 14             	sub    $0x14,%esp
  808c80:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808c83:	8b 43 78             	mov    0x78(%ebx),%eax
  808c86:	85 c0                	test   %eax,%eax
  808c88:	74 33                	je     808cbd <tcp_rexmit+0x44>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808c8a:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808c8c:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808c8f:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808c91:	8b 43 78             	mov    0x78(%ebx),%eax
  808c94:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808c97:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808c9a:	8b 40 10             	mov    0x10(%eax),%eax
  808c9d:	8b 40 04             	mov    0x4(%eax),%eax
  808ca0:	89 04 24             	mov    %eax,(%esp)
  808ca3:	e8 27 f2 ff ff       	call   807ecf <ntohl>
  808ca8:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808cab:	fe 43 46             	incb   0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808cae:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808cb5:	89 1c 24             	mov    %ebx,(%esp)
  808cb8:	e8 81 f9 ff ff       	call   80863e <tcp_output>
}
  808cbd:	83 c4 14             	add    $0x14,%esp
  808cc0:	5b                   	pop    %ebx
  808cc1:	5d                   	pop    %ebp
  808cc2:	c3                   	ret    

00808cc3 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808cc3:	55                   	push   %ebp
  808cc4:	89 e5                	mov    %esp,%ebp
  808cc6:	57                   	push   %edi
  808cc7:	56                   	push   %esi
  808cc8:	53                   	push   %ebx
  808cc9:	83 ec 3c             	sub    $0x3c,%esp
  808ccc:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808ccf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808cd6:	00 
  808cd7:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808cde:	00 
  808cdf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808ce6:	e8 67 c2 ff ff       	call   804f52 <pbuf_alloc>
  808ceb:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808ced:	85 c0                	test   %eax,%eax
  808cef:	0f 84 19 01 00 00    	je     808e0e <tcp_keepalive+0x14b>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808cf5:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808cfa:	77 1c                	ja     808d18 <tcp_keepalive+0x55>
  808cfc:	c7 44 24 08 48 2d 81 	movl   $0x812d48,0x8(%esp)
  808d03:	00 
  808d04:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  808d0b:	00 
  808d0c:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  808d13:	e8 68 61 00 00       	call   80ee80 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808d18:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808d1b:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808d1f:	89 04 24             	mov    %eax,(%esp)
  808d22:	e8 32 ef ff ff       	call   807c59 <htons>
  808d27:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808d2a:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808d2e:	89 04 24             	mov    %eax,(%esp)
  808d31:	e8 23 ef ff ff       	call   807c59 <htons>
  808d36:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  808d3a:	8b 46 54             	mov    0x54(%esi),%eax
  808d3d:	48                   	dec    %eax
  808d3e:	89 04 24             	mov    %eax,(%esp)
  808d41:	e8 33 ef ff ff       	call   807c79 <htonl>
  808d46:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808d49:	8b 46 24             	mov    0x24(%esi),%eax
  808d4c:	89 04 24             	mov    %eax,(%esp)
  808d4f:	e8 25 ef ff ff       	call   807c79 <htonl>
  808d54:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808d57:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808d5b:	89 04 24             	mov    %eax,(%esp)
  808d5e:	e8 02 ef ff ff       	call   807c65 <ntohs>
  808d63:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808d68:	89 04 24             	mov    %eax,(%esp)
  808d6b:	e8 e9 ee ff ff       	call   807c59 <htons>
  808d70:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808d74:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808d78:	89 04 24             	mov    %eax,(%esp)
  808d7b:	e8 d9 ee ff ff       	call   807c59 <htons>
  808d80:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808d84:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808d8a:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808d8e:	89 04 24             	mov    %eax,(%esp)
  808d91:	e8 cf ee ff ff       	call   807c65 <ntohs>
  808d96:	83 e0 3f             	and    $0x3f,%eax
  808d99:	80 cc 50             	or     $0x50,%ah
  808d9c:	89 04 24             	mov    %eax,(%esp)
  808d9f:	e8 b5 ee ff ff       	call   807c59 <htons>
  808da4:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808da8:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808dae:	8d 46 04             	lea    0x4(%esi),%eax
  808db1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808db4:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808db8:	89 44 24 10          	mov    %eax,0x10(%esp)
  808dbc:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808dc3:	00 
  808dc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808dc7:	89 44 24 08          	mov    %eax,0x8(%esp)
  808dcb:	89 74 24 04          	mov    %esi,0x4(%esp)
  808dcf:	89 3c 24             	mov    %edi,(%esp)
  808dd2:	e8 3d eb ff ff       	call   807914 <inet_chksum_pseudo>
  808dd7:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808ddb:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808de2:	00 
  808de3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808dea:	00 
  808deb:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808def:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808df3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808df6:	89 44 24 08          	mov    %eax,0x8(%esp)
  808dfa:	89 74 24 04          	mov    %esi,0x4(%esp)
  808dfe:	89 3c 24             	mov    %edi,(%esp)
  808e01:	e8 61 e0 ff ff       	call   806e67 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808e06:	89 3c 24             	mov    %edi,(%esp)
  808e09:	e8 43 bf ff ff       	call   804d51 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808e0e:	83 c4 3c             	add    $0x3c,%esp
  808e11:	5b                   	pop    %ebx
  808e12:	5e                   	pop    %esi
  808e13:	5f                   	pop    %edi
  808e14:	5d                   	pop    %ebp
  808e15:	c3                   	ret    

00808e16 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  808e16:	55                   	push   %ebp
  808e17:	89 e5                	mov    %esp,%ebp
  808e19:	57                   	push   %edi
  808e1a:	56                   	push   %esi
  808e1b:	53                   	push   %ebx
  808e1c:	83 ec 3c             	sub    $0x3c,%esp
  808e1f:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808e22:	8b 46 78             	mov    0x78(%esi),%eax
  808e25:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808e28:	85 c0                	test   %eax,%eax
  808e2a:	75 0e                	jne    808e3a <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  808e2c:	8b 56 74             	mov    0x74(%esi),%edx
  808e2f:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  if(seg == NULL)
  808e32:	85 d2                	test   %edx,%edx
  808e34:	0f 84 4a 01 00 00    	je     808f84 <tcp_zero_window_probe+0x16e>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808e3a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808e41:	00 
  808e42:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  808e49:	00 
  808e4a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808e51:	e8 fc c0 ff ff       	call   804f52 <pbuf_alloc>
  808e56:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808e58:	85 c0                	test   %eax,%eax
  808e5a:	0f 84 24 01 00 00    	je     808f84 <tcp_zero_window_probe+0x16e>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808e60:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808e65:	77 1c                	ja     808e83 <tcp_zero_window_probe+0x6d>
  808e67:	c7 44 24 08 48 2d 81 	movl   $0x812d48,0x8(%esp)
  808e6e:	00 
  808e6f:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  808e76:	00 
  808e77:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  808e7e:	e8 fd 5f 00 00       	call   80ee80 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808e83:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808e86:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808e8a:	89 04 24             	mov    %eax,(%esp)
  808e8d:	e8 c7 ed ff ff       	call   807c59 <htons>
  808e92:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808e95:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808e99:	89 04 24             	mov    %eax,(%esp)
  808e9c:	e8 b8 ed ff ff       	call   807c59 <htons>
  808ea1:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808ea5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808ea8:	8b 41 10             	mov    0x10(%ecx),%eax
  808eab:	8b 40 04             	mov    0x4(%eax),%eax
  808eae:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808eb1:	8b 46 24             	mov    0x24(%esi),%eax
  808eb4:	89 04 24             	mov    %eax,(%esp)
  808eb7:	e8 bd ed ff ff       	call   807c79 <htonl>
  808ebc:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808ebf:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808ec3:	89 04 24             	mov    %eax,(%esp)
  808ec6:	e8 9a ed ff ff       	call   807c65 <ntohs>
  808ecb:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808ed0:	89 04 24             	mov    %eax,(%esp)
  808ed3:	e8 81 ed ff ff       	call   807c59 <htons>
  808ed8:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808edc:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808ee0:	89 04 24             	mov    %eax,(%esp)
  808ee3:	e8 71 ed ff ff       	call   807c59 <htons>
  808ee8:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808eec:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808ef2:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808ef6:	89 04 24             	mov    %eax,(%esp)
  808ef9:	e8 67 ed ff ff       	call   807c65 <ntohs>
  808efe:	83 e0 3f             	and    $0x3f,%eax
  808f01:	80 cc 50             	or     $0x50,%ah
  808f04:	89 04 24             	mov    %eax,(%esp)
  808f07:	e8 4d ed ff ff       	call   807c59 <htons>
  808f0c:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808f10:	8b 47 04             	mov    0x4(%edi),%eax
  808f13:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808f16:	8b 51 08             	mov    0x8(%ecx),%edx
  808f19:	8a 12                	mov    (%edx),%dl
  808f1b:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808f1e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808f24:	8d 46 04             	lea    0x4(%esi),%eax
  808f27:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808f2a:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808f2e:	89 44 24 10          	mov    %eax,0x10(%esp)
  808f32:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808f39:	00 
  808f3a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808f3d:	89 54 24 08          	mov    %edx,0x8(%esp)
  808f41:	89 74 24 04          	mov    %esi,0x4(%esp)
  808f45:	89 3c 24             	mov    %edi,(%esp)
  808f48:	e8 c7 e9 ff ff       	call   807914 <inet_chksum_pseudo>
  808f4d:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808f51:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808f58:	00 
  808f59:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808f60:	00 
  808f61:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808f65:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808f69:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808f6c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  808f70:	89 74 24 04          	mov    %esi,0x4(%esp)
  808f74:	89 3c 24             	mov    %edi,(%esp)
  808f77:	e8 eb de ff ff       	call   806e67 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808f7c:	89 3c 24             	mov    %edi,(%esp)
  808f7f:	e8 cd bd ff ff       	call   804d51 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808f84:	83 c4 3c             	add    $0x3c,%esp
  808f87:	5b                   	pop    %ebx
  808f88:	5e                   	pop    %esi
  808f89:	5f                   	pop    %edi
  808f8a:	5d                   	pop    %ebp
  808f8b:	c3                   	ret    

00808f8c <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  808f8c:	55                   	push   %ebp
  808f8d:	89 e5                	mov    %esp,%ebp
  808f8f:	57                   	push   %edi
  808f90:	56                   	push   %esi
  808f91:	53                   	push   %ebx
  808f92:	83 ec 4c             	sub    $0x4c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  808f95:	8b 45 08             	mov    0x8(%ebp),%eax
  808f98:	8b 40 04             	mov    0x4(%eax),%eax
  808f9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  808f9e:	8b 55 08             	mov    0x8(%ebp),%edx
  808fa1:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  808fa5:	0f b7 00             	movzwl (%eax),%eax
  808fa8:	89 04 24             	mov    %eax,(%esp)
  808fab:	e8 b5 ec ff ff       	call   807c65 <ntohs>
  808fb0:	0f b6 c4             	movzbl %ah,%eax
  808fb3:	83 e0 0f             	and    $0xf,%eax
  808fb6:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808fbd:	39 c3                	cmp    %eax,%ebx
  808fbf:	7c 2b                	jl     808fec <udp_input+0x60>
  808fc1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808fc4:	0f b7 02             	movzwl (%edx),%eax
  808fc7:	89 04 24             	mov    %eax,(%esp)
  808fca:	e8 96 ec ff ff       	call   807c65 <ntohs>
  808fcf:	66 c1 e8 06          	shr    $0x6,%ax
  808fd3:	83 e0 3c             	and    $0x3c,%eax
  808fd6:	f7 d8                	neg    %eax
  808fd8:	98                   	cwtl   
  808fd9:	89 44 24 04          	mov    %eax,0x4(%esp)
  808fdd:	8b 45 08             	mov    0x8(%ebp),%eax
  808fe0:	89 04 24             	mov    %eax,(%esp)
  808fe3:	e8 84 bc ff ff       	call   804c6c <pbuf_header>
  808fe8:	84 c0                	test   %al,%al
  808fea:	74 10                	je     808ffc <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808fec:	8b 55 08             	mov    0x8(%ebp),%edx
  808fef:	89 14 24             	mov    %edx,(%esp)
  808ff2:	e8 5a bd ff ff       	call   804d51 <pbuf_free>
    goto end;
  808ff7:	e9 fa 02 00 00       	jmp    8092f6 <udp_input+0x36a>
  }

  udphdr = (struct udp_hdr *)p->payload;
  808ffc:	8b 45 08             	mov    0x8(%ebp),%eax
  808fff:	8b 40 04             	mov    0x4(%eax),%eax
  809002:	89 45 d8             	mov    %eax,-0x28(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  809005:	0f b7 00             	movzwl (%eax),%eax
  809008:	89 04 24             	mov    %eax,(%esp)
  80900b:	e8 55 ec ff ff       	call   807c65 <ntohs>
  809010:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  dest = ntohs(udphdr->dest);
  809014:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809017:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80901b:	89 04 24             	mov    %eax,(%esp)
  80901e:	e8 42 ec ff ff       	call   807c65 <ntohs>
  809023:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  809025:	66 83 f8 44          	cmp    $0x44,%ax
  809029:	75 4e                	jne    809079 <udp_input+0xed>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80902b:	66 83 7d de 43       	cmpw   $0x43,-0x22(%ebp)
  809030:	0f 85 fa 00 00 00    	jne    809130 <udp_input+0x1a4>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  809036:	8b 55 0c             	mov    0xc(%ebp),%edx
  809039:	8b 42 20             	mov    0x20(%edx),%eax
  80903c:	85 c0                	test   %eax,%eax
  80903e:	0f 84 f3 00 00 00    	je     809137 <udp_input+0x1ab>
  809044:	8b 58 08             	mov    0x8(%eax),%ebx
  809047:	85 db                	test   %ebx,%ebx
  809049:	0f 84 ed 00 00 00    	je     80913c <udp_input+0x1b0>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80904f:	83 fb fc             	cmp    $0xfffffffc,%ebx
  809052:	0f 84 fb 00 00 00    	je     809153 <udp_input+0x1c7>
  809058:	8b 43 04             	mov    0x4(%ebx),%eax
  80905b:	85 c0                	test   %eax,%eax
  80905d:	0f 84 f0 00 00 00    	je     809153 <udp_input+0x1c7>
  809063:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809066:	3b 42 0c             	cmp    0xc(%edx),%eax
  809069:	0f 84 e4 00 00 00    	je     809153 <udp_input+0x1c7>
  80906f:	bb 00 00 00 00       	mov    $0x0,%ebx
  809074:	e9 c3 00 00 00       	jmp    80913c <udp_input+0x1b0>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  809079:	8b 1d 94 c2 b3 00    	mov    0xb3c294,%ebx
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  80907f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  809086:	bf 00 00 00 00       	mov    $0x0,%edi
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80908b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80908e:	83 c0 10             	add    $0x10,%eax
  809091:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  809094:	e9 84 00 00 00       	jmp    80911d <udp_input+0x191>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  809099:	66 39 73 12          	cmp    %si,0x12(%ebx)
  80909d:	75 79                	jne    809118 <udp_input+0x18c>
  80909f:	85 db                	test   %ebx,%ebx
  8090a1:	74 24                	je     8090c7 <udp_input+0x13b>
          (ip_addr_isany(&pcb->local_ip) ||
  8090a3:	8b 03                	mov    (%ebx),%eax
  8090a5:	85 c0                	test   %eax,%eax
  8090a7:	74 1e                	je     8090c7 <udp_input+0x13b>
  8090a9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8090ac:	3b 42 10             	cmp    0x10(%edx),%eax
  8090af:	74 16                	je     8090c7 <udp_input+0x13b>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8090b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8090b4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8090b8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8090bb:	89 14 24             	mov    %edx,(%esp)
  8090be:	e8 d9 d8 ff ff       	call   80699c <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  8090c3:	84 c0                	test   %al,%al
  8090c5:	74 51                	je     809118 <udp_input+0x18c>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  8090c7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8090cb:	0f 85 0a 02 00 00    	jne    8092db <udp_input+0x34f>
  8090d1:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  8090d5:	0f 84 fd 01 00 00    	je     8092d8 <udp_input+0x34c>
  8090db:	e9 fb 01 00 00       	jmp    8092db <udp_input+0x34f>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  8090e0:	83 fb fc             	cmp    $0xfffffffc,%ebx
  8090e3:	74 13                	je     8090f8 <udp_input+0x16c>
          (ip_addr_isany(&pcb->remote_ip) ||
  8090e5:	8b 43 04             	mov    0x4(%ebx),%eax
  8090e8:	85 c0                	test   %eax,%eax
  8090ea:	74 10                	je     8090fc <udp_input+0x170>
  8090ec:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8090ef:	3b 42 0c             	cmp    0xc(%edx),%eax
  8090f2:	75 24                	jne    809118 <udp_input+0x18c>
  8090f4:	89 d8                	mov    %ebx,%eax
  8090f6:	eb 06                	jmp    8090fe <udp_input+0x172>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  8090f8:	89 d8                	mov    %ebx,%eax
  8090fa:	eb 02                	jmp    8090fe <udp_input+0x172>
          (ip_addr_isany(&pcb->remote_ip) ||
  8090fc:	89 d8                	mov    %ebx,%eax
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  8090fe:	85 ff                	test   %edi,%edi
  809100:	74 51                	je     809153 <udp_input+0x1c7>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  809102:	8b 50 0c             	mov    0xc(%eax),%edx
  809105:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  809108:	8b 15 94 c2 b3 00    	mov    0xb3c294,%edx
  80910e:	89 50 0c             	mov    %edx,0xc(%eax)
          udp_pcbs = pcb;
  809111:	a3 94 c2 b3 00       	mov    %eax,0xb3c294
  809116:	eb 3b                	jmp    809153 <udp_input+0x1c7>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  809118:	89 df                	mov    %ebx,%edi
  80911a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80911d:	85 db                	test   %ebx,%ebx
  80911f:	0f 85 74 ff ff ff    	jne    809099 <udp_input+0x10d>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  809125:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  809129:	75 25                	jne    809150 <udp_input+0x1c4>
  80912b:	e9 be 01 00 00       	jmp    8092ee <udp_input+0x362>
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  809130:	bb 00 00 00 00       	mov    $0x0,%ebx
  809135:	eb 05                	jmp    80913c <udp_input+0x1b0>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  809137:	bb 00 00 00 00       	mov    $0x0,%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80913c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80913f:	8b 50 10             	mov    0x10(%eax),%edx
  809142:	8b 45 0c             	mov    0xc(%ebp),%eax
  809145:	39 50 04             	cmp    %edx,0x4(%eax)
  809148:	0f 85 7d 01 00 00    	jne    8092cb <udp_input+0x33f>
  80914e:	eb 03                	jmp    809153 <udp_input+0x1c7>
  809150:	8b 5d e0             	mov    -0x20(%ebp),%ebx
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  809153:	8b 45 d8             	mov    -0x28(%ebp),%eax
  809156:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80915b:	74 44                	je     8091a1 <udp_input+0x215>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80915d:	8b 55 08             	mov    0x8(%ebp),%edx
  809160:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  809164:	89 44 24 10          	mov    %eax,0x10(%esp)
  809168:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80916f:	00 
  809170:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809173:	83 c0 10             	add    $0x10,%eax
  809176:	89 44 24 08          	mov    %eax,0x8(%esp)
  80917a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80917d:	83 c0 0c             	add    $0xc,%eax
  809180:	89 44 24 04          	mov    %eax,0x4(%esp)
  809184:	89 14 24             	mov    %edx,(%esp)
  809187:	e8 88 e7 ff ff       	call   807914 <inet_chksum_pseudo>
  80918c:	66 85 c0             	test   %ax,%ax
  80918f:	74 10                	je     8091a1 <udp_input+0x215>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  809191:	8b 45 08             	mov    0x8(%ebp),%eax
  809194:	89 04 24             	mov    %eax,(%esp)
  809197:	e8 b5 bb ff ff       	call   804d51 <pbuf_free>
          goto end;
  80919c:	e9 55 01 00 00       	jmp    8092f6 <udp_input+0x36a>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  8091a1:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  8091a8:	ff 
  8091a9:	8b 55 08             	mov    0x8(%ebp),%edx
  8091ac:	89 14 24             	mov    %edx,(%esp)
  8091af:	e8 b8 ba ff ff       	call   804c6c <pbuf_header>
  8091b4:	84 c0                	test   %al,%al
  8091b6:	74 1c                	je     8091d4 <udp_input+0x248>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8091b8:	c7 44 24 08 9b 2d 81 	movl   $0x812d9b,0x8(%esp)
  8091bf:	00 
  8091c0:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  8091c7:	00 
  8091c8:	c7 04 24 c6 2d 81 00 	movl   $0x812dc6,(%esp)
  8091cf:	e8 ac 5c 00 00       	call   80ee80 <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  8091d4:	85 db                	test   %ebx,%ebx
  8091d6:	74 41                	je     809219 <udp_input+0x28d>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  8091d8:	8b 43 18             	mov    0x18(%ebx),%eax
  8091db:	85 c0                	test   %eax,%eax
  8091dd:	74 2a                	je     809209 <udp_input+0x27d>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  8091df:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  8091e3:	89 54 24 10          	mov    %edx,0x10(%esp)
  8091e7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8091ea:	83 c2 0c             	add    $0xc,%edx
  8091ed:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8091f1:	8b 55 08             	mov    0x8(%ebp),%edx
  8091f4:	89 54 24 08          	mov    %edx,0x8(%esp)
  8091f8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8091fc:	8b 53 1c             	mov    0x1c(%ebx),%edx
  8091ff:	89 14 24             	mov    %edx,(%esp)
  809202:	ff d0                	call   *%eax
  809204:	e9 ed 00 00 00       	jmp    8092f6 <udp_input+0x36a>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  809209:	8b 45 08             	mov    0x8(%ebp),%eax
  80920c:	89 04 24             	mov    %eax,(%esp)
  80920f:	e8 3d bb ff ff       	call   804d51 <pbuf_free>
        goto end;
  809214:	e9 dd 00 00 00       	jmp    8092f6 <udp_input+0x36a>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  809219:	8b 55 0c             	mov    0xc(%ebp),%edx
  80921c:	89 54 24 04          	mov    %edx,0x4(%esp)
  809220:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809223:	83 c0 10             	add    $0x10,%eax
  809226:	89 04 24             	mov    %eax,(%esp)
  809229:	e8 6e d7 ff ff       	call   80699c <ip_addr_isbroadcast>
  80922e:	84 c0                	test   %al,%al
  809230:	0f 85 88 00 00 00    	jne    8092be <udp_input+0x332>
          !ip_addr_ismulticast(&iphdr->dest)) {
  809236:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809239:	8b 58 10             	mov    0x10(%eax),%ebx
  80923c:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809243:	e8 87 ec ff ff       	call   807ecf <ntohl>
  809248:	21 c3                	and    %eax,%ebx
  80924a:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809251:	e8 79 ec ff ff       	call   807ecf <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  809256:	39 c3                	cmp    %eax,%ebx
  809258:	74 64                	je     8092be <udp_input+0x332>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  80925a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80925d:	0f b7 02             	movzwl (%edx),%eax
  809260:	89 04 24             	mov    %eax,(%esp)
  809263:	e8 fd e9 ff ff       	call   807c65 <ntohs>
  809268:	0f b6 c4             	movzbl %ah,%eax
  80926b:	83 e0 0f             	and    $0xf,%eax
  80926e:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  809275:	89 44 24 04          	mov    %eax,0x4(%esp)
  809279:	8b 45 08             	mov    0x8(%ebp),%eax
  80927c:	89 04 24             	mov    %eax,(%esp)
  80927f:	e8 e8 b9 ff ff       	call   804c6c <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  809284:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809287:	8b 55 08             	mov    0x8(%ebp),%edx
  80928a:	39 42 04             	cmp    %eax,0x4(%edx)
  80928d:	74 1c                	je     8092ab <udp_input+0x31f>
  80928f:	c7 44 24 08 da 2d 81 	movl   $0x812dda,0x8(%esp)
  809296:	00 
  809297:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80929e:	00 
  80929f:	c7 04 24 c6 2d 81 00 	movl   $0x812dc6,(%esp)
  8092a6:	e8 d5 5b 00 00       	call   80ee80 <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  8092ab:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  8092b2:	00 
  8092b3:	8b 55 08             	mov    0x8(%ebp),%edx
  8092b6:	89 14 24             	mov    %edx,(%esp)
  8092b9:	e8 2d 59 00 00       	call   80ebeb <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  8092be:	8b 45 08             	mov    0x8(%ebp),%eax
  8092c1:	89 04 24             	mov    %eax,(%esp)
  8092c4:	e8 88 ba ff ff       	call   804d51 <pbuf_free>
  8092c9:	eb 2b                	jmp    8092f6 <udp_input+0x36a>
    }
  } else {
    pbuf_free(p);
  8092cb:	8b 55 08             	mov    0x8(%ebp),%edx
  8092ce:	89 14 24             	mov    %edx,(%esp)
  8092d1:	e8 7b ba ff ff       	call   804d51 <pbuf_free>
  8092d6:	eb 1e                	jmp    8092f6 <udp_input+0x36a>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  8092d8:	89 5d e0             	mov    %ebx,-0x20(%ebp)
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  8092db:	66 8b 45 de          	mov    -0x22(%ebp),%ax
  8092df:	66 39 43 14          	cmp    %ax,0x14(%ebx)
  8092e3:	0f 85 2f fe ff ff    	jne    809118 <udp_input+0x18c>
  8092e9:	e9 f2 fd ff ff       	jmp    8090e0 <udp_input+0x154>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  8092ee:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  8092f1:	e9 46 fe ff ff       	jmp    80913c <udp_input+0x1b0>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  8092f6:	83 c4 4c             	add    $0x4c,%esp
  8092f9:	5b                   	pop    %ebx
  8092fa:	5e                   	pop    %esi
  8092fb:	5f                   	pop    %edi
  8092fc:	5d                   	pop    %ebp
  8092fd:	c3                   	ret    

008092fe <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8092fe:	55                   	push   %ebp
  8092ff:	89 e5                	mov    %esp,%ebp
  809301:	57                   	push   %edi
  809302:	56                   	push   %esi
  809303:	53                   	push   %ebx
  809304:	83 ec 1c             	sub    $0x1c,%esp
  809307:	8b 55 08             	mov    0x8(%ebp),%edx
  80930a:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80930d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809310:	a1 94 c2 b3 00       	mov    0xb3c294,%eax

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  809315:	be 00 00 00 00       	mov    $0x0,%esi
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80931a:	eb 2e                	jmp    80934a <udp_bind+0x4c>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  80931c:	39 c2                	cmp    %eax,%edx
  80931e:	75 27                	jne    809347 <udp_bind+0x49>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  809320:	89 f3                	mov    %esi,%ebx
  809322:	84 db                	test   %bl,%bl
  809324:	74 1c                	je     809342 <udp_bind+0x44>
  809326:	c7 44 24 08 ee 2d 81 	movl   $0x812dee,0x8(%esp)
  80932d:	00 
  80932e:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  809335:	00 
  809336:	c7 04 24 c6 2d 81 00 	movl   $0x812dc6,(%esp)
  80933d:	e8 3e 5b 00 00       	call   80ee80 <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  809342:	be 01 00 00 00       	mov    $0x1,%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809347:	8b 40 0c             	mov    0xc(%eax),%eax
  80934a:	85 c0                	test   %eax,%eax
  80934c:	75 ce                	jne    80931c <udp_bind+0x1e>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  80934e:	85 ff                	test   %edi,%edi
  809350:	74 04                	je     809356 <udp_bind+0x58>
  809352:	8b 07                	mov    (%edi),%eax
  809354:	eb 05                	jmp    80935b <udp_bind+0x5d>
  809356:	b8 00 00 00 00       	mov    $0x0,%eax
  80935b:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  80935d:	66 85 c9             	test   %cx,%cx
  809360:	75 31                	jne    809393 <udp_bind+0x95>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  809362:	8b 3d 94 c2 b3 00    	mov    0xb3c294,%edi
  809368:	89 f8                	mov    %edi,%eax
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  80936a:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80936f:	eb 13                	jmp    809384 <udp_bind+0x86>
      if (ipcb->local_port == port) {
  809371:	66 8b 58 12          	mov    0x12(%eax),%bx
  809375:	66 39 cb             	cmp    %cx,%bx
  809378:	75 07                	jne    809381 <udp_bind+0x83>
        /* port is already used by another udp_pcb */
        port++;
  80937a:	8d 4b 01             	lea    0x1(%ebx),%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  80937d:	89 f8                	mov    %edi,%eax
  80937f:	eb 03                	jmp    809384 <udp_bind+0x86>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  809381:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  809384:	85 c0                	test   %eax,%eax
  809386:	74 0b                	je     809393 <udp_bind+0x95>
  809388:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  80938d:	75 e2                	jne    809371 <udp_bind+0x73>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  80938f:	b0 f5                	mov    $0xf5,%al
  809391:	eb 1e                	jmp    8093b1 <udp_bind+0xb3>
    }
  }
  pcb->local_port = port;
  809393:	66 89 4a 12          	mov    %cx,0x12(%edx)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  809397:	89 f0                	mov    %esi,%eax
  809399:	84 c0                	test   %al,%al
  80939b:	75 12                	jne    8093af <udp_bind+0xb1>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  80939d:	a1 94 c2 b3 00       	mov    0xb3c294,%eax
  8093a2:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  8093a5:	89 15 94 c2 b3 00    	mov    %edx,0xb3c294
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  8093ab:	b0 00                	mov    $0x0,%al
  8093ad:	eb 02                	jmp    8093b1 <udp_bind+0xb3>
  8093af:	b0 00                	mov    $0x0,%al
}
  8093b1:	83 c4 1c             	add    $0x1c,%esp
  8093b4:	5b                   	pop    %ebx
  8093b5:	5e                   	pop    %esi
  8093b6:	5f                   	pop    %edi
  8093b7:	5d                   	pop    %ebp
  8093b8:	c3                   	ret    

008093b9 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  8093b9:	55                   	push   %ebp
  8093ba:	89 e5                	mov    %esp,%ebp
  8093bc:	57                   	push   %edi
  8093bd:	56                   	push   %esi
  8093be:	53                   	push   %ebx
  8093bf:	83 ec 3c             	sub    $0x3c,%esp
  8093c2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8093c5:	8b 45 14             	mov    0x14(%ebp),%eax
  8093c8:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  8093cc:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  8093d1:	75 1e                	jne    8093f1 <udp_sendto_if+0x38>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  8093d3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8093da:	00 
  8093db:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8093df:	89 1c 24             	mov    %ebx,(%esp)
  8093e2:	e8 17 ff ff ff       	call   8092fe <udp_bind>
  8093e7:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  8093e9:	84 c0                	test   %al,%al
  8093eb:	0f 85 74 01 00 00    	jne    809565 <udp_sendto_if+0x1ac>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  8093f1:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  8093f8:	00 
  8093f9:	8b 55 0c             	mov    0xc(%ebp),%edx
  8093fc:	89 14 24             	mov    %edx,(%esp)
  8093ff:	e8 68 b8 ff ff       	call   804c6c <pbuf_header>
  809404:	84 c0                	test   %al,%al
  809406:	74 37                	je     80943f <udp_sendto_if+0x86>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  809408:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80940f:	00 
  809410:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  809417:	00 
  809418:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80941f:	e8 2e bb ff ff       	call   804f52 <pbuf_alloc>
  809424:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  809426:	85 c0                	test   %eax,%eax
  809428:	0f 84 2b 01 00 00    	je     809559 <udp_sendto_if+0x1a0>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80942e:	8b 45 0c             	mov    0xc(%ebp),%eax
  809431:	89 44 24 04          	mov    %eax,0x4(%esp)
  809435:	89 34 24             	mov    %esi,(%esp)
  809438:	e8 32 be ff ff       	call   80526f <pbuf_chain>
  80943d:	eb 03                	jmp    809442 <udp_sendto_if+0x89>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  80943f:	8b 75 0c             	mov    0xc(%ebp),%esi
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  809442:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  809447:	77 1c                	ja     809465 <udp_sendto_if+0xac>
  809449:	c7 44 24 08 fc 2d 81 	movl   $0x812dfc,0x8(%esp)
  809450:	00 
  809451:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  809458:	00 
  809459:	c7 04 24 c6 2d 81 00 	movl   $0x812dc6,(%esp)
  809460:	e8 1b 5a 00 00       	call   80ee80 <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  809465:	8b 7e 04             	mov    0x4(%esi),%edi
  udphdr->src = htons(pcb->local_port);
  809468:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  80946c:	89 04 24             	mov    %eax,(%esp)
  80946f:	e8 e5 e7 ff ff       	call   807c59 <htons>
  809474:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  809477:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80947b:	89 04 24             	mov    %eax,(%esp)
  80947e:	e8 d6 e7 ff ff       	call   807c59 <htons>
  809483:	66 89 47 02          	mov    %ax,0x2(%edi)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  809487:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80948d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  809490:	85 db                	test   %ebx,%ebx
  809492:	74 06                	je     80949a <udp_sendto_if+0xe1>
  809494:	8b 03                	mov    (%ebx),%eax
  809496:	85 c0                	test   %eax,%eax
  809498:	75 0b                	jne    8094a5 <udp_sendto_if+0xec>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80949a:	8b 55 18             	mov    0x18(%ebp),%edx
  80949d:	83 c2 04             	add    $0x4,%edx
  8094a0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8094a3:	eb 23                	jmp    8094c8 <udp_sendto_if+0x10f>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8094a5:	8b 55 18             	mov    0x18(%ebp),%edx
  8094a8:	3b 42 04             	cmp    0x4(%edx),%eax
  8094ab:	74 1b                	je     8094c8 <udp_sendto_if+0x10f>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  8094ad:	3b 75 0c             	cmp    0xc(%ebp),%esi
  8094b0:	0f 84 aa 00 00 00    	je     809560 <udp_sendto_if+0x1a7>
        /* free the header pbuf */
        pbuf_free(q);
  8094b6:	89 34 24             	mov    %esi,(%esp)
  8094b9:	e8 93 b8 ff ff       	call   804d51 <pbuf_free>
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  8094be:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
  8094c3:	e9 9d 00 00 00       	jmp    809565 <udp_sendto_if+0x1ac>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  8094c8:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8094cc:	89 04 24             	mov    %eax,(%esp)
  8094cf:	e8 85 e7 ff ff       	call   807c59 <htons>
  8094d4:	66 89 47 04          	mov    %ax,0x4(%edi)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  8094d8:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  8094dc:	75 35                	jne    809513 <udp_sendto_if+0x15a>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  8094de:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8094e2:	89 44 24 10          	mov    %eax,0x10(%esp)
  8094e6:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  8094ed:	00 
  8094ee:	8b 45 10             	mov    0x10(%ebp),%eax
  8094f1:	89 44 24 08          	mov    %eax,0x8(%esp)
  8094f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8094f8:	89 54 24 04          	mov    %edx,0x4(%esp)
  8094fc:	89 34 24             	mov    %esi,(%esp)
  8094ff:	e8 10 e4 ff ff       	call   807914 <inet_chksum_pseudo>
  809504:	66 89 47 06          	mov    %ax,0x6(%edi)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  809508:	66 85 c0             	test   %ax,%ax
  80950b:	75 06                	jne    809513 <udp_sendto_if+0x15a>
  80950d:	66 c7 47 06 ff ff    	movw   $0xffff,0x6(%edi)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  809513:	8b 45 18             	mov    0x18(%ebp),%eax
  809516:	89 44 24 18          	mov    %eax,0x18(%esp)
  80951a:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  809521:	00 
  809522:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  809526:	89 44 24 10          	mov    %eax,0x10(%esp)
  80952a:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80952e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809532:	8b 55 10             	mov    0x10(%ebp),%edx
  809535:	89 54 24 08          	mov    %edx,0x8(%esp)
  809539:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80953c:	89 44 24 04          	mov    %eax,0x4(%esp)
  809540:	89 34 24             	mov    %esi,(%esp)
  809543:	e8 98 d7 ff ff       	call   806ce0 <ip_output_if>
  809548:	89 c7                	mov    %eax,%edi
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80954a:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80954d:	74 16                	je     809565 <udp_sendto_if+0x1ac>
    /* free the header pbuf */
    pbuf_free(q);
  80954f:	89 34 24             	mov    %esi,(%esp)
  809552:	e8 fa b7 ff ff       	call   804d51 <pbuf_free>
  809557:	eb 0c                	jmp    809565 <udp_sendto_if+0x1ac>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  809559:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80955e:	eb 05                	jmp    809565 <udp_sendto_if+0x1ac>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  809560:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  809565:	89 f8                	mov    %edi,%eax
  809567:	83 c4 3c             	add    $0x3c,%esp
  80956a:	5b                   	pop    %ebx
  80956b:	5e                   	pop    %esi
  80956c:	5f                   	pop    %edi
  80956d:	5d                   	pop    %ebp
  80956e:	c3                   	ret    

0080956f <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  80956f:	55                   	push   %ebp
  809570:	89 e5                	mov    %esp,%ebp
  809572:	56                   	push   %esi
  809573:	53                   	push   %ebx
  809574:	83 ec 20             	sub    $0x20,%esp
  809577:	8b 75 10             	mov    0x10(%ebp),%esi
  80957a:	8b 5d 14             	mov    0x14(%ebp),%ebx

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  80957d:	89 34 24             	mov    %esi,(%esp)
  809580:	e8 5b d4 ff ff       	call   8069e0 <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  809585:	85 c0                	test   %eax,%eax
  809587:	74 23                	je     8095ac <udp_sendto+0x3d>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  809589:	89 44 24 10          	mov    %eax,0x10(%esp)
  80958d:	0f b7 db             	movzwl %bx,%ebx
  809590:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  809594:	89 74 24 08          	mov    %esi,0x8(%esp)
  809598:	8b 45 0c             	mov    0xc(%ebp),%eax
  80959b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80959f:	8b 45 08             	mov    0x8(%ebp),%eax
  8095a2:	89 04 24             	mov    %eax,(%esp)
  8095a5:	e8 0f fe ff ff       	call   8093b9 <udp_sendto_if>
  8095aa:	eb 02                	jmp    8095ae <udp_sendto+0x3f>

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  8095ac:	b0 fc                	mov    $0xfc,%al
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
}
  8095ae:	83 c4 20             	add    $0x20,%esp
  8095b1:	5b                   	pop    %ebx
  8095b2:	5e                   	pop    %esi
  8095b3:	5d                   	pop    %ebp
  8095b4:	c3                   	ret    

008095b5 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  8095b5:	55                   	push   %ebp
  8095b6:	89 e5                	mov    %esp,%ebp
  8095b8:	83 ec 18             	sub    $0x18,%esp
  8095bb:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  8095be:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  8095c2:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8095c6:	8d 50 04             	lea    0x4(%eax),%edx
  8095c9:	89 54 24 08          	mov    %edx,0x8(%esp)
  8095cd:	8b 55 0c             	mov    0xc(%ebp),%edx
  8095d0:	89 54 24 04          	mov    %edx,0x4(%esp)
  8095d4:	89 04 24             	mov    %eax,(%esp)
  8095d7:	e8 93 ff ff ff       	call   80956f <udp_sendto>
}
  8095dc:	c9                   	leave  
  8095dd:	c3                   	ret    

008095de <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8095de:	55                   	push   %ebp
  8095df:	89 e5                	mov    %esp,%ebp
  8095e1:	57                   	push   %edi
  8095e2:	56                   	push   %esi
  8095e3:	53                   	push   %ebx
  8095e4:	83 ec 1c             	sub    $0x1c,%esp
  8095e7:	8b 75 08             	mov    0x8(%ebp),%esi
  8095ea:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8095ed:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  8095f0:	66 83 7e 12 00       	cmpw   $0x0,0x12(%esi)
  8095f5:	75 18                	jne    80960f <udp_connect+0x31>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  8095f7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8095fe:	00 
  8095ff:	89 74 24 04          	mov    %esi,0x4(%esp)
  809603:	89 34 24             	mov    %esi,(%esp)
  809606:	e8 f3 fc ff ff       	call   8092fe <udp_bind>
    if (err != ERR_OK)
  80960b:	84 c0                	test   %al,%al
  80960d:	75 3a                	jne    809649 <udp_connect+0x6b>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  80960f:	85 db                	test   %ebx,%ebx
  809611:	74 04                	je     809617 <udp_connect+0x39>
  809613:	8b 03                	mov    (%ebx),%eax
  809615:	eb 05                	jmp    80961c <udp_connect+0x3e>
  809617:	b8 00 00 00 00       	mov    $0x0,%eax
  80961c:	89 46 04             	mov    %eax,0x4(%esi)
  pcb->remote_port = port;
  80961f:	66 89 7e 14          	mov    %di,0x14(%esi)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  809623:	80 4e 10 04          	orb    $0x4,0x10(%esi)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809627:	8b 15 94 c2 b3 00    	mov    0xb3c294,%edx
  80962d:	89 d0                	mov    %edx,%eax
  80962f:	eb 07                	jmp    809638 <udp_connect+0x5a>
    if (pcb == ipcb) {
  809631:	39 c6                	cmp    %eax,%esi
  809633:	74 12                	je     809647 <udp_connect+0x69>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809635:	8b 40 0c             	mov    0xc(%eax),%eax
  809638:	85 c0                	test   %eax,%eax
  80963a:	75 f5                	jne    809631 <udp_connect+0x53>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80963c:	89 56 0c             	mov    %edx,0xc(%esi)
  udp_pcbs = pcb;
  80963f:	89 35 94 c2 b3 00    	mov    %esi,0xb3c294
  return ERR_OK;
  809645:	eb 02                	jmp    809649 <udp_connect+0x6b>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  809647:	b0 00                	mov    $0x0,%al
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  809649:	83 c4 1c             	add    $0x1c,%esp
  80964c:	5b                   	pop    %ebx
  80964d:	5e                   	pop    %esi
  80964e:	5f                   	pop    %edi
  80964f:	5d                   	pop    %ebp
  809650:	c3                   	ret    

00809651 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  809651:	55                   	push   %ebp
  809652:	89 e5                	mov    %esp,%ebp
  809654:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  809657:	8b 15 38 2a 81 00    	mov    0x812a38,%edx
  80965d:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  809660:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  809666:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80966a:	5d                   	pop    %ebp
  80966b:	c3                   	ret    

0080966c <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80966c:	55                   	push   %ebp
  80966d:	89 e5                	mov    %esp,%ebp
  80966f:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  809672:	8b 55 0c             	mov    0xc(%ebp),%edx
  809675:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  809678:	8b 55 10             	mov    0x10(%ebp),%edx
  80967b:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80967e:	5d                   	pop    %ebp
  80967f:	c3                   	ret    

00809680 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  809680:	55                   	push   %ebp
  809681:	89 e5                	mov    %esp,%ebp
  809683:	83 ec 18             	sub    $0x18,%esp
  809686:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  809689:	a1 94 c2 b3 00       	mov    0xb3c294,%eax
  80968e:	39 c8                	cmp    %ecx,%eax
  809690:	75 1e                	jne    8096b0 <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  809692:	8b 40 0c             	mov    0xc(%eax),%eax
  809695:	a3 94 c2 b3 00       	mov    %eax,0xb3c294
  80969a:	eb 18                	jmp    8096b4 <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80969c:	8b 50 0c             	mov    0xc(%eax),%edx
  80969f:	85 d2                	test   %edx,%edx
  8096a1:	74 0a                	je     8096ad <udp_remove+0x2d>
  8096a3:	39 d1                	cmp    %edx,%ecx
  8096a5:	75 06                	jne    8096ad <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  8096a7:	8b 51 0c             	mov    0xc(%ecx),%edx
  8096aa:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8096ad:	8b 40 0c             	mov    0xc(%eax),%eax
  8096b0:	85 c0                	test   %eax,%eax
  8096b2:	75 e8                	jne    80969c <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  8096b4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8096b8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8096bf:	e8 02 b3 ff ff       	call   8049c6 <memp_free>
}
  8096c4:	c9                   	leave  
  8096c5:	c3                   	ret    

008096c6 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  8096c6:	55                   	push   %ebp
  8096c7:	89 e5                	mov    %esp,%ebp
  8096c9:	53                   	push   %ebx
  8096ca:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  8096cd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8096d4:	e8 8d b2 ff ff       	call   804966 <memp_malloc>
  8096d9:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  8096db:	85 c0                	test   %eax,%eax
  8096dd:	74 1c                	je     8096fb <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  8096df:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  8096e6:	00 
  8096e7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8096ee:	00 
  8096ef:	89 04 24             	mov    %eax,(%esp)
  8096f2:	e8 5b 5f 00 00       	call   80f652 <memset>
    pcb->ttl = UDP_TTL;
  8096f7:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  8096fb:	89 d8                	mov    %ebx,%eax
  8096fd:	83 c4 14             	add    $0x14,%esp
  809700:	5b                   	pop    %ebx
  809701:	5d                   	pop    %ebp
  809702:	c3                   	ret    
	...

00809704 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809704:	55                   	push   %ebp
  809705:	89 e5                	mov    %esp,%ebp
  809707:	57                   	push   %edi
  809708:	56                   	push   %esi
  809709:	53                   	push   %ebx
  80970a:	83 ec 2c             	sub    $0x2c,%esp
  80970d:	89 c6                	mov    %eax,%esi
  80970f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  809712:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  809715:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809718:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80971c:	74 1c                	je     80973a <etharp_send_ip+0x36>
  80971e:	c7 44 24 08 2c 2e 81 	movl   $0x812e2c,0x8(%esp)
  809725:	00 
  809726:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  80972d:	00 
  80972e:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  809735:	e8 46 57 00 00       	call   80ee80 <_panic>
  80973a:	b2 06                	mov    $0x6,%dl
  80973c:	89 4d e0             	mov    %ecx,-0x20(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  80973f:	4a                   	dec    %edx
    ethhdr->dest.addr[k] = dst->addr[k];
  809740:	0f b6 c2             	movzbl %dl,%eax
  809743:	8a 0c 07             	mov    (%edi,%eax,1),%cl
  809746:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809749:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80974c:	8a 0c 01             	mov    (%ecx,%eax,1),%cl
  80974f:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  809753:	84 d2                	test   %dl,%dl
  809755:	75 e8                	jne    80973f <etharp_send_ip+0x3b>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809757:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80975e:	e8 f6 e4 ff ff       	call   807c59 <htons>
  809763:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809767:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80976a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80976e:	89 34 24             	mov    %esi,(%esp)
  809771:	ff 56 18             	call   *0x18(%esi)
}
  809774:	83 c4 2c             	add    $0x2c,%esp
  809777:	5b                   	pop    %ebx
  809778:	5e                   	pop    %esi
  809779:	5f                   	pop    %edi
  80977a:	5d                   	pop    %ebp
  80977b:	c3                   	ret    

0080977c <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  80977c:	55                   	push   %ebp
  80977d:	89 e5                	mov    %esp,%ebp
  80977f:	56                   	push   %esi
  809780:	53                   	push   %ebx
  809781:	83 ec 10             	sub    $0x10,%esp
  809784:	89 c3                	mov    %eax,%ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  809786:	85 c0                	test   %eax,%eax
  809788:	75 1c                	jne    8097a6 <free_etharp_q+0x2a>
  80978a:	c7 44 24 08 f6 24 81 	movl   $0x8124f6,0x8(%esp)
  809791:	00 
  809792:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  809799:	00 
  80979a:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  8097a1:	e8 da 56 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8097a6:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8097aa:	75 1e                	jne    8097ca <free_etharp_q+0x4e>
  8097ac:	c7 44 24 08 2d 2f 81 	movl   $0x812f2d,0x8(%esp)
  8097b3:	00 
  8097b4:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  8097bb:	00 
  8097bc:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  8097c3:	e8 b8 56 00 00       	call   80ee80 <_panic>
  while (q) {
    r = q;
    q = q->next;
  8097c8:	89 f3                	mov    %esi,%ebx
  8097ca:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8097cc:	8b 43 04             	mov    0x4(%ebx),%eax
  8097cf:	85 c0                	test   %eax,%eax
  8097d1:	75 1c                	jne    8097ef <free_etharp_q+0x73>
  8097d3:	c7 44 24 08 3a 2f 81 	movl   $0x812f3a,0x8(%esp)
  8097da:	00 
  8097db:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  8097e2:	00 
  8097e3:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  8097ea:	e8 91 56 00 00       	call   80ee80 <_panic>
    pbuf_free(r->p);
  8097ef:	89 04 24             	mov    %eax,(%esp)
  8097f2:	e8 5a b5 ff ff       	call   804d51 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  8097f7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8097fb:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  809802:	e8 bf b1 ff ff       	call   8049c6 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  809807:	85 f6                	test   %esi,%esi
  809809:	75 bd                	jne    8097c8 <free_etharp_q+0x4c>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  80980b:	83 c4 10             	add    $0x10,%esp
  80980e:	5b                   	pop    %ebx
  80980f:	5e                   	pop    %esi
  809810:	5d                   	pop    %ebp
  809811:	c3                   	ret    

00809812 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809812:	55                   	push   %ebp
  809813:	89 e5                	mov    %esp,%ebp
  809815:	57                   	push   %edi
  809816:	56                   	push   %esi
  809817:	53                   	push   %ebx
  809818:	83 ec 2c             	sub    $0x2c,%esp
  80981b:	89 c6                	mov    %eax,%esi
  80981d:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809820:	85 c0                	test   %eax,%eax
  809822:	74 2f                	je     809853 <find_entry+0x41>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809824:	a0 78 5b b3 00       	mov    0xb35b78,%al
  809829:	0f b6 c8             	movzbl %al,%ecx
  80982c:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
  809833:	8d 1c d5 00 00 00 00 	lea    0x0(,%edx,8),%ebx
  80983a:	29 d3                	sub    %edx,%ebx
  80983c:	83 bb 70 5a b3 00 02 	cmpl   $0x2,0xb35a70(%ebx)
  809843:	75 0e                	jne    809853 <find_entry+0x41>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  809845:	8b 8b 64 5a b3 00    	mov    0xb35a64(%ebx),%ecx
  80984b:	39 0e                	cmp    %ecx,(%esi)
  80984d:	0f 84 d4 01 00 00    	je     809a27 <find_entry+0x215>
  809853:	ba 74 5a b3 00       	mov    $0xb35a74,%edx
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809858:	bf 00 00 00 00       	mov    $0x0,%edi
  80985d:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  809861:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809865:	c6 45 e2 00          	movb   $0x0,-0x1e(%ebp)
  809869:	b0 00                	mov    $0x0,%al
  80986b:	c6 45 e7 0a          	movb   $0xa,-0x19(%ebp)
  80986f:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809873:	c6 45 e1 0a          	movb   $0xa,-0x1f(%ebp)
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  809877:	80 7d e7 0a          	cmpb   $0xa,-0x19(%ebp)
  80987b:	75 0b                	jne    809888 <find_entry+0x76>
  80987d:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  809881:	75 05                	jne    809888 <find_entry+0x76>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  809883:	88 45 e7             	mov    %al,-0x19(%ebp)
  809886:	eb 6a                	jmp    8098f2 <find_entry+0xe0>
 */
static s8_t
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
  809888:	89 d3                	mov    %edx,%ebx
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80988a:	8b 4a fc             	mov    -0x4(%edx),%ecx
  80988d:	83 f9 01             	cmp    $0x1,%ecx
  809890:	75 39                	jne    8098cb <find_entry+0xb9>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809892:	85 f6                	test   %esi,%esi
  809894:	74 11                	je     8098a7 <find_entry+0x95>
  809896:	8b 4a f0             	mov    -0x10(%edx),%ecx
  809899:	39 0e                	cmp    %ecx,(%esi)
  80989b:	75 0a                	jne    8098a7 <find_entry+0x95>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80989d:	a2 78 5b b3 00       	mov    %al,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  8098a2:	e9 80 01 00 00       	jmp    809a27 <find_entry+0x215>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  8098a7:	83 7b ec 00          	cmpl   $0x0,-0x14(%ebx)
  8098ab:	74 0f                	je     8098bc <find_entry+0xaa>
        if (arp_table[i].ctime >= age_queue) {
  8098ad:	8a 0b                	mov    (%ebx),%cl
  8098af:	89 fb                	mov    %edi,%ebx
  8098b1:	38 cb                	cmp    %cl,%bl
  8098b3:	77 3d                	ja     8098f2 <find_entry+0xe0>
          old_queue = i;
  8098b5:	88 45 e3             	mov    %al,-0x1d(%ebp)
          age_queue = arp_table[i].ctime;
  8098b8:	89 cf                	mov    %ecx,%edi
  8098ba:	eb 36                	jmp    8098f2 <find_entry+0xe0>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  8098bc:	8a 0b                	mov    (%ebx),%cl
  8098be:	38 4d e2             	cmp    %cl,-0x1e(%ebp)
  8098c1:	77 2f                	ja     8098f2 <find_entry+0xe0>
          old_pending = i;
  8098c3:	88 45 e1             	mov    %al,-0x1f(%ebp)
          age_pending = arp_table[i].ctime;
  8098c6:	88 4d e2             	mov    %cl,-0x1e(%ebp)
  8098c9:	eb 27                	jmp    8098f2 <find_entry+0xe0>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8098cb:	83 f9 02             	cmp    $0x2,%ecx
  8098ce:	75 22                	jne    8098f2 <find_entry+0xe0>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8098d0:	85 f6                	test   %esi,%esi
  8098d2:	74 11                	je     8098e5 <find_entry+0xd3>
  8098d4:	8b 4a f0             	mov    -0x10(%edx),%ecx
  8098d7:	39 0e                	cmp    %ecx,(%esi)
  8098d9:	75 0a                	jne    8098e5 <find_entry+0xd3>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  8098db:	a2 78 5b b3 00       	mov    %al,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  8098e0:	e9 42 01 00 00       	jmp    809a27 <find_entry+0x215>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  8098e5:	8a 0b                	mov    (%ebx),%cl
  8098e7:	38 4d e6             	cmp    %cl,-0x1a(%ebp)
  8098ea:	77 06                	ja     8098f2 <find_entry+0xe0>
        old_stable = i;
  8098ec:	88 45 e5             	mov    %al,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  8098ef:	88 4d e6             	mov    %cl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8098f2:	40                   	inc    %eax
  8098f3:	83 c2 1c             	add    $0x1c,%edx
  8098f6:	3c 0a                	cmp    $0xa,%al
  8098f8:	0f 85 79 ff ff ff    	jne    809877 <find_entry+0x65>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8098fe:	80 7d e7 0a          	cmpb   $0xa,-0x19(%ebp)
  809902:	75 0a                	jne    80990e <find_entry+0xfc>
  809904:	f6 45 e4 01          	testb  $0x1,-0x1c(%ebp)
  809908:	0f 84 0f 01 00 00    	je     809a1d <find_entry+0x20b>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  80990e:	f6 45 e4 02          	testb  $0x2,-0x1c(%ebp)
  809912:	0f 85 09 01 00 00    	jne    809a21 <find_entry+0x20f>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  809918:	80 7d e7 09          	cmpb   $0x9,-0x19(%ebp)
  80991c:	7f 06                	jg     809924 <find_entry+0x112>
    i = empty;
  80991e:	0f b6 7d e7          	movzbl -0x19(%ebp),%edi
  809922:	eb 7e                	jmp    8099a2 <find_entry+0x190>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  809924:	80 7d e5 09          	cmpb   $0x9,-0x1b(%ebp)
  809928:	7f 39                	jg     809963 <find_entry+0x151>
    /* recycle oldest stable*/
    i = old_stable;
  80992a:	0f b6 7d e5          	movzbl -0x1b(%ebp),%edi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80992e:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  809932:	c1 e0 02             	shl    $0x2,%eax
  809935:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  80993c:	29 c2                	sub    %eax,%edx
  80993e:	83 ba 60 5a b3 00 00 	cmpl   $0x0,0xb35a60(%edx)
  809945:	74 5b                	je     8099a2 <find_entry+0x190>
  809947:	c7 44 24 08 47 2f 81 	movl   $0x812f47,0x8(%esp)
  80994e:	00 
  80994f:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  809956:	00 
  809957:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  80995e:	e8 1d 55 00 00       	call   80ee80 <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  809963:	80 7d e1 09          	cmpb   $0x9,-0x1f(%ebp)
  809967:	7f 06                	jg     80996f <find_entry+0x15d>
    /* recycle oldest pending */
    i = old_pending;
  809969:	0f b6 7d e1          	movzbl -0x1f(%ebp),%edi
  80996d:	eb 33                	jmp    8099a2 <find_entry+0x190>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  80996f:	80 7d e3 09          	cmpb   $0x9,-0x1d(%ebp)
  809973:	0f 8f ac 00 00 00    	jg     809a25 <find_entry+0x213>
    /* recycle oldest pending */
    i = old_queue;
  809979:	0f b6 7d e3          	movzbl -0x1d(%ebp),%edi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  80997d:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  809981:	c1 e0 02             	shl    $0x2,%eax
  809984:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  80998b:	29 c3                	sub    %eax,%ebx
  80998d:	8b 83 60 5a b3 00    	mov    0xb35a60(%ebx),%eax
  809993:	e8 e4 fd ff ff       	call   80977c <free_etharp_q>
    arp_table[i].q = NULL;
  809998:	c7 83 60 5a b3 00 00 	movl   $0x0,0xb35a60(%ebx)
  80999f:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8099a2:	89 fb                	mov    %edi,%ebx
  8099a4:	80 fb 09             	cmp    $0x9,%bl
  8099a7:	76 1c                	jbe    8099c5 <find_entry+0x1b3>
  8099a9:	c7 44 24 08 5e 2f 81 	movl   $0x812f5e,0x8(%esp)
  8099b0:	00 
  8099b1:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  8099b8:	00 
  8099b9:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  8099c0:	e8 bb 54 00 00       	call   80ee80 <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  8099c5:	0f b6 c3             	movzbl %bl,%eax
  8099c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  8099cf:	8d 0c d5 00 00 00 00 	lea    0x0(,%edx,8),%ecx
  8099d6:	29 d1                	sub    %edx,%ecx
  8099d8:	c7 81 70 5a b3 00 00 	movl   $0x0,0xb35a70(%ecx)
  8099df:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  8099e2:	85 f6                	test   %esi,%esi
  8099e4:	74 18                	je     8099fe <find_entry+0x1ec>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  8099e6:	8b 0e                	mov    (%esi),%ecx
  8099e8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  8099ef:	8d 1c d5 00 00 00 00 	lea    0x0(,%edx,8),%ebx
  8099f6:	29 d3                	sub    %edx,%ebx
  8099f8:	89 8b 64 5a b3 00    	mov    %ecx,0xb35a64(%ebx)
  }
  arp_table[i].ctime = 0;
  8099fe:	c1 e0 02             	shl    $0x2,%eax
  809a01:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  809a08:	29 c2                	sub    %eax,%edx
  809a0a:	c6 82 74 5a b3 00 00 	movb   $0x0,0xb35a74(%edx)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809a11:	89 f9                	mov    %edi,%ecx
  809a13:	88 0d 78 5b b3 00    	mov    %cl,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  809a19:	89 f8                	mov    %edi,%eax
  809a1b:	eb 0a                	jmp    809a27 <find_entry+0x215>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809a1d:	b0 ff                	mov    $0xff,%al
  809a1f:	eb 06                	jmp    809a27 <find_entry+0x215>
  809a21:	b0 ff                	mov    $0xff,%al
  809a23:	eb 02                	jmp    809a27 <find_entry+0x215>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  809a25:	b0 ff                	mov    $0xff,%al
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  809a27:	83 c4 2c             	add    $0x2c,%esp
  809a2a:	5b                   	pop    %ebx
  809a2b:	5e                   	pop    %esi
  809a2c:	5f                   	pop    %edi
  809a2d:	5d                   	pop    %ebp
  809a2e:	c3                   	ret    

00809a2f <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  809a2f:	55                   	push   %ebp
  809a30:	89 e5                	mov    %esp,%ebp
  809a32:	57                   	push   %edi
  809a33:	56                   	push   %esi
  809a34:	53                   	push   %ebx
  809a35:	83 ec 2c             	sub    $0x2c,%esp
  809a38:	89 45 e0             	mov    %eax,-0x20(%ebp)
  809a3b:	89 d3                	mov    %edx,%ebx
  809a3d:	89 ce                	mov    %ecx,%esi
  809a3f:	0f b6 7d 08          	movzbl 0x8(%ebp),%edi
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809a43:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809a47:	74 1c                	je     809a65 <update_arp_entry+0x36>
  809a49:	c7 44 24 08 70 2e 81 	movl   $0x812e70,0x8(%esp)
  809a50:	00 
  809a51:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  809a58:	00 
  809a59:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  809a60:	e8 1b 54 00 00       	call   80ee80 <_panic>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809a65:	85 d2                	test   %edx,%edx
  809a67:	0f 84 0e 01 00 00    	je     809b7b <update_arp_entry+0x14c>
  809a6d:	83 3a 00             	cmpl   $0x0,(%edx)
  809a70:	0f 84 09 01 00 00    	je     809b7f <update_arp_entry+0x150>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809a76:	8b 45 e0             	mov    -0x20(%ebp),%eax
  809a79:	89 44 24 04          	mov    %eax,0x4(%esp)
  809a7d:	89 14 24             	mov    %edx,(%esp)
  809a80:	e8 17 cf ff ff       	call   80699c <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809a85:	84 c0                	test   %al,%al
  809a87:	0f 85 f6 00 00 00    	jne    809b83 <update_arp_entry+0x154>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  809a8d:	8b 0b                	mov    (%ebx),%ecx
  809a8f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  809a92:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809a99:	e8 31 e4 ff ff       	call   807ecf <ntohl>
  809a9e:	23 45 e4             	and    -0x1c(%ebp),%eax
  809aa1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809aa4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809aab:	e8 1f e4 ff ff       	call   807ecf <ntohl>
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  809ab0:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  809ab3:	0f 84 ce 00 00 00    	je     809b87 <update_arp_entry+0x158>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  809ab9:	89 f8                	mov    %edi,%eax
  809abb:	0f b6 d0             	movzbl %al,%edx
  809abe:	89 d8                	mov    %ebx,%eax
  809ac0:	e8 4d fd ff ff       	call   809812 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809ac5:	84 c0                	test   %al,%al
  809ac7:	0f 88 bc 00 00 00    	js     809b89 <update_arp_entry+0x15a>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  809acd:	0f be c0             	movsbl %al,%eax
  809ad0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  809ad7:	8d 14 cd 00 00 00 00 	lea    0x0(,%ecx,8),%edx
  809ade:	29 ca                	sub    %ecx,%edx
  809ae0:	c7 82 70 5a b3 00 02 	movl   $0x2,0xb35a70(%edx)
  809ae7:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  809aea:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809aed:	89 8a 78 5a b3 00    	mov    %ecx,0xb35a78(%edx)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  809af3:	b2 06                	mov    $0x6,%dl
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809af5:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  809afc:	8d 1c cd 00 00 00 00 	lea    0x0(,%ecx,8),%ebx
  809b03:	29 cb                	sub    %ecx,%ebx
  809b05:	89 c7                	mov    %eax,%edi

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  809b07:	4a                   	dec    %edx
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809b08:	0f b6 ca             	movzbl %dl,%ecx
  809b0b:	8a 04 0e             	mov    (%esi,%ecx,1),%al
  809b0e:	88 84 19 68 5a b3 00 	mov    %al,0xb35a68(%ecx,%ebx,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  809b15:	84 d2                	test   %dl,%dl
  809b17:	75 ee                	jne    809b07 <update_arp_entry+0xd8>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809b19:	8d 14 bd 00 00 00 00 	lea    0x0(,%edi,4),%edx
  809b20:	8d 0c d5 00 00 00 00 	lea    0x0(,%edx,8),%ecx
  809b27:	29 d1                	sub    %edx,%ecx
  809b29:	c6 81 74 5a b3 00 00 	movb   $0x0,0xb35a74(%ecx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809b30:	89 cf                	mov    %ecx,%edi
  809b32:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  809b35:	8b 75 e0             	mov    -0x20(%ebp),%esi
  809b38:	eb 35                	jmp    809b6f <update_arp_entry+0x140>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  809b3a:	8b 10                	mov    (%eax),%edx
  809b3c:	89 97 60 5a b3 00    	mov    %edx,0xb35a60(%edi)
    /* get the packet pointer */
    p = q->p;
  809b42:	8b 58 04             	mov    0x4(%eax),%ebx
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  809b45:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b49:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  809b50:	e8 71 ae ff ff       	call   8049c6 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809b55:	8d 4e 25             	lea    0x25(%esi),%ecx
  809b58:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809b5b:	89 04 24             	mov    %eax,(%esp)
  809b5e:	89 da                	mov    %ebx,%edx
  809b60:	89 f0                	mov    %esi,%eax
  809b62:	e8 9d fb ff ff       	call   809704 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809b67:	89 1c 24             	mov    %ebx,(%esp)
  809b6a:	e8 e2 b1 ff ff       	call   804d51 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809b6f:	8b 87 60 5a b3 00    	mov    0xb35a60(%edi),%eax
  809b75:	85 c0                	test   %eax,%eax
  809b77:	75 c1                	jne    809b3a <update_arp_entry+0x10b>
  809b79:	eb 0e                	jmp    809b89 <update_arp_entry+0x15a>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809b7b:	b0 f6                	mov    $0xf6,%al
  809b7d:	eb 0a                	jmp    809b89 <update_arp_entry+0x15a>
  809b7f:	b0 f6                	mov    $0xf6,%al
  809b81:	eb 06                	jmp    809b89 <update_arp_entry+0x15a>
  809b83:	b0 f6                	mov    $0xf6,%al
  809b85:	eb 02                	jmp    809b89 <update_arp_entry+0x15a>
  809b87:	b0 f6                	mov    $0xf6,%al
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  809b89:	83 c4 2c             	add    $0x2c,%esp
  809b8c:	5b                   	pop    %ebx
  809b8d:	5e                   	pop    %esi
  809b8e:	5f                   	pop    %edi
  809b8f:	5d                   	pop    %ebp
  809b90:	c3                   	ret    

00809b91 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  809b91:	55                   	push   %ebp
  809b92:	89 e5                	mov    %esp,%ebp
  809b94:	57                   	push   %edi
  809b95:	56                   	push   %esi
  809b96:	53                   	push   %ebx
  809b97:	83 ec 0c             	sub    $0xc,%esp
  809b9a:	bb 74 5a b3 00       	mov    $0xb35a74,%ebx
 *
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
  809b9f:	bf 8c 5b b3 00       	mov    $0xb35b8c,%edi
  809ba4:	89 de                	mov    %ebx,%esi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  809ba6:	8a 13                	mov    (%ebx),%dl
  809ba8:	42                   	inc    %edx
  809ba9:	88 13                	mov    %dl,(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  809bab:	8b 43 fc             	mov    -0x4(%ebx),%eax
  809bae:	83 f8 02             	cmp    $0x2,%eax
  809bb1:	75 07                	jne    809bba <etharp_tmr+0x29>
  809bb3:	80 fa ef             	cmp    $0xef,%dl
  809bb6:	77 0c                	ja     809bc4 <etharp_tmr+0x33>
  809bb8:	eb 24                	jmp    809bde <etharp_tmr+0x4d>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  809bba:	83 f8 01             	cmp    $0x1,%eax
  809bbd:	75 1f                	jne    809bde <etharp_tmr+0x4d>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809bbf:	80 fa 01             	cmp    $0x1,%dl
  809bc2:	76 1a                	jbe    809bde <etharp_tmr+0x4d>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  809bc4:	8b 46 ec             	mov    -0x14(%esi),%eax
  809bc7:	85 c0                	test   %eax,%eax
  809bc9:	74 0c                	je     809bd7 <etharp_tmr+0x46>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  809bcb:	e8 ac fb ff ff       	call   80977c <free_etharp_q>
        arp_table[i].q = NULL;
  809bd0:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  809bd7:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  809bde:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809be1:	39 fb                	cmp    %edi,%ebx
  809be3:	75 bf                	jne    809ba4 <etharp_tmr+0x13>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  809be5:	83 c4 0c             	add    $0xc,%esp
  809be8:	5b                   	pop    %ebx
  809be9:	5e                   	pop    %esi
  809bea:	5f                   	pop    %edi
  809beb:	5d                   	pop    %ebp
  809bec:	c3                   	ret    

00809bed <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  809bed:	55                   	push   %ebp
  809bee:	89 e5                	mov    %esp,%ebp
  809bf0:	53                   	push   %ebx
  809bf1:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809bf4:	ba 02 00 00 00       	mov    $0x2,%edx
  809bf9:	8b 45 0c             	mov    0xc(%ebp),%eax
  809bfc:	e8 11 fc ff ff       	call   809812 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  809c01:	84 c0                	test   %al,%al
  809c03:	78 36                	js     809c3b <etharp_find_addr+0x4e>
  809c05:	0f be c8             	movsbl %al,%ecx
  809c08:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
  809c0f:	8d 1c d5 00 00 00 00 	lea    0x0(,%edx,8),%ebx
  809c16:	29 d3                	sub    %edx,%ebx
  809c18:	83 bb 70 5a b3 00 02 	cmpl   $0x2,0xb35a70(%ebx)
  809c1f:	75 1e                	jne    809c3f <etharp_find_addr+0x52>
      *eth_ret = &arp_table[i].ethaddr;
  809c21:	89 da                	mov    %ebx,%edx
  809c23:	8d 9b 68 5a b3 00    	lea    0xb35a68(%ebx),%ebx
  809c29:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809c2c:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809c2e:	81 c2 64 5a b3 00    	add    $0xb35a64,%edx
  809c34:	8b 4d 14             	mov    0x14(%ebp),%ecx
  809c37:	89 11                	mov    %edx,(%ecx)
      return i;
  809c39:	eb 06                	jmp    809c41 <etharp_find_addr+0x54>
  }
  return -1;
  809c3b:	b0 ff                	mov    $0xff,%al
  809c3d:	eb 02                	jmp    809c41 <etharp_find_addr+0x54>
  809c3f:	b0 ff                	mov    $0xff,%al
}
  809c41:	83 c4 04             	add    $0x4,%esp
  809c44:	5b                   	pop    %ebx
  809c45:	5d                   	pop    %ebp
  809c46:	c3                   	ret    

00809c47 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809c47:	55                   	push   %ebp
  809c48:	89 e5                	mov    %esp,%ebp
  809c4a:	83 ec 18             	sub    $0x18,%esp
  809c4d:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809c50:	85 c0                	test   %eax,%eax
  809c52:	75 1c                	jne    809c70 <etharp_ip_input+0x29>
  809c54:	c7 44 24 08 82 21 81 	movl   $0x812182,0x8(%esp)
  809c5b:	00 
  809c5c:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  809c63:	00 
  809c64:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  809c6b:	e8 10 52 00 00       	call   80ee80 <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809c70:	8b 55 0c             	mov    0xc(%ebp),%edx
  809c73:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809c76:	8b 48 04             	mov    0x4(%eax),%ecx
  809c79:	33 4a 1c             	xor    0x1c(%edx),%ecx
  809c7c:	85 48 08             	test   %ecx,0x8(%eax)
  809c7f:	75 12                	jne    809c93 <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  809c81:	8d 4a 06             	lea    0x6(%edx),%ecx
  809c84:	83 c2 1c             	add    $0x1c,%edx
  809c87:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809c8e:	e8 9c fd ff ff       	call   809a2f <update_arp_entry>
}
  809c93:	c9                   	leave  
  809c94:	c3                   	ret    

00809c95 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  809c95:	55                   	push   %ebp
  809c96:	89 e5                	mov    %esp,%ebp
  809c98:	57                   	push   %edi
  809c99:	56                   	push   %esi
  809c9a:	53                   	push   %ebx
  809c9b:	83 ec 2c             	sub    $0x2c,%esp
  809c9e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809ca1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  809ca5:	75 1c                	jne    809cc3 <etharp_arp_input+0x2e>
  809ca7:	c7 44 24 08 82 21 81 	movl   $0x812182,0x8(%esp)
  809cae:	00 
  809caf:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  809cb6:	00 
  809cb7:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  809cbe:	e8 bd 51 00 00       	call   80ee80 <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  809cc3:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  809cc8:	77 0d                	ja     809cd7 <etharp_arp_input+0x42>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809cca:	89 1c 24             	mov    %ebx,(%esp)
  809ccd:	e8 7f b0 ff ff       	call   804d51 <pbuf_free>
    return;
  809cd2:	e9 9b 01 00 00       	jmp    809e72 <etharp_arp_input+0x1dd>
  }

  hdr = p->payload;
  809cd7:	8b 7b 04             	mov    0x4(%ebx),%edi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809cda:	66 8b 77 0e          	mov    0xe(%edi),%si
  809cde:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809ce5:	e8 6f df ff ff       	call   807c59 <htons>
  809cea:	66 39 c6             	cmp    %ax,%si
  809ced:	75 3f                	jne    809d2e <etharp_arp_input+0x99>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809cef:	66 8b 77 12          	mov    0x12(%edi),%si
  809cf3:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809cfa:	e8 5a df ff ff       	call   807c59 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809cff:	66 39 c6             	cmp    %ax,%si
  809d02:	75 2a                	jne    809d2e <etharp_arp_input+0x99>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809d04:	66 8b 77 10          	mov    0x10(%edi),%si
  809d08:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809d0f:	e8 45 df ff ff       	call   807c59 <htons>

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809d14:	66 39 c6             	cmp    %ax,%si
  809d17:	75 15                	jne    809d2e <etharp_arp_input+0x99>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809d19:	66 8b 77 0c          	mov    0xc(%edi),%si
  809d1d:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809d24:	e8 30 df ff ff       	call   807c59 <htons>
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809d29:	66 39 c6             	cmp    %ax,%si
  809d2c:	74 0d                	je     809d3b <etharp_arp_input+0xa6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809d2e:	89 1c 24             	mov    %ebx,(%esp)
  809d31:	e8 1b b0 ff ff       	call   804d51 <pbuf_free>
    return;
  809d36:	e9 37 01 00 00       	jmp    809e72 <etharp_arp_input+0x1dd>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809d3b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  809d42:	00 
  809d43:	8d 47 1c             	lea    0x1c(%edi),%eax
  809d46:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d4a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809d4d:	89 04 24             	mov    %eax,(%esp)
  809d50:	e8 b1 59 00 00       	call   80f706 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809d55:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  809d5c:	00 
  809d5d:	8d 47 26             	lea    0x26(%edi),%eax
  809d60:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d64:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809d67:	89 04 24             	mov    %eax,(%esp)
  809d6a:	e8 97 59 00 00       	call   80f706 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  809d6f:	8b 55 08             	mov    0x8(%ebp),%edx
  809d72:	8b 42 04             	mov    0x4(%edx),%eax
  809d75:	85 c0                	test   %eax,%eax
  809d77:	74 21                	je     809d9a <etharp_arp_input+0x105>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  809d79:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  809d7c:	0f 94 c0             	sete   %al
  809d7f:	89 c6                	mov    %eax,%esi
  809d81:	75 1c                	jne    809d9f <etharp_arp_input+0x10a>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  809d83:	8d 4f 16             	lea    0x16(%edi),%ecx
  809d86:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809d8d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809d90:	8b 45 08             	mov    0x8(%ebp),%eax
  809d93:	e8 97 fc ff ff       	call   809a2f <update_arp_entry>
  809d98:	eb 1a                	jmp    809db4 <etharp_arp_input+0x11f>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
    for_us = 0;
  809d9a:	be 00 00 00 00       	mov    $0x0,%esi
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809d9f:	8d 4f 16             	lea    0x16(%edi),%ecx
  809da2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809da9:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809dac:	8b 45 08             	mov    0x8(%ebp),%eax
  809daf:	e8 7b fc ff ff       	call   809a2f <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  809db4:	0f b7 47 14          	movzwl 0x14(%edi),%eax
  809db8:	89 04 24             	mov    %eax,(%esp)
  809dbb:	e8 99 de ff ff       	call   807c59 <htons>
  809dc0:	66 83 f8 01          	cmp    $0x1,%ax
  809dc4:	74 0f                	je     809dd5 <etharp_arp_input+0x140>
  809dc6:	66 83 f8 02          	cmp    $0x2,%ax
  809dca:	0f 85 9a 00 00 00    	jne    809e6a <etharp_arp_input+0x1d5>
  809dd0:	e9 83 00 00 00       	jmp    809e58 <etharp_arp_input+0x1c3>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  809dd5:	89 f2                	mov    %esi,%edx
  809dd7:	84 d2                	test   %dl,%dl
  809dd9:	0f 84 8b 00 00 00    	je     809e6a <etharp_arp_input+0x1d5>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  809ddf:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809de6:	e8 6e de ff ff       	call   807c59 <htons>
  809deb:	66 89 47 14          	mov    %ax,0x14(%edi)

      hdr->dipaddr = hdr->sipaddr;
  809def:	8b 47 1c             	mov    0x1c(%edi),%eax
  809df2:	89 47 26             	mov    %eax,0x26(%edi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  809df5:	8b 55 08             	mov    0x8(%ebp),%edx
  809df8:	8b 42 04             	mov    0x4(%edx),%eax
  809dfb:	89 47 1c             	mov    %eax,0x1c(%edi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809dfe:	b2 06                	mov    $0x6,%dl
  809e00:	8b 45 08             	mov    0x8(%ebp),%eax
  809e03:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809e07:	74 1c                	je     809e25 <etharp_arp_input+0x190>
  809e09:	c7 44 24 08 2c 2e 81 	movl   $0x812e2c,0x8(%esp)
  809e10:	00 
  809e11:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  809e18:	00 
  809e19:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  809e20:	e8 5b 50 00 00       	call   80ee80 <_panic>
  809e25:	8b 75 0c             	mov    0xc(%ebp),%esi
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  809e28:	4a                   	dec    %edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809e29:	0f b6 c2             	movzbl %dl,%eax
  809e2c:	8a 4c 07 16          	mov    0x16(%edi,%eax,1),%cl
  809e30:	88 4c 07 20          	mov    %cl,0x20(%edi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809e34:	88 0c 07             	mov    %cl,(%edi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809e37:	8a 0c 06             	mov    (%esi,%eax,1),%cl
  809e3a:	88 4c 07 16          	mov    %cl,0x16(%edi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809e3e:	8a 0c 06             	mov    (%esi,%eax,1),%cl
  809e41:	88 4c 07 06          	mov    %cl,0x6(%edi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  809e45:	84 d2                	test   %dl,%dl
  809e47:	75 df                	jne    809e28 <etharp_arp_input+0x193>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  809e49:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809e4d:	8b 55 08             	mov    0x8(%ebp),%edx
  809e50:	89 14 24             	mov    %edx,(%esp)
  809e53:	ff 52 18             	call   *0x18(%edx)
  809e56:	eb 12                	jmp    809e6a <etharp_arp_input+0x1d5>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  809e58:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809e5b:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e5f:	8b 45 08             	mov    0x8(%ebp),%eax
  809e62:	89 04 24             	mov    %eax,(%esp)
  809e65:	e8 ea 9e ff ff       	call   803d54 <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  809e6a:	89 1c 24             	mov    %ebx,(%esp)
  809e6d:	e8 df ae ff ff       	call   804d51 <pbuf_free>
}
  809e72:	83 c4 2c             	add    $0x2c,%esp
  809e75:	5b                   	pop    %ebx
  809e76:	5e                   	pop    %esi
  809e77:	5f                   	pop    %edi
  809e78:	5d                   	pop    %ebp
  809e79:	c3                   	ret    

00809e7a <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  809e7a:	55                   	push   %ebp
  809e7b:	89 e5                	mov    %esp,%ebp
  809e7d:	57                   	push   %edi
  809e7e:	56                   	push   %esi
  809e7f:	53                   	push   %ebx
  809e80:	83 ec 1c             	sub    $0x1c,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  809e83:	8b 75 08             	mov    0x8(%ebp),%esi
  809e86:	83 c6 25             	add    $0x25,%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809e89:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809e90:	00 
  809e91:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  809e98:	00 
  809e99:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809ea0:	e8 ad b0 ff ff       	call   804f52 <pbuf_alloc>
  809ea5:	89 c7                	mov    %eax,%edi
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  809ea7:	85 c0                	test   %eax,%eax
  809ea9:	0f 84 f0 00 00 00    	je     809f9f <etharp_request+0x125>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809eaf:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  809eb4:	77 1c                	ja     809ed2 <etharp_request+0x58>
  809eb6:	c7 44 24 08 98 2e 81 	movl   $0x812e98,0x8(%esp)
  809ebd:	00 
  809ebe:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  809ec5:	00 
  809ec6:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  809ecd:	e8 ae 4f 00 00       	call   80ee80 <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  809ed2:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  809ed5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809edc:	e8 78 dd ff ff       	call   807c59 <htons>
  809ee1:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809ee5:	8b 45 08             	mov    0x8(%ebp),%eax
  809ee8:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809eec:	74 1c                	je     809f0a <etharp_request+0x90>
  809eee:	c7 44 24 08 2c 2e 81 	movl   $0x812e2c,0x8(%esp)
  809ef5:	00 
  809ef6:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  809efd:	00 
  809efe:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  809f05:	e8 76 4f 00 00       	call   80ee80 <_panic>
  809f0a:	b2 06                	mov    $0x6,%dl
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  809f0c:	4a                   	dec    %edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  809f0d:	0f b6 c2             	movzbl %dl,%eax
  809f10:	8a 0c 06             	mov    (%esi,%eax,1),%cl
  809f13:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  809f17:	8a 88 8b 2f 81 00    	mov    0x812f8b(%eax),%cl
  809f1d:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  809f21:	8a 88 91 2f 81 00    	mov    0x812f91(%eax),%cl
  809f27:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  809f2a:	8a 0c 06             	mov    (%esi,%eax,1),%cl
  809f2d:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  809f31:	84 d2                	test   %dl,%dl
  809f33:	75 d7                	jne    809f0c <etharp_request+0x92>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  809f35:	8b 55 08             	mov    0x8(%ebp),%edx
  809f38:	8b 42 04             	mov    0x4(%edx),%eax
  809f3b:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  809f3e:	8b 45 0c             	mov    0xc(%ebp),%eax
  809f41:	8b 00                	mov    (%eax),%eax
  809f43:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809f46:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809f4d:	e8 07 dd ff ff       	call   807c59 <htons>
  809f52:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809f56:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809f5d:	e8 f7 dc ff ff       	call   807c59 <htons>
  809f62:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809f66:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809f6d:	e8 e7 dc ff ff       	call   807c59 <htons>
  809f72:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809f76:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809f7d:	e8 d7 dc ff ff       	call   807c59 <htons>
  809f82:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  809f86:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809f8a:	8b 45 08             	mov    0x8(%ebp),%eax
  809f8d:	89 04 24             	mov    %eax,(%esp)
  809f90:	ff 50 18             	call   *0x18(%eax)
  809f93:	88 c3                	mov    %al,%bl
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  809f95:	89 3c 24             	mov    %edi,(%esp)
  809f98:	e8 b4 ad ff ff       	call   804d51 <pbuf_free>
  809f9d:	eb 02                	jmp    809fa1 <etharp_request+0x127>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  809f9f:	b3 ff                	mov    $0xff,%bl
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809fa1:	88 d8                	mov    %bl,%al
  809fa3:	83 c4 1c             	add    $0x1c,%esp
  809fa6:	5b                   	pop    %ebx
  809fa7:	5e                   	pop    %esi
  809fa8:	5f                   	pop    %edi
  809fa9:	5d                   	pop    %ebp
  809faa:	c3                   	ret    

00809fab <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  809fab:	55                   	push   %ebp
  809fac:	89 e5                	mov    %esp,%ebp
  809fae:	57                   	push   %edi
  809faf:	56                   	push   %esi
  809fb0:	53                   	push   %ebx
  809fb1:	83 ec 1c             	sub    $0x1c,%esp
  809fb4:	8b 7d 08             	mov    0x8(%ebp),%edi
  809fb7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809fba:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809fbe:	89 1c 24             	mov    %ebx,(%esp)
  809fc1:	e8 d6 c9 ff ff       	call   80699c <ip_addr_isbroadcast>
  809fc6:	84 c0                	test   %al,%al
  809fc8:	0f 85 f9 01 00 00    	jne    80a1c7 <etharp_query+0x21c>
      ip_addr_ismulticast(ipaddr) ||
  809fce:	8b 33                	mov    (%ebx),%esi
  809fd0:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809fd7:	e8 f3 de ff ff       	call   807ecf <ntohl>
  809fdc:	21 c6                	and    %eax,%esi
  809fde:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809fe5:	e8 e5 de ff ff       	call   807ecf <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809fea:	39 c6                	cmp    %eax,%esi
  809fec:	0f 84 d9 01 00 00    	je     80a1cb <etharp_query+0x220>
      ip_addr_ismulticast(ipaddr) ||
  809ff2:	85 db                	test   %ebx,%ebx
  809ff4:	0f 84 d5 01 00 00    	je     80a1cf <etharp_query+0x224>
      ip_addr_isany(ipaddr)) {
  809ffa:	83 3b 00             	cmpl   $0x0,(%ebx)
  809ffd:	0f 84 d0 01 00 00    	je     80a1d3 <etharp_query+0x228>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80a003:	ba 01 00 00 00       	mov    $0x1,%edx
  80a008:	89 d8                	mov    %ebx,%eax
  80a00a:	e8 03 f8 ff ff       	call   809812 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80a00f:	84 c0                	test   %al,%al
  80a011:	0f 88 c6 01 00 00    	js     80a1dd <etharp_query+0x232>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80a017:	0f be f0             	movsbl %al,%esi
  80a01a:	8d 04 b5 00 00 00 00 	lea    0x0(,%esi,4),%eax
  80a021:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  80a028:	29 c2                	sub    %eax,%edx
  80a02a:	8b 82 70 5a b3 00    	mov    0xb35a70(%edx),%eax
  80a030:	85 c0                	test   %eax,%eax
  80a032:	75 1c                	jne    80a050 <etharp_query+0xa5>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80a034:	8d 04 b5 00 00 00 00 	lea    0x0(,%esi,4),%eax
  80a03b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  80a042:	29 c2                	sub    %eax,%edx
  80a044:	c7 82 70 5a b3 00 01 	movl   $0x1,0xb35a70(%edx)
  80a04b:	00 00 00 
  80a04e:	eb 37                	jmp    80a087 <etharp_query+0xdc>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80a050:	8d 50 ff             	lea    -0x1(%eax),%edx
  80a053:	83 fa 01             	cmp    $0x1,%edx
  80a056:	76 1c                	jbe    80a074 <etharp_query+0xc9>
  80a058:	c7 44 24 08 cc 2e 81 	movl   $0x812ecc,0x8(%esp)
  80a05f:	00 
  80a060:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80a067:	00 
  80a068:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  80a06f:	e8 0c 4e 00 00       	call   80ee80 <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80a074:	83 f8 01             	cmp    $0x1,%eax
  80a077:	74 0e                	je     80a087 <etharp_query+0xdc>
  80a079:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80a07d:	0f 84 75 01 00 00    	je     80a1f8 <etharp_query+0x24d>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  80a083:	b3 ff                	mov    $0xff,%bl
  80a085:	eb 18                	jmp    80a09f <etharp_query+0xf4>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a087:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a08b:	89 3c 24             	mov    %edi,(%esp)
  80a08e:	e8 e7 fd ff ff       	call   809e7a <etharp_request>
  80a093:	88 c3                	mov    %al,%bl
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80a095:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80a099:	0f 84 3e 01 00 00    	je     80a1dd <etharp_query+0x232>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80a09f:	8d 04 b5 00 00 00 00 	lea    0x0(,%esi,4),%eax
  80a0a6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  80a0ad:	29 c2                	sub    %eax,%edx
  80a0af:	8b 82 70 5a b3 00    	mov    0xb35a70(%edx),%eax
  80a0b5:	83 f8 02             	cmp    $0x2,%eax
  80a0b8:	75 1c                	jne    80a0d6 <etharp_query+0x12b>
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  80a0ba:	8d 4f 25             	lea    0x25(%edi),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80a0bd:	89 d0                	mov    %edx,%eax
  80a0bf:	05 68 5a b3 00       	add    $0xb35a68,%eax
  80a0c4:	89 04 24             	mov    %eax,(%esp)
  80a0c7:	8b 55 10             	mov    0x10(%ebp),%edx
  80a0ca:	89 f8                	mov    %edi,%eax
  80a0cc:	e8 33 f6 ff ff       	call   809704 <etharp_send_ip>
  80a0d1:	e9 07 01 00 00       	jmp    80a1dd <etharp_query+0x232>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80a0d6:	83 f8 01             	cmp    $0x1,%eax
  80a0d9:	0f 85 f8 00 00 00    	jne    80a1d7 <etharp_query+0x22c>
  80a0df:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80a0e2:	8b 50 08             	mov    0x8(%eax),%edx
  80a0e5:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  80a0e9:	75 21                	jne    80a10c <etharp_query+0x161>
  80a0eb:	83 38 00             	cmpl   $0x0,(%eax)
  80a0ee:	74 1c                	je     80a10c <etharp_query+0x161>
  80a0f0:	c7 44 24 08 71 2f 81 	movl   $0x812f71,0x8(%esp)
  80a0f7:	00 
  80a0f8:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80a0ff:	00 
  80a100:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  80a107:	e8 74 4d 00 00       	call   80ee80 <_panic>
        if(p->type != PBUF_ROM) {
  80a10c:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80a110:	75 0b                	jne    80a11d <etharp_query+0x172>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80a112:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80a114:	85 c0                	test   %eax,%eax
  80a116:	75 ca                	jne    80a0e2 <etharp_query+0x137>
  80a118:	e9 c8 00 00 00       	jmp    80a1e5 <etharp_query+0x23a>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80a11d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80a121:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80a128:	00 
  80a129:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a12d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80a134:	e8 19 ae ff ff       	call   804f52 <pbuf_alloc>
  80a139:	89 c7                	mov    %eax,%edi
        if(p != NULL) {
  80a13b:	85 c0                	test   %eax,%eax
  80a13d:	0f 84 98 00 00 00    	je     80a1db <etharp_query+0x230>
          if (pbuf_copy(p, q) != ERR_OK) {
  80a143:	8b 55 10             	mov    0x10(%ebp),%edx
  80a146:	89 54 24 04          	mov    %edx,0x4(%esp)
  80a14a:	89 04 24             	mov    %eax,(%esp)
  80a14d:	e8 e7 b1 ff ff       	call   805339 <pbuf_copy>
  80a152:	84 c0                	test   %al,%al
  80a154:	74 0c                	je     80a162 <etharp_query+0x1b7>
            pbuf_free(p);
  80a156:	89 3c 24             	mov    %edi,(%esp)
  80a159:	e8 f3 ab ff ff       	call   804d51 <pbuf_free>
  80a15e:	88 d8                	mov    %bl,%al
  80a160:	eb 7b                	jmp    80a1dd <etharp_query+0x232>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80a162:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80a169:	e8 f8 a7 ff ff       	call   804966 <memp_malloc>
        if (new_entry != NULL) {
  80a16e:	85 c0                	test   %eax,%eax
  80a170:	74 49                	je     80a1bb <etharp_query+0x210>
          new_entry->next = 0;
  80a172:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80a178:	89 78 04             	mov    %edi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80a17b:	8d 14 b5 00 00 00 00 	lea    0x0(,%esi,4),%edx
  80a182:	8d 0c d5 00 00 00 00 	lea    0x0(,%edx,8),%ecx
  80a189:	29 d1                	sub    %edx,%ecx
  80a18b:	8b 89 60 5a b3 00    	mov    0xb35a60(%ecx),%ecx
  80a191:	85 c9                	test   %ecx,%ecx
  80a193:	75 04                	jne    80a199 <etharp_query+0x1ee>
  80a195:	eb 0e                	jmp    80a1a5 <etharp_query+0x1fa>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
              r = r->next;
  80a197:	89 d1                	mov    %edx,%ecx
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80a199:	8b 11                	mov    (%ecx),%edx
  80a19b:	85 d2                	test   %edx,%edx
  80a19d:	75 f8                	jne    80a197 <etharp_query+0x1ec>
              r = r->next;
            }
            r->next = new_entry;
  80a19f:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80a1a1:	b0 00                	mov    $0x0,%al
  80a1a3:	eb 38                	jmp    80a1dd <etharp_query+0x232>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80a1a5:	c1 e6 02             	shl    $0x2,%esi
  80a1a8:	8d 14 f5 00 00 00 00 	lea    0x0(,%esi,8),%edx
  80a1af:	29 f2                	sub    %esi,%edx
  80a1b1:	89 82 60 5a b3 00    	mov    %eax,0xb35a60(%edx)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80a1b7:	b0 00                	mov    $0x0,%al
  80a1b9:	eb 22                	jmp    80a1dd <etharp_query+0x232>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80a1bb:	89 3c 24             	mov    %edi,(%esp)
  80a1be:	e8 8e ab ff ff       	call   804d51 <pbuf_free>
  80a1c3:	88 d8                	mov    %bl,%al
  80a1c5:	eb 16                	jmp    80a1dd <etharp_query+0x232>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80a1c7:	b0 f6                	mov    $0xf6,%al
  80a1c9:	eb 12                	jmp    80a1dd <etharp_query+0x232>
  80a1cb:	b0 f6                	mov    $0xf6,%al
  80a1cd:	eb 0e                	jmp    80a1dd <etharp_query+0x232>
  80a1cf:	b0 f6                	mov    $0xf6,%al
  80a1d1:	eb 0a                	jmp    80a1dd <etharp_query+0x232>
  80a1d3:	b0 f6                	mov    $0xf6,%al
  80a1d5:	eb 06                	jmp    80a1dd <etharp_query+0x232>
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80a1d7:	88 d8                	mov    %bl,%al
  80a1d9:	eb 02                	jmp    80a1dd <etharp_query+0x232>
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
  80a1db:	88 d8                	mov    %bl,%al
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80a1dd:	83 c4 1c             	add    $0x1c,%esp
  80a1e0:	5b                   	pop    %ebx
  80a1e1:	5e                   	pop    %esi
  80a1e2:	5f                   	pop    %edi
  80a1e3:	5d                   	pop    %ebp
  80a1e4:	c3                   	ret    
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80a1e5:	8b 55 10             	mov    0x10(%ebp),%edx
  80a1e8:	89 14 24             	mov    %edx,(%esp)
  80a1eb:	e8 fb af ff ff       	call   8051eb <pbuf_ref>
            p = NULL;
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  80a1f0:	8b 7d 10             	mov    0x10(%ebp),%edi
  80a1f3:	e9 6a ff ff ff       	jmp    80a162 <etharp_query+0x1b7>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a1f8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a1fc:	89 3c 24             	mov    %edi,(%esp)
  80a1ff:	e8 76 fc ff ff       	call   809e7a <etharp_request>
  80a204:	eb d7                	jmp    80a1dd <etharp_query+0x232>

0080a206 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80a206:	55                   	push   %ebp
  80a207:	89 e5                	mov    %esp,%ebp
  80a209:	57                   	push   %edi
  80a20a:	56                   	push   %esi
  80a20b:	53                   	push   %ebx
  80a20c:	83 ec 3c             	sub    $0x3c,%esp
  80a20f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a212:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80a215:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80a218:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80a21f:	00 
  80a220:	89 3c 24             	mov    %edi,(%esp)
  80a223:	e8 44 aa ff ff       	call   804c6c <pbuf_header>
  80a228:	84 c0                	test   %al,%al
  80a22a:	0f 85 b8 00 00 00    	jne    80a2e8 <etharp_output+0xe2>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80a230:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a234:	89 34 24             	mov    %esi,(%esp)
  80a237:	e8 60 c7 ff ff       	call   80699c <ip_addr_isbroadcast>
  80a23c:	84 c0                	test   %al,%al
  80a23e:	0f 85 8e 00 00 00    	jne    80a2d2 <etharp_output+0xcc>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80a244:	8b 06                	mov    (%esi),%eax
  80a246:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80a249:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80a250:	e8 7a dc ff ff       	call   807ecf <ntohl>
  80a255:	23 45 d4             	and    -0x2c(%ebp),%eax
  80a258:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80a25b:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a262:	e8 68 dc ff ff       	call   807ecf <ntohl>
  80a267:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80a26a:	75 41                	jne    80a2ad <etharp_output+0xa7>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80a26c:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80a270:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80a274:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80a278:	8b 06                	mov    (%esi),%eax
  80a27a:	89 04 24             	mov    %eax,(%esp)
  80a27d:	e8 4d dc ff ff       	call   807ecf <ntohl>
  80a282:	c1 e8 10             	shr    $0x10,%eax
  80a285:	83 e0 7f             	and    $0x7f,%eax
  80a288:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80a28b:	8b 06                	mov    (%esi),%eax
  80a28d:	89 04 24             	mov    %eax,(%esp)
  80a290:	e8 3a dc ff ff       	call   807ecf <ntohl>
  80a295:	c1 e8 08             	shr    $0x8,%eax
  80a298:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80a29b:	8b 06                	mov    (%esi),%eax
  80a29d:	89 04 24             	mov    %eax,(%esp)
  80a2a0:	e8 2a dc ff ff       	call   807ecf <ntohl>
  80a2a5:	88 45 e7             	mov    %al,-0x19(%ebp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  80a2a8:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  80a2ab:	eb 2a                	jmp    80a2d7 <etharp_output+0xd1>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80a2ad:	8b 43 04             	mov    0x4(%ebx),%eax
  80a2b0:	33 06                	xor    (%esi),%eax
  80a2b2:	85 43 08             	test   %eax,0x8(%ebx)
  80a2b5:	74 09                	je     80a2c0 <etharp_output+0xba>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80a2b7:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80a2bb:	74 2f                	je     80a2ec <etharp_output+0xe6>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80a2bd:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80a2c0:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80a2c4:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a2c8:	89 1c 24             	mov    %ebx,(%esp)
  80a2cb:	e8 db fc ff ff       	call   809fab <etharp_query>
  80a2d0:	eb 1c                	jmp    80a2ee <etharp_output+0xe8>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  80a2d2:	b8 91 2f 81 00       	mov    $0x812f91,%eax
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80a2d7:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80a2da:	89 04 24             	mov    %eax,(%esp)
  80a2dd:	89 fa                	mov    %edi,%edx
  80a2df:	89 d8                	mov    %ebx,%eax
  80a2e1:	e8 1e f4 ff ff       	call   809704 <etharp_send_ip>
  80a2e6:	eb 06                	jmp    80a2ee <etharp_output+0xe8>
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  80a2e8:	b0 fe                	mov    $0xfe,%al
  80a2ea:	eb 02                	jmp    80a2ee <etharp_output+0xe8>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  80a2ec:	b0 fc                	mov    $0xfc,%al

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
  80a2ee:	83 c4 3c             	add    $0x3c,%esp
  80a2f1:	5b                   	pop    %ebx
  80a2f2:	5e                   	pop    %esi
  80a2f3:	5f                   	pop    %edi
  80a2f4:	5d                   	pop    %ebp
  80a2f5:	c3                   	ret    

0080a2f6 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80a2f6:	55                   	push   %ebp
  80a2f7:	89 e5                	mov    %esp,%ebp
  80a2f9:	56                   	push   %esi
  80a2fa:	53                   	push   %ebx
  80a2fb:	83 ec 10             	sub    $0x10,%esp
  80a2fe:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a301:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80a304:	8b 43 04             	mov    0x4(%ebx),%eax
  80a307:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80a30b:	89 04 24             	mov    %eax,(%esp)
  80a30e:	e8 46 d9 ff ff       	call   807c59 <htons>
  80a313:	66 3d 00 08          	cmp    $0x800,%ax
  80a317:	74 08                	je     80a321 <ethernet_input+0x2b>
  80a319:	66 3d 06 08          	cmp    $0x806,%ax
  80a31d:	75 61                	jne    80a380 <ethernet_input+0x8a>
  80a31f:	eb 4a                	jmp    80a36b <ethernet_input+0x75>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80a321:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a325:	89 34 24             	mov    %esi,(%esp)
  80a328:	e8 1a f9 ff ff       	call   809c47 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80a32d:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80a334:	ff 
  80a335:	89 1c 24             	mov    %ebx,(%esp)
  80a338:	e8 2f a9 ff ff       	call   804c6c <pbuf_header>
  80a33d:	84 c0                	test   %al,%al
  80a33f:	74 1c                	je     80a35d <ethernet_input+0x67>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80a341:	c7 44 24 08 f4 2e 81 	movl   $0x812ef4,0x8(%esp)
  80a348:	00 
  80a349:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80a350:	00 
  80a351:	c7 04 24 15 2f 81 00 	movl   $0x812f15,(%esp)
  80a358:	e8 23 4b 00 00       	call   80ee80 <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80a35d:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a361:	89 1c 24             	mov    %ebx,(%esp)
  80a364:	e8 ca c6 ff ff       	call   806a33 <ip_input>
      }
      break;
  80a369:	eb 1d                	jmp    80a388 <ethernet_input+0x92>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80a36b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80a36f:	8d 46 25             	lea    0x25(%esi),%eax
  80a372:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a376:	89 34 24             	mov    %esi,(%esp)
  80a379:	e8 17 f9 ff ff       	call   809c95 <etharp_arp_input>
      break;
  80a37e:	eb 08                	jmp    80a388 <ethernet_input+0x92>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80a380:	89 1c 24             	mov    %ebx,(%esp)
  80a383:	e8 c9 a9 ff ff       	call   804d51 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80a388:	b0 00                	mov    $0x0,%al
  80a38a:	83 c4 10             	add    $0x10,%esp
  80a38d:	5b                   	pop    %ebx
  80a38e:	5e                   	pop    %esi
  80a38f:	5d                   	pop    %ebp
  80a390:	c3                   	ret    
  80a391:	00 00                	add    %al,(%eax)
	...

0080a394 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80a394:	55                   	push   %ebp
  80a395:	89 e5                	mov    %esp,%ebp
  80a397:	53                   	push   %ebx
  80a398:	83 ec 14             	sub    $0x14,%esp
  80a39b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a39e:	bb 01 01 00 00       	mov    $0x101,%ebx
  80a3a3:	89 c8                	mov    %ecx,%eax
  80a3a5:	ba 00 00 00 00       	mov    $0x0,%edx
  80a3aa:	f7 f3                	div    %ebx
  80a3ac:	8b 04 95 c0 bd b3 00 	mov    0xb3bdc0(,%edx,4),%eax
  80a3b3:	eb 26                	jmp    80a3db <timeout_cleanup+0x47>
	if (t->tid == tid) {
  80a3b5:	39 08                	cmp    %ecx,(%eax)
  80a3b7:	75 1f                	jne    80a3d8 <timeout_cleanup+0x44>
	    LIST_REMOVE(t, link);
  80a3b9:	8b 50 08             	mov    0x8(%eax),%edx
  80a3bc:	85 d2                	test   %edx,%edx
  80a3be:	74 06                	je     80a3c6 <timeout_cleanup+0x32>
  80a3c0:	8b 48 0c             	mov    0xc(%eax),%ecx
  80a3c3:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80a3c6:	8b 50 0c             	mov    0xc(%eax),%edx
  80a3c9:	8b 48 08             	mov    0x8(%eax),%ecx
  80a3cc:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  80a3ce:	89 04 24             	mov    %eax,(%esp)
  80a3d1:	e8 8a 6a 00 00       	call   810e60 <free>
	    goto done;
  80a3d6:	eb 07                	jmp    80a3df <timeout_cleanup+0x4b>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a3d8:	8b 40 08             	mov    0x8(%eax),%eax
  80a3db:	85 c0                	test   %eax,%eax
  80a3dd:	75 d6                	jne    80a3b5 <timeout_cleanup+0x21>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80a3df:	83 c4 14             	add    $0x14,%esp
  80a3e2:	5b                   	pop    %ebx
  80a3e3:	5d                   	pop    %ebp
  80a3e4:	c3                   	ret    

0080a3e5 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80a3e5:	55                   	push   %ebp
  80a3e6:	89 e5                	mov    %esp,%ebp
  80a3e8:	53                   	push   %ebx
  80a3e9:	83 ec 14             	sub    $0x14,%esp
  80a3ec:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80a3ef:	8b 43 04             	mov    0x4(%ebx),%eax
  80a3f2:	89 04 24             	mov    %eax,(%esp)
  80a3f5:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80a3f7:	89 1c 24             	mov    %ebx,(%esp)
  80a3fa:	e8 61 6a 00 00       	call   810e60 <free>
}
  80a3ff:	83 c4 14             	add    $0x14,%esp
  80a402:	5b                   	pop    %ebx
  80a403:	5d                   	pop    %ebp
  80a404:	c3                   	ret    

0080a405 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80a405:	55                   	push   %ebp
  80a406:	89 e5                	mov    %esp,%ebp
  80a408:	56                   	push   %esi
  80a409:	53                   	push   %ebx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80a40a:	8b 0d 80 6f b3 00    	mov    0xb36f80,%ecx
  80a410:	bb 80 5b b3 00       	mov    $0xb35b80,%ebx
  80a415:	b8 00 00 00 00       	mov    $0x0,%eax
  80a41a:	eb 02                	jmp    80a41e <sys_init+0x19>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a41c:	89 d1                	mov    %edx,%ecx
void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80a41e:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a424:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a427:	8d 14 95 80 5b b3 00 	lea    0xb35b80(,%edx,4),%edx
  80a42e:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80a431:	85 c9                	test   %ecx,%ecx
  80a433:	74 06                	je     80a43b <sys_init+0x36>
  80a435:	8d 72 0c             	lea    0xc(%edx),%esi
  80a438:	89 71 10             	mov    %esi,0x10(%ecx)
  80a43b:	c7 42 10 80 6f b3 00 	movl   $0xb36f80,0x10(%edx)

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80a442:	40                   	inc    %eax
  80a443:	83 c3 14             	add    $0x14,%ebx
  80a446:	3d 00 01 00 00       	cmp    $0x100,%eax
  80a44b:	75 cf                	jne    80a41c <sys_init+0x17>
  80a44d:	89 15 80 6f b3 00    	mov    %edx,0xb36f80
  80a453:	8b 0d a0 bd b3 00    	mov    0xb3bda0,%ecx
  80a459:	bb a0 6f b3 00       	mov    $0xb36fa0,%ebx
  80a45e:	66 b8 00 00          	mov    $0x0,%ax
  80a462:	eb 02                	jmp    80a466 <sys_init+0x61>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a464:	89 d1                	mov    %edx,%ecx
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80a466:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a46c:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a46f:	c1 e2 03             	shl    $0x3,%edx
  80a472:	29 c2                	sub    %eax,%edx
  80a474:	8d 14 95 a0 6f b3 00 	lea    0xb36fa0(,%edx,4),%edx
  80a47b:	89 8a 94 00 00 00    	mov    %ecx,0x94(%edx)
  80a481:	85 c9                	test   %ecx,%ecx
  80a483:	74 0c                	je     80a491 <sys_init+0x8c>
  80a485:	8d b2 94 00 00 00    	lea    0x94(%edx),%esi
  80a48b:	89 b1 98 00 00 00    	mov    %esi,0x98(%ecx)
  80a491:	c7 82 98 00 00 00 a0 	movl   $0xb3bda0,0x98(%edx)
  80a498:	bd b3 00 
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80a49b:	40                   	inc    %eax
  80a49c:	81 c3 9c 00 00 00    	add    $0x9c,%ebx
  80a4a2:	3d 80 00 00 00       	cmp    $0x80,%eax
  80a4a7:	75 bb                	jne    80a464 <sys_init+0x5f>
  80a4a9:	89 15 a0 bd b3 00    	mov    %edx,0xb3bda0
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80a4af:	5b                   	pop    %ebx
  80a4b0:	5e                   	pop    %esi
  80a4b1:	5d                   	pop    %ebp
  80a4b2:	c3                   	ret    

0080a4b3 <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80a4b3:	55                   	push   %ebp
  80a4b4:	89 e5                	mov    %esp,%ebp
  80a4b6:	53                   	push   %ebx
  80a4b7:	83 ec 14             	sub    $0x14,%esp
  80a4ba:	8a 4d 08             	mov    0x8(%ebp),%cl
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80a4bd:	a1 80 6f b3 00       	mov    0xb36f80,%eax
    if (!se) {
  80a4c2:	85 c0                	test   %eax,%eax
  80a4c4:	75 13                	jne    80a4d9 <sys_sem_new+0x26>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80a4c6:	c7 04 24 98 2f 81 00 	movl   $0x812f98,(%esp)
  80a4cd:	e8 a6 4a 00 00       	call   80ef78 <cprintf>
	return SYS_SEM_NULL;
  80a4d2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a4d7:	eb 70                	jmp    80a549 <sys_sem_new+0x96>
    }
    LIST_REMOVE(se, link);
  80a4d9:	8b 50 0c             	mov    0xc(%eax),%edx
  80a4dc:	85 d2                	test   %edx,%edx
  80a4de:	74 06                	je     80a4e6 <sys_sem_new+0x33>
  80a4e0:	8b 58 10             	mov    0x10(%eax),%ebx
  80a4e3:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a4e6:	8b 50 10             	mov    0x10(%eax),%edx
  80a4e9:	8b 58 0c             	mov    0xc(%eax),%ebx
  80a4ec:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80a4ee:	83 38 00             	cmpl   $0x0,(%eax)
  80a4f1:	75 24                	jne    80a517 <sys_sem_new+0x64>
  80a4f3:	c7 44 24 0c 0d 31 81 	movl   $0x81310d,0xc(%esp)
  80a4fa:	00 
  80a4fb:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  80a502:	00 
  80a503:	c7 44 24 04 8d 00 00 	movl   $0x8d,0x4(%esp)
  80a50a:	00 
  80a50b:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80a512:	e8 69 49 00 00       	call   80ee80 <_panic>
    se->freed = 0;
  80a517:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80a51d:	0f b6 c9             	movzbl %cl,%ecx
  80a520:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80a524:	ff 40 04             	incl   0x4(%eax)
    return se - &sems[0];
  80a527:	2d 80 5b b3 00       	sub    $0xb35b80,%eax
  80a52c:	c1 f8 02             	sar    $0x2,%eax
  80a52f:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a532:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a535:	8d 14 50             	lea    (%eax,%edx,2),%edx
  80a538:	89 d1                	mov    %edx,%ecx
  80a53a:	c1 e1 08             	shl    $0x8,%ecx
  80a53d:	01 ca                	add    %ecx,%edx
  80a53f:	89 d1                	mov    %edx,%ecx
  80a541:	c1 e1 10             	shl    $0x10,%ecx
  80a544:	01 ca                	add    %ecx,%edx
  80a546:	8d 04 90             	lea    (%eax,%edx,4),%eax
}
  80a549:	83 c4 14             	add    $0x14,%esp
  80a54c:	5b                   	pop    %ebx
  80a54d:	5d                   	pop    %ebp
  80a54e:	c3                   	ret    

0080a54f <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  80a54f:	55                   	push   %ebp
  80a550:	89 e5                	mov    %esp,%ebp
  80a552:	83 ec 18             	sub    $0x18,%esp
  80a555:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a558:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a55b:	83 3c 95 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%edx,4)
  80a562:	00 
  80a563:	74 24                	je     80a589 <sys_sem_free+0x3a>
  80a565:	c7 44 24 0c 49 31 81 	movl   $0x813149,0xc(%esp)
  80a56c:	00 
  80a56d:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  80a574:	00 
  80a575:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80a57c:	00 
  80a57d:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80a584:	e8 f7 48 00 00       	call   80ee80 <_panic>
    sems[sem].freed = 1;
  80a589:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a58c:	c1 e2 02             	shl    $0x2,%edx
  80a58f:	8d 82 80 5b b3 00    	lea    0xb35b80(%edx),%eax
  80a595:	c7 82 80 5b b3 00 01 	movl   $0x1,0xb35b80(%edx)
  80a59c:	00 00 00 
    sems[sem].gen++;
  80a59f:	ff 40 04             	incl   0x4(%eax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80a5a2:	8b 15 80 6f b3 00    	mov    0xb36f80,%edx
  80a5a8:	89 50 0c             	mov    %edx,0xc(%eax)
  80a5ab:	85 d2                	test   %edx,%edx
  80a5ad:	74 06                	je     80a5b5 <sys_sem_free+0x66>
  80a5af:	8d 48 0c             	lea    0xc(%eax),%ecx
  80a5b2:	89 4a 10             	mov    %ecx,0x10(%edx)
  80a5b5:	a3 80 6f b3 00       	mov    %eax,0xb36f80
  80a5ba:	c7 40 10 80 6f b3 00 	movl   $0xb36f80,0x10(%eax)
}
  80a5c1:	c9                   	leave  
  80a5c2:	c3                   	ret    

0080a5c3 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80a5c3:	55                   	push   %ebp
  80a5c4:	89 e5                	mov    %esp,%ebp
  80a5c6:	56                   	push   %esi
  80a5c7:	53                   	push   %ebx
  80a5c8:	83 ec 10             	sub    $0x10,%esp
  80a5cb:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a5ce:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80a5d1:	c1 e0 03             	shl    $0x3,%eax
  80a5d4:	29 d8                	sub    %ebx,%eax
  80a5d6:	83 3c 85 a0 6f b3 00 	cmpl   $0x0,0xb36fa0(,%eax,4)
  80a5dd:	00 
  80a5de:	74 24                	je     80a604 <sys_mbox_free+0x41>
  80a5e0:	c7 44 24 0c 5a 31 81 	movl   $0x81315a,0xc(%esp)
  80a5e7:	00 
  80a5e8:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  80a5ef:	00 
  80a5f0:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  80a5f7:	00 
  80a5f8:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80a5ff:	e8 7c 48 00 00       	call   80ee80 <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80a604:	8d 34 9d 00 00 00 00 	lea    0x0(,%ebx,4),%esi
  80a60b:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
  80a60e:	c1 e0 03             	shl    $0x3,%eax
  80a611:	29 d8                	sub    %ebx,%eax
  80a613:	8b 04 85 2c 70 b3 00 	mov    0xb3702c(,%eax,4),%eax
  80a61a:	89 04 24             	mov    %eax,(%esp)
  80a61d:	e8 2d ff ff ff       	call   80a54f <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80a622:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
  80a625:	c1 e0 03             	shl    $0x3,%eax
  80a628:	29 d8                	sub    %ebx,%eax
  80a62a:	8b 04 85 30 70 b3 00 	mov    0xb37030(,%eax,4),%eax
  80a631:	89 04 24             	mov    %eax,(%esp)
  80a634:	e8 16 ff ff ff       	call   80a54f <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80a639:	01 de                	add    %ebx,%esi
  80a63b:	c1 e6 03             	shl    $0x3,%esi
  80a63e:	29 de                	sub    %ebx,%esi
  80a640:	8d 04 b5 a0 6f b3 00 	lea    0xb36fa0(,%esi,4),%eax
  80a647:	8b 15 a0 bd b3 00    	mov    0xb3bda0,%edx
  80a64d:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80a653:	85 d2                	test   %edx,%edx
  80a655:	74 0c                	je     80a663 <sys_mbox_free+0xa0>
  80a657:	8d 88 94 00 00 00    	lea    0x94(%eax),%ecx
  80a65d:	89 8a 98 00 00 00    	mov    %ecx,0x98(%edx)
  80a663:	a3 a0 bd b3 00       	mov    %eax,0xb3bda0
  80a668:	c7 80 98 00 00 00 a0 	movl   $0xb3bda0,0x98(%eax)
  80a66f:	bd b3 00 
    mboxes[mbox].freed = 1;
  80a672:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80a675:	c1 e0 03             	shl    $0x3,%eax
  80a678:	29 d8                	sub    %ebx,%eax
  80a67a:	c7 04 85 a0 6f b3 00 	movl   $0x1,0xb36fa0(,%eax,4)
  80a681:	01 00 00 00 
}
  80a685:	83 c4 10             	add    $0x10,%esp
  80a688:	5b                   	pop    %ebx
  80a689:	5e                   	pop    %esi
  80a68a:	5d                   	pop    %ebp
  80a68b:	c3                   	ret    

0080a68c <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80a68c:	55                   	push   %ebp
  80a68d:	89 e5                	mov    %esp,%ebp
  80a68f:	57                   	push   %edi
  80a690:	56                   	push   %esi
  80a691:	53                   	push   %ebx
  80a692:	83 ec 1c             	sub    $0x1c,%esp
    assert(size < MBOXSLOTS);
  80a695:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a699:	7e 24                	jle    80a6bf <sys_mbox_new+0x33>
  80a69b:	c7 44 24 0c 6e 31 81 	movl   $0x81316e,0xc(%esp)
  80a6a2:	00 
  80a6a3:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  80a6aa:	00 
  80a6ab:	c7 44 24 04 45 00 00 	movl   $0x45,0x4(%esp)
  80a6b2:	00 
  80a6b3:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80a6ba:	e8 c1 47 00 00       	call   80ee80 <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a6bf:	8b 1d a0 bd b3 00    	mov    0xb3bda0,%ebx
    if (!mbe) {
  80a6c5:	85 db                	test   %ebx,%ebx
  80a6c7:	75 16                	jne    80a6df <sys_mbox_new+0x53>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a6c9:	c7 04 24 c0 2f 81 00 	movl   $0x812fc0,(%esp)
  80a6d0:	e8 a3 48 00 00       	call   80ef78 <cprintf>
	return SYS_MBOX_NULL;
  80a6d5:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80a6da:	e9 d8 00 00 00       	jmp    80a7b7 <sys_mbox_new+0x12b>
    }
    LIST_REMOVE(mbe, link);
  80a6df:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a6e5:	85 c0                	test   %eax,%eax
  80a6e7:	74 0c                	je     80a6f5 <sys_mbox_new+0x69>
  80a6e9:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a6ef:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a6f5:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a6fb:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a701:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a703:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a706:	75 24                	jne    80a72c <sys_mbox_new+0xa0>
  80a708:	c7 44 24 0c 7f 31 81 	movl   $0x81317f,0xc(%esp)
  80a70f:	00 
  80a710:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  80a717:	00 
  80a718:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  80a71f:	00 
  80a720:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80a727:	e8 54 47 00 00       	call   80ee80 <_panic>
    mbe->freed = 0;
  80a72c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80a732:	89 d8                	mov    %ebx,%eax
  80a734:	2d a0 6f b3 00       	sub    $0xb36fa0,%eax
  80a739:	c1 f8 02             	sar    $0x2,%eax
  80a73c:	8d 14 40             	lea    (%eax,%eax,2),%edx
  80a73f:	8d 14 90             	lea    (%eax,%edx,4),%edx
  80a742:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  80a745:	89 d1                	mov    %edx,%ecx
  80a747:	c1 e1 0c             	shl    $0xc,%ecx
  80a74a:	01 ca                	add    %ecx,%edx
  80a74c:	c1 e2 06             	shl    $0x6,%edx
  80a74f:	01 c2                	add    %eax,%edx
  80a751:	8d 14 50             	lea    (%eax,%edx,2),%edx
  80a754:	8d 14 90             	lea    (%eax,%edx,4),%edx
  80a757:	8d 3c d0             	lea    (%eax,%edx,8),%edi
  80a75a:	f7 df                	neg    %edi
  80a75c:	89 fe                	mov    %edi,%esi
    mbe->head = -1;
  80a75e:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a765:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a76c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80a773:	e8 3b fd ff ff       	call   80a4b3 <sys_sem_new>
  80a778:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a77e:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a785:	e8 29 fd ff ff       	call   80a4b3 <sys_sem_new>
  80a78a:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a790:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a797:	74 05                	je     80a79e <sys_mbox_new+0x112>
  80a799:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a79c:	75 19                	jne    80a7b7 <sys_mbox_new+0x12b>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80a79e:	89 3c 24             	mov    %edi,(%esp)
  80a7a1:	e8 1d fe ff ff       	call   80a5c3 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a7a6:	c7 04 24 e8 2f 81 00 	movl   $0x812fe8,(%esp)
  80a7ad:	e8 c6 47 00 00       	call   80ef78 <cprintf>
	return SYS_MBOX_NULL;
  80a7b2:	be ff ff ff ff       	mov    $0xffffffff,%esi
    }
    return i;
}
  80a7b7:	89 f0                	mov    %esi,%eax
  80a7b9:	83 c4 1c             	add    $0x1c,%esp
  80a7bc:	5b                   	pop    %ebx
  80a7bd:	5e                   	pop    %esi
  80a7be:	5f                   	pop    %edi
  80a7bf:	5d                   	pop    %ebp
  80a7c0:	c3                   	ret    

0080a7c1 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80a7c1:	55                   	push   %ebp
  80a7c2:	89 e5                	mov    %esp,%ebp
  80a7c4:	83 ec 18             	sub    $0x18,%esp
  80a7c7:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a7ca:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a7cd:	83 3c 95 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%edx,4)
  80a7d4:	00 
  80a7d5:	74 24                	je     80a7fb <sys_sem_signal+0x3a>
  80a7d7:	c7 44 24 0c 49 31 81 	movl   $0x813149,0xc(%esp)
  80a7de:	00 
  80a7df:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  80a7e6:	00 
  80a7e7:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80a7ee:	00 
  80a7ef:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80a7f6:	e8 85 46 00 00       	call   80ee80 <_panic>
    sems[sem].counter++;
  80a7fb:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a7fe:	8d 14 95 80 5b b3 00 	lea    0xb35b80(,%edx,4),%edx
  80a805:	66 ff 42 08          	incw   0x8(%edx)
    if (sems[sem].waiters) {
  80a809:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a80e:	74 13                	je     80a823 <sys_sem_signal+0x62>
	sems[sem].waiters = 0;
  80a810:	89 d0                	mov    %edx,%eax
  80a812:	66 c7 42 0a 00 00    	movw   $0x0,0xa(%edx)
	thread_wakeup(&sems[sem].v);
  80a818:	83 c0 08             	add    $0x8,%eax
  80a81b:	89 04 24             	mov    %eax,(%esp)
  80a81e:	e8 64 05 00 00       	call   80ad87 <thread_wakeup>
    }
}
  80a823:	c9                   	leave  
  80a824:	c3                   	ret    

0080a825 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80a825:	55                   	push   %ebp
  80a826:	89 e5                	mov    %esp,%ebp
  80a828:	57                   	push   %edi
  80a829:	56                   	push   %esi
  80a82a:	53                   	push   %ebx
  80a82b:	83 ec 2c             	sub    $0x2c,%esp
  80a82e:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a831:	8b 55 08             	mov    0x8(%ebp),%edx
  80a834:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80a837:	83 3c 85 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%eax,4)
  80a83e:	00 
  80a83f:	74 24                	je     80a865 <sys_arch_sem_wait+0x40>
  80a841:	c7 44 24 0c 49 31 81 	movl   $0x813149,0xc(%esp)
  80a848:	00 
  80a849:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  80a850:	00 
  80a851:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  80a858:	00 
  80a859:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80a860:	e8 1b 46 00 00       	call   80ee80 <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80a865:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a868:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80a86b:	8b 04 85 84 5b b3 00 	mov    0xb35b84(,%eax,4),%eax
  80a872:	89 45 dc             	mov    %eax,-0x24(%ebp)

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  80a875:	bf 00 00 00 00       	mov    $0x0,%edi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80a87a:	8d 1c 89             	lea    (%ecx,%ecx,4),%ebx
  80a87d:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80a880:	89 df                	mov    %ebx,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a882:	e9 8c 00 00 00       	jmp    80a913 <sys_arch_sem_wait+0xee>
	if (sems[sem].counter > 0) {
  80a887:	8b 04 bd 88 5b b3 00 	mov    0xb35b88(,%edi,4),%eax
  80a88e:	66 85 c0             	test   %ax,%ax
  80a891:	74 17                	je     80a8aa <sys_arch_sem_wait+0x85>
  80a893:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	    sems[sem].counter--;
  80a896:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a899:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80a89c:	48                   	dec    %eax
  80a89d:	66 89 04 95 88 5b b3 	mov    %ax,0xb35b88(,%edx,4)
  80a8a4:	00 
	    return waited;
  80a8a5:	e9 86 00 00 00       	jmp    80a930 <sys_arch_sem_wait+0x10b>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a8aa:	83 fe fe             	cmp    $0xfffffffe,%esi
  80a8ad:	74 7c                	je     80a92b <sys_arch_sem_wait+0x106>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80a8af:	e8 c9 52 00 00       	call   80fb7d <sys_time_msec>
  80a8b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a8b7:	85 f6                	test   %esi,%esi
  80a8b9:	74 0a                	je     80a8c5 <sys_arch_sem_wait+0xa0>
  80a8bb:	89 f0                	mov    %esi,%eax
  80a8bd:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80a8c0:	03 45 e0             	add    -0x20(%ebp),%eax
  80a8c3:	eb 05                	jmp    80a8ca <sys_arch_sem_wait+0xa5>
  80a8c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	    sems[sem].waiters = 1;
  80a8ca:	8d 1c bd 80 5b b3 00 	lea    0xb35b80(,%edi,4),%ebx
  80a8d1:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a8d7:	89 44 24 08          	mov    %eax,0x8(%esp)
  80a8db:	8b 43 08             	mov    0x8(%ebx),%eax
  80a8de:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a8e2:	8d 43 08             	lea    0x8(%ebx),%eax
  80a8e5:	89 04 24             	mov    %eax,(%esp)
  80a8e8:	e8 7f 07 00 00       	call   80b06c <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80a8ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a8f0:	39 43 04             	cmp    %eax,0x4(%ebx)
  80a8f3:	74 13                	je     80a908 <sys_arch_sem_wait+0xe3>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a8f5:	c7 04 24 14 30 81 00 	movl   $0x813014,(%esp)
  80a8fc:	e8 77 46 00 00       	call   80ef78 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a901:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a906:	eb 28                	jmp    80a930 <sys_arch_sem_wait+0x10b>
	    }
	    uint32_t b = sys_time_msec();
  80a908:	e8 70 52 00 00       	call   80fb7d <sys_time_msec>
	    waited += (b - a);
  80a90d:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a910:	01 45 e4             	add    %eax,-0x1c(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a913:	85 f6                	test   %esi,%esi
  80a915:	0f 84 6c ff ff ff    	je     80a887 <sys_arch_sem_wait+0x62>
  80a91b:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80a91e:	0f 82 63 ff ff ff    	jb     80a887 <sys_arch_sem_wait+0x62>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80a924:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a929:	eb 05                	jmp    80a930 <sys_arch_sem_wait+0x10b>
    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80a92b:	bf ff ff ff ff       	mov    $0xffffffff,%edi
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80a930:	89 f8                	mov    %edi,%eax
  80a932:	83 c4 2c             	add    $0x2c,%esp
  80a935:	5b                   	pop    %ebx
  80a936:	5e                   	pop    %esi
  80a937:	5f                   	pop    %edi
  80a938:	5d                   	pop    %ebp
  80a939:	c3                   	ret    

0080a93a <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80a93a:	55                   	push   %ebp
  80a93b:	89 e5                	mov    %esp,%ebp
  80a93d:	56                   	push   %esi
  80a93e:	53                   	push   %ebx
  80a93f:	83 ec 10             	sub    $0x10,%esp
  80a942:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a945:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80a948:	c1 e0 03             	shl    $0x3,%eax
  80a94b:	29 d8                	sub    %ebx,%eax
  80a94d:	83 3c 85 a0 6f b3 00 	cmpl   $0x0,0xb36fa0(,%eax,4)
  80a954:	00 
  80a955:	74 24                	je     80a97b <sys_mbox_trypost+0x41>
  80a957:	c7 44 24 0c 5a 31 81 	movl   $0x81315a,0xc(%esp)
  80a95e:	00 
  80a95f:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  80a966:	00 
  80a967:	c7 44 24 04 72 00 00 	movl   $0x72,0x4(%esp)
  80a96e:	00 
  80a96f:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80a976:	e8 05 45 00 00       	call   80ee80 <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a97b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80a982:	00 
  80a983:	8d 34 9d 00 00 00 00 	lea    0x0(,%ebx,4),%esi
  80a98a:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
  80a98d:	c1 e0 03             	shl    $0x3,%eax
  80a990:	29 d8                	sub    %ebx,%eax
  80a992:	8b 04 85 30 70 b3 00 	mov    0xb37030(,%eax,4),%eax
  80a999:	89 04 24             	mov    %eax,(%esp)
  80a99c:	e8 84 fe ff ff       	call   80a825 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a9a1:	01 de                	add    %ebx,%esi
  80a9a3:	c1 e6 03             	shl    $0x3,%esi
  80a9a6:	29 de                	sub    %ebx,%esi
  80a9a8:	8d 14 b5 a0 6f b3 00 	lea    0xb36fa0(,%esi,4),%edx
  80a9af:	8b 42 08             	mov    0x8(%edx),%eax
  80a9b2:	3b 42 04             	cmp    0x4(%edx),%eax
  80a9b5:	74 6b                	je     80aa22 <sys_mbox_trypost+0xe8>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a9b7:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  80a9ba:	c1 e2 03             	shl    $0x3,%edx
  80a9bd:	29 da                	sub    %ebx,%edx
  80a9bf:	8d 0c 95 a0 6f b3 00 	lea    0xb36fa0(,%edx,4),%ecx
  80a9c6:	8d 50 01             	lea    0x1(%eax),%edx
  80a9c9:	81 e2 1f 00 00 80    	and    $0x8000001f,%edx
  80a9cf:	79 05                	jns    80a9d6 <sys_mbox_trypost+0x9c>
  80a9d1:	4a                   	dec    %edx
  80a9d2:	83 ca e0             	or     $0xffffffe0,%edx
  80a9d5:	42                   	inc    %edx
  80a9d6:	89 51 08             	mov    %edx,0x8(%ecx)
    mboxes[mbox].msg[slot] = msg;
  80a9d9:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  80a9dc:	c1 e2 03             	shl    $0x3,%edx
  80a9df:	29 da                	sub    %ebx,%edx
  80a9e1:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a9e4:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a9e7:	89 34 8d ac 6f b3 00 	mov    %esi,0xb36fac(,%ecx,4)

    if (mboxes[mbox].head == -1)
  80a9ee:	83 3c 95 a4 6f b3 00 	cmpl   $0xffffffff,0xb36fa4(,%edx,4)
  80a9f5:	ff 
  80a9f6:	75 0f                	jne    80aa07 <sys_mbox_trypost+0xcd>
	mboxes[mbox].head = slot;
  80a9f8:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  80a9fb:	c1 e2 03             	shl    $0x3,%edx
  80a9fe:	29 da                	sub    %ebx,%edx
  80aa00:	89 04 95 a4 6f b3 00 	mov    %eax,0xb36fa4(,%edx,4)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80aa07:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80aa0a:	c1 e0 03             	shl    $0x3,%eax
  80aa0d:	29 d8                	sub    %ebx,%eax
  80aa0f:	8b 04 85 2c 70 b3 00 	mov    0xb3702c(,%eax,4),%eax
  80aa16:	89 04 24             	mov    %eax,(%esp)
  80aa19:	e8 a3 fd ff ff       	call   80a7c1 <sys_sem_signal>

    return ERR_OK;
  80aa1e:	b0 00                	mov    $0x0,%al
  80aa20:	eb 02                	jmp    80aa24 <sys_mbox_trypost+0xea>
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
	return ERR_MEM;
  80aa22:	b0 ff                	mov    $0xff,%al
	mboxes[mbox].head = slot;

    sys_sem_signal(mboxes[mbox].queued_msg);

    return ERR_OK;
}
  80aa24:	83 c4 10             	add    $0x10,%esp
  80aa27:	5b                   	pop    %ebx
  80aa28:	5e                   	pop    %esi
  80aa29:	5d                   	pop    %ebp
  80aa2a:	c3                   	ret    

0080aa2b <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80aa2b:	55                   	push   %ebp
  80aa2c:	89 e5                	mov    %esp,%ebp
  80aa2e:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80aa31:	8b 45 0c             	mov    0xc(%ebp),%eax
  80aa34:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aa38:	8b 45 08             	mov    0x8(%ebp),%eax
  80aa3b:	89 04 24             	mov    %eax,(%esp)
  80aa3e:	e8 f7 fe ff ff       	call   80a93a <sys_mbox_trypost>
  80aa43:	84 c0                	test   %al,%al
  80aa45:	74 24                	je     80aa6b <sys_mbox_post+0x40>
  80aa47:	c7 44 24 0c 40 30 81 	movl   $0x813040,0xc(%esp)
  80aa4e:	00 
  80aa4f:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  80aa56:	00 
  80aa57:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  80aa5e:	00 
  80aa5f:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80aa66:	e8 15 44 00 00       	call   80ee80 <_panic>
}
  80aa6b:	c9                   	leave  
  80aa6c:	c3                   	ret    

0080aa6d <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80aa6d:	55                   	push   %ebp
  80aa6e:	89 e5                	mov    %esp,%ebp
  80aa70:	57                   	push   %edi
  80aa71:	56                   	push   %esi
  80aa72:	53                   	push   %ebx
  80aa73:	83 ec 1c             	sub    $0x1c,%esp
  80aa76:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aa79:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80aa7c:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80aa7f:	c1 e0 03             	shl    $0x3,%eax
  80aa82:	29 d8                	sub    %ebx,%eax
  80aa84:	83 3c 85 a0 6f b3 00 	cmpl   $0x0,0xb36fa0(,%eax,4)
  80aa8b:	00 
  80aa8c:	74 24                	je     80aab2 <sys_arch_mbox_fetch+0x45>
  80aa8e:	c7 44 24 0c 5a 31 81 	movl   $0x81315a,0xc(%esp)
  80aa95:	00 
  80aa96:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  80aa9d:	00 
  80aa9e:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80aaa5:	00 
  80aaa6:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80aaad:	e8 ce 43 00 00       	call   80ee80 <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80aab2:	8b 45 10             	mov    0x10(%ebp),%eax
  80aab5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aab9:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80aabc:	c1 e0 03             	shl    $0x3,%eax
  80aabf:	29 d8                	sub    %ebx,%eax
  80aac1:	8b 04 85 2c 70 b3 00 	mov    0xb3702c(,%eax,4),%eax
  80aac8:	89 04 24             	mov    %eax,(%esp)
  80aacb:	e8 55 fd ff ff       	call   80a825 <sys_arch_sem_wait>
  80aad0:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80aad2:	83 f8 ff             	cmp    $0xffffffff,%eax
  80aad5:	0f 84 93 00 00 00    	je     80ab6e <sys_arch_mbox_fetch+0x101>
	return waited;

    int slot = mboxes[mbox].head;
  80aadb:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80aade:	c1 e0 03             	shl    $0x3,%eax
  80aae1:	29 d8                	sub    %ebx,%eax
  80aae3:	8b 04 85 a4 6f b3 00 	mov    0xb36fa4(,%eax,4),%eax
    if (slot == -1)
  80aaea:	83 f8 ff             	cmp    $0xffffffff,%eax
  80aaed:	75 1c                	jne    80ab0b <sys_arch_mbox_fetch+0x9e>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80aaef:	c7 44 24 08 68 30 81 	movl   $0x813068,0x8(%esp)
  80aaf6:	00 
  80aaf7:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
  80aafe:	00 
  80aaff:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80ab06:	e8 75 43 00 00       	call   80ee80 <_panic>
    if (msg)
  80ab0b:	85 ff                	test   %edi,%edi
  80ab0d:	74 11                	je     80ab20 <sys_arch_mbox_fetch+0xb3>
	*msg = mboxes[mbox].msg[slot];
  80ab0f:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  80ab12:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  80ab15:	29 da                	sub    %ebx,%edx
  80ab17:	8b 14 95 ac 6f b3 00 	mov    0xb36fac(,%edx,4),%edx
  80ab1e:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80ab20:	40                   	inc    %eax
  80ab21:	25 1f 00 00 80       	and    $0x8000001f,%eax
  80ab26:	79 05                	jns    80ab2d <sys_arch_mbox_fetch+0xc0>
  80ab28:	48                   	dec    %eax
  80ab29:	83 c8 e0             	or     $0xffffffe0,%eax
  80ab2c:	40                   	inc    %eax
  80ab2d:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  80ab30:	c1 e2 03             	shl    $0x3,%edx
  80ab33:	29 da                	sub    %ebx,%edx
  80ab35:	8d 14 95 a0 6f b3 00 	lea    0xb36fa0(,%edx,4),%edx
  80ab3c:	89 42 04             	mov    %eax,0x4(%edx)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80ab3f:	3b 42 08             	cmp    0x8(%edx),%eax
  80ab42:	75 13                	jne    80ab57 <sys_arch_mbox_fetch+0xea>
	mboxes[mbox].head = -1;
  80ab44:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80ab47:	c1 e0 03             	shl    $0x3,%eax
  80ab4a:	29 d8                	sub    %ebx,%eax
  80ab4c:	c7 04 85 a4 6f b3 00 	movl   $0xffffffff,0xb36fa4(,%eax,4)
  80ab53:	ff ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80ab57:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80ab5a:	c1 e0 03             	shl    $0x3,%eax
  80ab5d:	29 d8                	sub    %ebx,%eax
  80ab5f:	8b 04 85 30 70 b3 00 	mov    0xb37030(,%eax,4),%eax
  80ab66:	89 04 24             	mov    %eax,(%esp)
  80ab69:	e8 53 fc ff ff       	call   80a7c1 <sys_sem_signal>
    return waited;
}
  80ab6e:	89 f0                	mov    %esi,%eax
  80ab70:	83 c4 1c             	add    $0x1c,%esp
  80ab73:	5b                   	pop    %ebx
  80ab74:	5e                   	pop    %esi
  80ab75:	5f                   	pop    %edi
  80ab76:	5d                   	pop    %ebp
  80ab77:	c3                   	ret    

0080ab78 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80ab78:	55                   	push   %ebp
  80ab79:	89 e5                	mov    %esp,%ebp
  80ab7b:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80ab7e:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80ab85:	ff 
  80ab86:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ab89:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ab8d:	8b 45 08             	mov    0x8(%ebp),%eax
  80ab90:	89 04 24             	mov    %eax,(%esp)
  80ab93:	e8 d5 fe ff ff       	call   80aa6d <sys_arch_mbox_fetch>
}
  80ab98:	c9                   	leave  
  80ab99:	c3                   	ret    

0080ab9a <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80ab9a:	55                   	push   %ebp
  80ab9b:	89 e5                	mov    %esp,%ebp
  80ab9d:	53                   	push   %ebx
  80ab9e:	83 ec 24             	sub    $0x24,%esp
  80aba1:	8b 5d 14             	mov    0x14(%ebp),%ebx
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80aba4:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80abab:	e8 80 63 00 00       	call   810f30 <malloc>
    if (lt == 0)
  80abb0:	85 c0                	test   %eax,%eax
  80abb2:	75 1c                	jne    80abd0 <sys_thread_new+0x36>
	panic("sys_thread_new: cannot allocate thread struct");
  80abb4:	c7 44 24 08 90 30 81 	movl   $0x813090,0x8(%esp)
  80abbb:	00 
  80abbc:	c7 44 24 04 fd 00 00 	movl   $0xfd,0x4(%esp)
  80abc3:	00 
  80abc4:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80abcb:	e8 b0 42 00 00       	call   80ee80 <_panic>

    if (stacksize > PGSIZE)
  80abd0:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  80abd6:	7e 20                	jle    80abf8 <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80abd8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80abdc:	c7 44 24 08 8a 31 81 	movl   $0x81318a,0x8(%esp)
  80abe3:	00 
  80abe4:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  80abeb:	00 
  80abec:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80abf3:	e8 88 42 00 00       	call   80ee80 <_panic>

    lt->func = thread;
  80abf8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80abfb:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80abfd:	8b 55 10             	mov    0x10(%ebp),%edx
  80ac00:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80ac03:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ac07:	c7 44 24 08 e5 a3 80 	movl   $0x80a3e5,0x8(%esp)
  80ac0e:	00 
  80ac0f:	8b 45 08             	mov    0x8(%ebp),%eax
  80ac12:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ac16:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ac19:	89 04 24             	mov    %eax,(%esp)
  80ac1c:	e8 d0 01 00 00       	call   80adf1 <thread_create>

    if (r < 0)
  80ac21:	85 c0                	test   %eax,%eax
  80ac23:	79 28                	jns    80ac4d <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80ac25:	89 04 24             	mov    %eax,(%esp)
  80ac28:	e8 fb 04 00 00       	call   80b128 <e2s>
  80ac2d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ac31:	c7 44 24 08 c0 30 81 	movl   $0x8130c0,0x8(%esp)
  80ac38:	00 
  80ac39:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
  80ac40:	00 
  80ac41:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80ac48:	e8 33 42 00 00       	call   80ee80 <_panic>

    return tid;
}
  80ac4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ac50:	83 c4 24             	add    $0x24,%esp
  80ac53:	5b                   	pop    %ebx
  80ac54:	5d                   	pop    %ebp
  80ac55:	c3                   	ret    

0080ac56 <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80ac56:	55                   	push   %ebp
  80ac57:	89 e5                	mov    %esp,%ebp
  80ac59:	57                   	push   %edi
  80ac5a:	56                   	push   %esi
  80ac5b:	53                   	push   %ebx
  80ac5c:	83 ec 2c             	sub    $0x2c,%esp
    thread_id_t tid = thread_id();
  80ac5f:	e8 17 01 00 00       	call   80ad7b <thread_id>
  80ac64:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80ac66:	b9 01 01 00 00       	mov    $0x101,%ecx
  80ac6b:	ba 00 00 00 00       	mov    $0x0,%edx
  80ac70:	f7 f1                	div    %ecx
  80ac72:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
  80ac79:	8d 87 c0 bd b3 00    	lea    0xb3bdc0(%edi),%eax
  80ac7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ac82:	8b 9f c0 bd b3 00    	mov    0xb3bdc0(%edi),%ebx
  80ac88:	eb 0b                	jmp    80ac95 <sys_arch_timeouts+0x3f>
	if (t->tid == tid)
  80ac8a:	39 33                	cmp    %esi,(%ebx)
  80ac8c:	0f 84 af 00 00 00    	je     80ad41 <sys_arch_timeouts+0xeb>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80ac92:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80ac95:	85 db                	test   %ebx,%ebx
  80ac97:	75 f1                	jne    80ac8a <sys_arch_timeouts+0x34>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80ac99:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80aca0:	e8 8b 62 00 00       	call   810f30 <malloc>
  80aca5:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80aca7:	85 c0                	test   %eax,%eax
  80aca9:	75 1c                	jne    80acc7 <sys_arch_timeouts+0x71>
	panic("sys_arch_timeouts: cannot malloc");
  80acab:	c7 44 24 08 ec 30 81 	movl   $0x8130ec,0x8(%esp)
  80acb2:	00 
  80acb3:	c7 44 24 04 2c 01 00 	movl   $0x12c,0x4(%esp)
  80acba:	00 
  80acbb:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80acc2:	e8 b9 41 00 00       	call   80ee80 <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80acc7:	c7 04 24 94 a3 80 00 	movl   $0x80a394,(%esp)
  80acce:	e8 f5 00 00 00       	call   80adc8 <thread_onhalt>
    if (r < 0)
  80acd3:	85 c0                	test   %eax,%eax
  80acd5:	79 28                	jns    80acff <sys_arch_timeouts+0xa9>
	panic("thread_onhalt failed: %s", e2s(r));
  80acd7:	89 04 24             	mov    %eax,(%esp)
  80acda:	e8 49 04 00 00       	call   80b128 <e2s>
  80acdf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ace3:	c7 44 24 08 99 31 81 	movl   $0x813199,0x8(%esp)
  80acea:	00 
  80aceb:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80acf2:	00 
  80acf3:	c7 04 24 2c 31 81 00 	movl   $0x81312c,(%esp)
  80acfa:	e8 81 41 00 00       	call   80ee80 <_panic>

    t->tid = tid;
  80acff:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80ad01:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ad08:	00 
  80ad09:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ad10:	00 
  80ad11:	8d 43 04             	lea    0x4(%ebx),%eax
  80ad14:	89 04 24             	mov    %eax,(%esp)
  80ad17:	e8 36 49 00 00       	call   80f652 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80ad1c:	8b 87 c0 bd b3 00    	mov    0xb3bdc0(%edi),%eax
  80ad22:	89 43 08             	mov    %eax,0x8(%ebx)
  80ad25:	85 c0                	test   %eax,%eax
  80ad27:	74 0c                	je     80ad35 <sys_arch_timeouts+0xdf>
  80ad29:	8b 87 c0 bd b3 00    	mov    0xb3bdc0(%edi),%eax
  80ad2f:	8d 53 08             	lea    0x8(%ebx),%edx
  80ad32:	89 50 0c             	mov    %edx,0xc(%eax)
  80ad35:	89 9f c0 bd b3 00    	mov    %ebx,0xb3bdc0(%edi)
  80ad3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ad3e:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80ad41:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80ad44:	83 c4 2c             	add    $0x2c,%esp
  80ad47:	5b                   	pop    %ebx
  80ad48:	5e                   	pop    %esi
  80ad49:	5f                   	pop    %edi
  80ad4a:	5d                   	pop    %ebp
  80ad4b:	c3                   	ret    

0080ad4c <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80ad4c:	55                   	push   %ebp
  80ad4d:	89 e5                	mov    %esp,%ebp
}
  80ad4f:	5d                   	pop    %ebp
  80ad50:	c3                   	ret    

0080ad51 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80ad51:	55                   	push   %ebp
  80ad52:	89 e5                	mov    %esp,%ebp
}
  80ad54:	5d                   	pop    %ebp
  80ad55:	c3                   	ret    
	...

0080ad58 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80ad58:	55                   	push   %ebp
  80ad59:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80ad5b:	c7 05 c4 c1 b3 00 00 	movl   $0x0,0xb3c1c4
  80ad62:	00 00 00 
    tq->tq_last = 0;
  80ad65:	c7 05 c8 c1 b3 00 00 	movl   $0x0,0xb3c1c8
  80ad6c:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80ad6f:	c7 05 cc c1 b3 00 00 	movl   $0x0,0xb3c1cc
  80ad76:	00 00 00 
}
  80ad79:	5d                   	pop    %ebp
  80ad7a:	c3                   	ret    

0080ad7b <thread_id>:

uint32_t
thread_id(void) {
  80ad7b:	55                   	push   %ebp
  80ad7c:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80ad7e:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80ad83:	8b 00                	mov    (%eax),%eax
}
  80ad85:	5d                   	pop    %ebp
  80ad86:	c3                   	ret    

0080ad87 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80ad87:	55                   	push   %ebp
  80ad88:	89 e5                	mov    %esp,%ebp
  80ad8a:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80ad8d:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
    while (tc) {
  80ad92:	eb 0c                	jmp    80ada0 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80ad94:	39 50 48             	cmp    %edx,0x48(%eax)
  80ad97:	75 04                	jne    80ad9d <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80ad99:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80ad9d:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80ada0:	85 c0                	test   %eax,%eax
  80ada2:	75 f0                	jne    80ad94 <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80ada4:	5d                   	pop    %ebp
  80ada5:	c3                   	ret    

0080ada6 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80ada6:	55                   	push   %ebp
  80ada7:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80ada9:	8b 15 c4 c1 b3 00    	mov    0xb3c1c4,%edx
    int n = 0;
  80adaf:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80adb4:	eb 0c                	jmp    80adc2 <thread_wakeups_pending+0x1c>
	if (tc->tc_wakeup)
  80adb6:	8a 4a 4c             	mov    0x4c(%edx),%cl
	    ++n;
  80adb9:	80 f9 01             	cmp    $0x1,%cl
  80adbc:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80adbf:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80adc2:	85 d2                	test   %edx,%edx
  80adc4:	75 f0                	jne    80adb6 <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80adc6:	5d                   	pop    %ebp
  80adc7:	c3                   	ret    

0080adc8 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80adc8:	55                   	push   %ebp
  80adc9:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80adcb:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80add0:	8b 50 60             	mov    0x60(%eax),%edx
  80add3:	83 fa 03             	cmp    $0x3,%edx
  80add6:	7f 12                	jg     80adea <thread_onhalt+0x22>
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80add8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80addb:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
  80addf:	42                   	inc    %edx
  80ade0:	89 50 60             	mov    %edx,0x60(%eax)
    return 0;
  80ade3:	b8 00 00 00 00       	mov    $0x0,%eax
  80ade8:	eb 05                	jmp    80adef <thread_onhalt+0x27>
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80adea:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
    return 0;
}
  80adef:	5d                   	pop    %ebp
  80adf0:	c3                   	ret    

0080adf1 <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80adf1:	55                   	push   %ebp
  80adf2:	89 e5                	mov    %esp,%ebp
  80adf4:	57                   	push   %edi
  80adf5:	56                   	push   %esi
  80adf6:	53                   	push   %ebx
  80adf7:	83 ec 1c             	sub    $0x1c,%esp
  80adfa:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80adfd:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80ae04:	e8 27 61 00 00       	call   810f30 <malloc>
  80ae09:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80ae0b:	85 c0                	test   %eax,%eax
  80ae0d:	0f 84 16 01 00 00    	je     80af29 <thread_create+0x138>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80ae13:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80ae1a:	00 
  80ae1b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ae22:	00 
  80ae23:	89 04 24             	mov    %eax,(%esp)
  80ae26:	e8 27 48 00 00       	call   80f652 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80ae2b:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80ae32:	00 
  80ae33:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ae36:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ae3a:	8d 43 08             	lea    0x8(%ebx),%eax
  80ae3d:	89 04 24             	mov    %eax,(%esp)
  80ae40:	e8 26 47 00 00       	call   80f56b <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80ae45:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80ae49:	8b 15 cc c1 b3 00    	mov    0xb3c1cc,%edx
  80ae4f:	8d 42 01             	lea    0x1(%edx),%eax
  80ae52:	a3 cc c1 b3 00       	mov    %eax,0xb3c1cc
    if (max_tid == (uint32_t)~0)
  80ae57:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae5a:	75 1c                	jne    80ae78 <thread_create+0x87>
	panic("alloc_tid: no more thread ids");
  80ae5c:	c7 44 24 08 b2 31 81 	movl   $0x8131b2,0x8(%esp)
  80ae63:	00 
  80ae64:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80ae6b:	00 
  80ae6c:	c7 04 24 d0 31 81 00 	movl   $0x8131d0,(%esp)
  80ae73:	e8 08 40 00 00       	call   80ee80 <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80ae78:	89 13                	mov    %edx,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80ae7a:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80ae81:	e8 aa 60 00 00       	call   810f30 <malloc>
  80ae86:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80ae89:	85 c0                	test   %eax,%eax
  80ae8b:	75 12                	jne    80ae9f <thread_create+0xae>
	free(tc);
  80ae8d:	89 1c 24             	mov    %ebx,(%esp)
  80ae90:	e8 cb 5f 00 00       	call   810e60 <free>
	return -E_NO_MEM;
  80ae95:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80ae9a:	e9 96 00 00 00       	jmp    80af35 <thread_create+0x144>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80ae9f:	8d b0 fc 0f 00 00    	lea    0xffc(%eax),%esi
    memset(stacktop, 0, 4);
  80aea5:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80aeac:	00 
  80aead:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80aeb4:	00 
  80aeb5:	89 34 24             	mov    %esi,(%esp)
  80aeb8:	e8 95 47 00 00       	call   80f652 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80aebd:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80aec4:	00 
  80aec5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80aecc:	00 
  80aecd:	8d 43 30             	lea    0x30(%ebx),%eax
  80aed0:	89 04 24             	mov    %eax,(%esp)
  80aed3:	e8 7a 47 00 00       	call   80f652 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80aed8:	89 73 34             	mov    %esi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80aedb:	c7 43 30 51 b0 80 00 	movl   $0x80b051,0x30(%ebx)
    tc->tc_entry = entry;
  80aee2:	8b 45 10             	mov    0x10(%ebp),%eax
  80aee5:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80aee8:	8b 45 14             	mov    0x14(%ebp),%eax
  80aeeb:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80aeee:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80aef5:	83 3d c4 c1 b3 00 00 	cmpl   $0x0,0xb3c1c4
  80aefc:	75 0e                	jne    80af0c <thread_create+0x11b>
	tq->tq_first = tc;
  80aefe:	89 1d c4 c1 b3 00    	mov    %ebx,0xb3c1c4
	tq->tq_last = tc;
  80af04:	89 1d c8 c1 b3 00    	mov    %ebx,0xb3c1c8
  80af0a:	eb 0e                	jmp    80af1a <thread_create+0x129>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80af0c:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80af11:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80af14:	89 1d c8 c1 b3 00    	mov    %ebx,0xb3c1c8

    threadq_push(&thread_queue, tc);

    if (tid)
  80af1a:	85 ff                	test   %edi,%edi
  80af1c:	74 12                	je     80af30 <thread_create+0x13f>
	*tid = tc->tc_tid;
  80af1e:	8b 03                	mov    (%ebx),%eax
  80af20:	89 07                	mov    %eax,(%edi)
    return 0;
  80af22:	b8 00 00 00 00       	mov    $0x0,%eax
  80af27:	eb 0c                	jmp    80af35 <thread_create+0x144>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80af29:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80af2e:	eb 05                	jmp    80af35 <thread_create+0x144>

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80af30:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80af35:	83 c4 1c             	add    $0x1c,%esp
  80af38:	5b                   	pop    %ebx
  80af39:	5e                   	pop    %esi
  80af3a:	5f                   	pop    %edi
  80af3b:	5d                   	pop    %ebp
  80af3c:	c3                   	ret    

0080af3d <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80af3d:	55                   	push   %ebp
  80af3e:	89 e5                	mov    %esp,%ebp
  80af40:	53                   	push   %ebx
  80af41:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80af44:	8b 1d c4 c1 b3 00    	mov    0xb3c1c4,%ebx
  80af4a:	85 db                	test   %ebx,%ebx
  80af4c:	74 69                	je     80afb7 <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80af4e:	8b 43 64             	mov    0x64(%ebx),%eax
  80af51:	a3 c4 c1 b3 00       	mov    %eax,0xb3c1c4
    tc->tc_queue_link = 0;
  80af56:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80af5d:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80af62:	85 c0                	test   %eax,%eax
  80af64:	74 3e                	je     80afa4 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80af66:	83 c0 30             	add    $0x30,%eax
  80af69:	89 04 24             	mov    %eax,(%esp)
  80af6c:	e8 6f 01 00 00       	call   80b0e0 <jos_setjmp>
  80af71:	85 c0                	test   %eax,%eax
  80af73:	75 42                	jne    80afb7 <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80af75:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80af7a:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80af81:	83 3d c4 c1 b3 00 00 	cmpl   $0x0,0xb3c1c4
  80af88:	75 0c                	jne    80af96 <thread_yield+0x59>
	tq->tq_first = tc;
  80af8a:	a3 c4 c1 b3 00       	mov    %eax,0xb3c1c4
	tq->tq_last = tc;
  80af8f:	a3 c8 c1 b3 00       	mov    %eax,0xb3c1c8
  80af94:	eb 0e                	jmp    80afa4 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80af96:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80af9c:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80af9f:	a3 c8 c1 b3 00       	mov    %eax,0xb3c1c8
    }

    cur_tc = next_tc;
  80afa4:	89 1d d0 c1 b3 00    	mov    %ebx,0xb3c1d0
    jos_longjmp(&cur_tc->tc_jb, 1);
  80afaa:	8d 43 30             	lea    0x30(%ebx),%eax
  80afad:	ba 01 00 00 00       	mov    $0x1,%edx
  80afb2:	e8 59 01 00 00       	call   80b110 <jos_longjmp>
}
  80afb7:	83 c4 14             	add    $0x14,%esp
  80afba:	5b                   	pop    %ebx
  80afbb:	5d                   	pop    %ebp
  80afbc:	c3                   	ret    

0080afbd <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80afbd:	55                   	push   %ebp
  80afbe:	89 e5                	mov    %esp,%ebp
  80afc0:	56                   	push   %esi
  80afc1:	53                   	push   %ebx
  80afc2:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80afc5:	8b 1d d4 c1 b3 00    	mov    0xb3c1d4,%ebx
  80afcb:	85 db                	test   %ebx,%ebx
  80afcd:	74 38                	je     80b007 <thread_halt+0x4a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80afcf:	8b 43 64             	mov    0x64(%ebx),%eax
  80afd2:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
    tc->tc_queue_link = 0;
  80afd7:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80afde:	be 00 00 00 00       	mov    $0x0,%esi
  80afe3:	eb 0a                	jmp    80afef <thread_halt+0x32>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80afe5:	8b 03                	mov    (%ebx),%eax
  80afe7:	89 04 24             	mov    %eax,(%esp)
  80afea:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80afee:	46                   	inc    %esi
  80afef:	3b 73 60             	cmp    0x60(%ebx),%esi
  80aff2:	7c f1                	jl     80afe5 <thread_halt+0x28>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80aff4:	8b 43 04             	mov    0x4(%ebx),%eax
  80aff7:	89 04 24             	mov    %eax,(%esp)
  80affa:	e8 61 5e 00 00       	call   810e60 <free>
    free(tc);
  80afff:	89 1c 24             	mov    %ebx,(%esp)
  80b002:	e8 59 5e 00 00       	call   810e60 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80b007:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b00c:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80b013:	83 3d d4 c1 b3 00 00 	cmpl   $0x0,0xb3c1d4
  80b01a:	75 0c                	jne    80b028 <thread_halt+0x6b>
	tq->tq_first = tc;
  80b01c:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
	tq->tq_last = tc;
  80b021:	a3 d8 c1 b3 00       	mov    %eax,0xb3c1d8
  80b026:	eb 0e                	jmp    80b036 <thread_halt+0x79>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b028:	8b 15 d8 c1 b3 00    	mov    0xb3c1d8,%edx
  80b02e:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80b031:	a3 d8 c1 b3 00       	mov    %eax,0xb3c1d8
    cur_tc = NULL;
  80b036:	c7 05 d0 c1 b3 00 00 	movl   $0x0,0xb3c1d0
  80b03d:	00 00 00 
    thread_yield();
  80b040:	e8 f8 fe ff ff       	call   80af3d <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80b045:	e8 1a 3e 00 00       	call   80ee64 <exit>
}
  80b04a:	83 c4 10             	add    $0x10,%esp
  80b04d:	5b                   	pop    %ebx
  80b04e:	5e                   	pop    %esi
  80b04f:	5d                   	pop    %ebp
  80b050:	c3                   	ret    

0080b051 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80b051:	55                   	push   %ebp
  80b052:	89 e5                	mov    %esp,%ebp
  80b054:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80b057:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80b05c:	8b 50 2c             	mov    0x2c(%eax),%edx
  80b05f:	89 14 24             	mov    %edx,(%esp)
  80b062:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80b065:	e8 53 ff ff ff       	call   80afbd <thread_halt>
}
  80b06a:	c9                   	leave  
  80b06b:	c3                   	ret    

0080b06c <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80b06c:	55                   	push   %ebp
  80b06d:	89 e5                	mov    %esp,%ebp
  80b06f:	57                   	push   %edi
  80b070:	56                   	push   %esi
  80b071:	53                   	push   %ebx
  80b072:	83 ec 0c             	sub    $0xc,%esp
  80b075:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b078:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80b07b:	e8 fd 4a 00 00       	call   80fb7d <sys_time_msec>
  80b080:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80b082:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80b087:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b08a:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
    uint32_t s = sys_time_msec();
    uint32_t p = s;
  80b08e:	89 f0                	mov    %esi,%eax

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b090:	eb 25                	jmp    80b0b7 <thread_wait+0x4b>
	if (p < s)
  80b092:	39 f0                	cmp    %esi,%eax
  80b094:	72 25                	jb     80b0bb <thread_wait+0x4f>
	    break;
	if (addr && *addr != val)
  80b096:	85 db                	test   %ebx,%ebx
  80b098:	74 07                	je     80b0a1 <thread_wait+0x35>
  80b09a:	8b 03                	mov    (%ebx),%eax
  80b09c:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80b09f:	75 1a                	jne    80b0bb <thread_wait+0x4f>
	    break;
	if (cur_tc->tc_wakeup)
  80b0a1:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80b0a6:	8a 40 4c             	mov    0x4c(%eax),%al
  80b0a9:	84 c0                	test   %al,%al
  80b0ab:	75 0e                	jne    80b0bb <thread_wait+0x4f>
	    break;

	thread_yield();
  80b0ad:	e8 8b fe ff ff       	call   80af3d <thread_yield>
	p = sys_time_msec();
  80b0b2:	e8 c6 4a 00 00       	call   80fb7d <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b0b7:	39 f8                	cmp    %edi,%eax
  80b0b9:	72 d7                	jb     80b092 <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80b0bb:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80b0c0:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b0c7:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80b0cb:	83 c4 0c             	add    $0xc,%esp
  80b0ce:	5b                   	pop    %ebx
  80b0cf:	5e                   	pop    %esi
  80b0d0:	5f                   	pop    %edi
  80b0d1:	5d                   	pop    %ebp
  80b0d2:	c3                   	ret    
	...

0080b0e0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80b0e0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80b0e4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80b0e7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80b0e9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80b0ed:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80b0f0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80b0f3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80b0f6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80b0f9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80b0fc:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80b101:	c3                   	ret    
  80b102:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80b109:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080b110 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80b110:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80b112:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80b115:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80b118:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80b11b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80b11e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80b121:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80b123:	ff e1                	jmp    *%ecx
  80b125:	00 00                	add    %al,(%eax)
	...

0080b128 <e2s>:
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
  80b128:	55                   	push   %ebp
  80b129:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80b12b:	8b 45 08             	mov    0x8(%ebp),%eax
  80b12e:	8b 04 85 20 50 81 00 	mov    0x815020(,%eax,4),%eax
}
  80b135:	5d                   	pop    %ebp
  80b136:	c3                   	ret    

0080b137 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80b137:	55                   	push   %ebp
  80b138:	89 e5                	mov    %esp,%ebp
  80b13a:	83 ec 18             	sub    $0x18,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80b13d:	a1 20 c2 b3 00       	mov    0xb3c220,%eax
  80b142:	89 04 24             	mov    %eax,(%esp)
  80b145:	e8 de ff ff ff       	call   80b128 <e2s>
  80b14a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b14e:	8b 45 08             	mov    0x8(%ebp),%eax
  80b151:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b155:	c7 04 24 eb 31 81 00 	movl   $0x8131eb,(%esp)
  80b15c:	e8 17 3e 00 00       	call   80ef78 <cprintf>
}
  80b161:	c9                   	leave  
  80b162:	c3                   	ret    
	...

0080b164 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80b164:	55                   	push   %ebp
  80b165:	89 e5                	mov    %esp,%ebp
  80b167:	57                   	push   %edi
  80b168:	56                   	push   %esi
  80b169:	53                   	push   %ebx
  80b16a:	83 ec 2c             	sub    $0x2c,%esp
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80b16d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80b174:	00 
  80b175:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b17c:	10 
  80b17d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b184:	e8 8c 47 00 00       	call   80f915 <sys_page_alloc>
    if (r < 0)
  80b189:	85 c0                	test   %eax,%eax
  80b18b:	79 1c                	jns    80b1a9 <low_level_output+0x45>
	panic("jif: could not allocate page of memory");
  80b18d:	c7 44 24 08 d0 36 81 	movl   $0x8136d0,0x8(%esp)
  80b194:	00 
  80b195:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80b19c:	00 
  80b19d:	c7 04 24 21 37 81 00 	movl   $0x813721,(%esp)
  80b1a4:	e8 d7 3c 00 00       	call   80ee80 <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80b1a9:	8b 45 08             	mov    0x8(%ebp),%eax
  80b1ac:	8b 78 1c             	mov    0x1c(%eax),%edi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b1af:	8b 5d 0c             	mov    0xc(%ebp),%ebx

    struct jif *jif;
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
  80b1b2:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b1b7:	eb 5a                	jmp    80b213 <low_level_output+0xaf>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80b1b9:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  80b1bd:	0f b7 d0             	movzwl %ax,%edx
  80b1c0:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80b1c3:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80b1c9:	7e 24                	jle    80b1ef <low_level_output+0x8b>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80b1cb:	89 74 24 10          	mov    %esi,0x10(%esp)
  80b1cf:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80b1d3:	c7 44 24 08 f8 36 81 	movl   $0x8136f8,0x8(%esp)
  80b1da:	00 
  80b1db:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  80b1e2:	00 
  80b1e3:	c7 04 24 21 37 81 00 	movl   $0x813721,(%esp)
  80b1ea:	e8 91 3c 00 00       	call   80ee80 <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80b1ef:	0f b7 c0             	movzwl %ax,%eax
  80b1f2:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b1f6:	8b 43 04             	mov    0x4(%ebx),%eax
  80b1f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b1fd:	8d 86 04 00 00 10    	lea    0x10000004(%esi),%eax
  80b203:	89 04 24             	mov    %eax,(%esp)
  80b206:	e8 fb 44 00 00       	call   80f706 <memcpy>
	txsize += q->len;
  80b20b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b20f:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b211:	8b 1b                	mov    (%ebx),%ebx
  80b213:	85 db                	test   %ebx,%ebx
  80b215:	75 a2                	jne    80b1b9 <low_level_output+0x55>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80b217:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80b21d:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80b224:	00 
  80b225:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80b22c:	10 
  80b22d:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80b234:	00 
  80b235:	8b 47 04             	mov    0x4(%edi),%eax
  80b238:	89 04 24             	mov    %eax,(%esp)
  80b23b:	e8 cc 4d 00 00       	call   81000c <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80b240:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b247:	10 
  80b248:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b24f:	e8 68 47 00 00       	call   80f9bc <sys_page_unmap>

    return ERR_OK;
}
  80b254:	b0 00                	mov    $0x0,%al
  80b256:	83 c4 2c             	add    $0x2c,%esp
  80b259:	5b                   	pop    %ebx
  80b25a:	5e                   	pop    %esi
  80b25b:	5f                   	pop    %edi
  80b25c:	5d                   	pop    %ebp
  80b25d:	c3                   	ret    

0080b25e <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80b25e:	55                   	push   %ebp
  80b25f:	89 e5                	mov    %esp,%ebp
  80b261:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80b264:	8b 45 10             	mov    0x10(%ebp),%eax
  80b267:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b26b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b26e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b272:	8b 45 08             	mov    0x8(%ebp),%eax
  80b275:	89 04 24             	mov    %eax,(%esp)
  80b278:	e8 89 ef ff ff       	call   80a206 <etharp_output>
}
  80b27d:	c9                   	leave  
  80b27e:	c3                   	ret    

0080b27f <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80b27f:	55                   	push   %ebp
  80b280:	89 e5                	mov    %esp,%ebp
  80b282:	57                   	push   %edi
  80b283:	56                   	push   %esi
  80b284:	53                   	push   %ebx
  80b285:	83 ec 2c             	sub    $0x2c,%esp
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80b288:	8b 45 08             	mov    0x8(%ebp),%eax
  80b28b:	8b 40 1c             	mov    0x1c(%eax),%eax
  80b28e:	89 45 dc             	mov    %eax,-0x24(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80b291:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b294:	8b 32                	mov    (%edx),%esi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80b296:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80b29d:	00 
  80b29e:	0f b7 c6             	movzwl %si,%eax
  80b2a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b2a5:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80b2ac:	e8 a1 9c ff ff       	call   804f52 <pbuf_alloc>
  80b2b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (p == 0)
  80b2b4:	85 c0                	test   %eax,%eax
  80b2b6:	0f 84 c3 00 00 00    	je     80b37f <jif_input+0x100>
  80b2bc:	89 c3                	mov    %eax,%ebx
  80b2be:	bf 00 00 00 00       	mov    $0x0,%edi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  80b2c3:	0f bf f6             	movswl %si,%esi
  80b2c6:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80b2c9:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
	if (bytes > (len - copied))
  80b2cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b2d0:	29 f8                	sub    %edi,%eax
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80b2d2:	89 c6                	mov    %eax,%esi
  80b2d4:	39 d0                	cmp    %edx,%eax
  80b2d6:	7e 02                	jle    80b2da <jif_input+0x5b>
  80b2d8:	89 d6                	mov    %edx,%esi
	if (bytes > (len - copied))
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80b2da:	89 74 24 08          	mov    %esi,0x8(%esp)
  80b2de:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b2e1:	8d 44 3a 04          	lea    0x4(%edx,%edi,1),%eax
  80b2e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b2e9:	8b 43 04             	mov    0x4(%ebx),%eax
  80b2ec:	89 04 24             	mov    %eax,(%esp)
  80b2ef:	e8 12 44 00 00       	call   80f706 <memcpy>
	copied += bytes;
  80b2f4:	01 f7                	add    %esi,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b2f6:	8b 1b                	mov    (%ebx),%ebx
  80b2f8:	85 db                	test   %ebx,%ebx
  80b2fa:	75 cd                	jne    80b2c9 <jif_input+0x4a>
  80b2fc:	eb 61                	jmp    80b35f <jif_input+0xe0>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80b2fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b301:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b305:	8b 55 08             	mov    0x8(%ebp),%edx
  80b308:	89 14 24             	mov    %edx,(%esp)
  80b30b:	e8 37 e9 ff ff       	call   809c47 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80b310:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80b317:	ff 
  80b318:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b31b:	89 04 24             	mov    %eax,(%esp)
  80b31e:	e8 49 99 ff ff       	call   804c6c <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80b323:	8b 55 08             	mov    0x8(%ebp),%edx
  80b326:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b32a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b32d:	89 04 24             	mov    %eax,(%esp)
  80b330:	ff 52 10             	call   *0x10(%edx)
	break;
  80b333:	eb 4a                	jmp    80b37f <jif_input+0x100>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80b335:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b338:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b33c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b33f:	8b 02                	mov    (%edx),%eax
  80b341:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b345:	8b 45 08             	mov    0x8(%ebp),%eax
  80b348:	89 04 24             	mov    %eax,(%esp)
  80b34b:	e8 45 e9 ff ff       	call   809c95 <etharp_arp_input>
	break;
  80b350:	eb 2d                	jmp    80b37f <jif_input+0x100>

    default:
	pbuf_free(p);
  80b352:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b355:	89 04 24             	mov    %eax,(%esp)
  80b358:	e8 f4 99 ff ff       	call   804d51 <pbuf_free>
  80b35d:	eb 20                	jmp    80b37f <jif_input+0x100>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80b35f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b362:	8b 42 04             	mov    0x4(%edx),%eax
  80b365:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b369:	89 04 24             	mov    %eax,(%esp)
  80b36c:	e8 e8 c8 ff ff       	call   807c59 <htons>
  80b371:	66 3d 00 08          	cmp    $0x800,%ax
  80b375:	74 87                	je     80b2fe <jif_input+0x7f>
  80b377:	66 3d 06 08          	cmp    $0x806,%ax
  80b37b:	75 d5                	jne    80b352 <jif_input+0xd3>
  80b37d:	eb b6                	jmp    80b335 <jif_input+0xb6>
	break;

    default:
	pbuf_free(p);
    }
}
  80b37f:	83 c4 2c             	add    $0x2c,%esp
  80b382:	5b                   	pop    %ebx
  80b383:	5e                   	pop    %esi
  80b384:	5f                   	pop    %edi
  80b385:	5d                   	pop    %ebp
  80b386:	c3                   	ret    

0080b387 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80b387:	55                   	push   %ebp
  80b388:	89 e5                	mov    %esp,%ebp
  80b38a:	57                   	push   %edi
  80b38b:	56                   	push   %esi
  80b38c:	53                   	push   %ebx
  80b38d:	83 ec 2c             	sub    $0x2c,%esp
  80b390:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80b393:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80b39a:	e8 79 93 ff ff       	call   804718 <mem_malloc>
  80b39f:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80b3a1:	85 c0                	test   %eax,%eax
  80b3a3:	0f 84 89 00 00 00    	je     80b432 <jif_init+0xab>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80b3a9:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80b3ac:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80b3af:	c7 43 14 5e b2 80 00 	movl   $0x80b25e,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80b3b6:	c7 43 18 64 b1 80 00 	movl   $0x80b164,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80b3bd:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80b3c4:	00 
  80b3c5:	c7 44 24 04 f8 43 81 	movl   $0x8143f8,0x4(%esp)
  80b3cc:	00 
  80b3cd:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80b3d0:	89 04 24             	mov    %eax,(%esp)
  80b3d3:	e8 2e 43 00 00       	call   80f706 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80b3d8:	8d 43 25             	lea    0x25(%ebx),%eax
  80b3db:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80b3dd:	8b 07                	mov    (%edi),%eax
  80b3df:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80b3e2:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80b3e6:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80b3ec:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80b3f0:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80b3f4:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80b3f8:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80b3fc:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80b400:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80b404:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80b408:	c7 04 24 ab 1a 81 00 	movl   $0x811aab,(%esp)
  80b40f:	e8 93 ca ff ff       	call   807ea7 <inet_addr>
  80b414:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80b417:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b41e:	00 
  80b41f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b422:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b426:	89 1c 24             	mov    %ebx,(%esp)
  80b429:	e8 7d eb ff ff       	call   809fab <etharp_query>

    return ERR_OK;
  80b42e:	b0 00                	mov    $0x0,%al
  80b430:	eb 02                	jmp    80b434 <jif_init+0xad>

    jif = mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80b432:	b0 ff                	mov    $0xff,%al
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);

    return ERR_OK;
}
  80b434:	83 c4 2c             	add    $0x2c,%esp
  80b437:	5b                   	pop    %ebx
  80b438:	5e                   	pop    %esi
  80b439:	5f                   	pop    %edi
  80b43a:	5d                   	pop    %ebp
  80b43b:	c3                   	ret    

0080b43c <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80b43c:	55                   	push   %ebp
  80b43d:	89 e5                	mov    %esp,%ebp
  80b43f:	53                   	push   %ebx
  80b440:	83 ec 44             	sub    $0x44,%esp
  80b443:	8a 45 0c             	mov    0xc(%ebp),%al
  80b446:	88 45 d7             	mov    %al,-0x29(%ebp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80b449:	8b 45 10             	mov    0x10(%ebp),%eax
  80b44c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b450:	8b 45 08             	mov    0x8(%ebp),%eax
  80b453:	89 04 24             	mov    %eax,(%esp)
  80b456:	e8 05 10 00 00       	call   80c460 <netconn_alloc>
  80b45b:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80b45d:	85 c0                	test   %eax,%eax
  80b45f:	0f 84 d7 00 00 00    	je     80b53c <netconn_new_with_proto_and_callback+0x100>
    msg.function = do_newconn;
  80b465:	c7 45 e4 61 c3 80 00 	movl   $0x80c361,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80b46c:	8a 45 d7             	mov    -0x29(%ebp),%al
  80b46f:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80b472:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80b475:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b478:	89 04 24             	mov    %eax,(%esp)
  80b47b:	e8 46 72 ff ff       	call   8026c6 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80b480:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b484:	0f 84 b2 00 00 00    	je     80b53c <netconn_new_with_proto_and_callback+0x100>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80b48a:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b48e:	74 1c                	je     80b4ac <netconn_new_with_proto_and_callback+0x70>
  80b490:	c7 44 24 08 38 37 81 	movl   $0x813738,0x8(%esp)
  80b497:	00 
  80b498:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80b49f:	00 
  80b4a0:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b4a7:	e8 d4 39 00 00       	call   80ee80 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80b4ac:	8b 43 10             	mov    0x10(%ebx),%eax
  80b4af:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b4b2:	75 1c                	jne    80b4d0 <netconn_new_with_proto_and_callback+0x94>
  80b4b4:	c7 44 24 08 01 38 81 	movl   $0x813801,0x8(%esp)
  80b4bb:	00 
  80b4bc:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80b4c3:	00 
  80b4c4:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b4cb:	e8 b0 39 00 00       	call   80ee80 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80b4d0:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b4d4:	75 1c                	jne    80b4f2 <netconn_new_with_proto_and_callback+0xb6>
  80b4d6:	c7 44 24 08 1a 38 81 	movl   $0x81381a,0x8(%esp)
  80b4dd:	00 
  80b4de:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80b4e5:	00 
  80b4e6:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b4ed:	e8 8e 39 00 00       	call   80ee80 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80b4f2:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b4f6:	74 1c                	je     80b514 <netconn_new_with_proto_and_callback+0xd8>
  80b4f8:	c7 44 24 08 5c 37 81 	movl   $0x81375c,0x8(%esp)
  80b4ff:	00 
  80b500:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80b507:	00 
  80b508:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b50f:	e8 6c 39 00 00       	call   80ee80 <_panic>
      sys_sem_free(conn->op_completed);
  80b514:	89 04 24             	mov    %eax,(%esp)
  80b517:	e8 33 f0 ff ff       	call   80a54f <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80b51c:	8b 43 14             	mov    0x14(%ebx),%eax
  80b51f:	89 04 24             	mov    %eax,(%esp)
  80b522:	e8 9c f0 ff ff       	call   80a5c3 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80b527:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80b52b:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80b532:	e8 8f 94 ff ff       	call   8049c6 <memp_free>
      return NULL;
  80b537:	bb 00 00 00 00       	mov    $0x0,%ebx
    }
  }
  return conn;
}
  80b53c:	89 d8                	mov    %ebx,%eax
  80b53e:	83 c4 44             	add    $0x44,%esp
  80b541:	5b                   	pop    %ebx
  80b542:	5d                   	pop    %ebp
  80b543:	c3                   	ret    

0080b544 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80b544:	55                   	push   %ebp
  80b545:	89 e5                	mov    %esp,%ebp
  80b547:	53                   	push   %ebx
  80b548:	83 ec 34             	sub    $0x34,%esp
  80b54b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80b54e:	85 db                	test   %ebx,%ebx
  80b550:	74 24                	je     80b576 <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80b552:	c7 45 e4 ab c6 80 00 	movl   $0x80c6ab,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b559:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b55c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b55f:	89 04 24             	mov    %eax,(%esp)
  80b562:	e8 5f 71 ff ff       	call   8026c6 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80b567:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80b56e:	89 1c 24             	mov    %ebx,(%esp)
  80b571:	e8 a1 0f 00 00       	call   80c517 <netconn_free>

  return ERR_OK;
}
  80b576:	b0 00                	mov    $0x0,%al
  80b578:	83 c4 34             	add    $0x34,%esp
  80b57b:	5b                   	pop    %ebx
  80b57c:	5d                   	pop    %ebp
  80b57d:	c3                   	ret    

0080b57e <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80b57e:	55                   	push   %ebp
  80b57f:	89 e5                	mov    %esp,%ebp
  80b581:	83 ec 18             	sub    $0x18,%esp
  80b584:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80b587:	85 c0                	test   %eax,%eax
  80b589:	75 1c                	jne    80b5a7 <netconn_type+0x29>
  80b58b:	c7 44 24 08 2f 38 81 	movl   $0x81382f,0x8(%esp)
  80b592:	00 
  80b593:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80b59a:	00 
  80b59b:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b5a2:	e8 d9 38 00 00       	call   80ee80 <_panic>
  80b5a7:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80b5a9:	c9                   	leave  
  80b5aa:	c3                   	ret    

0080b5ab <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80b5ab:	55                   	push   %ebp
  80b5ac:	89 e5                	mov    %esp,%ebp
  80b5ae:	53                   	push   %ebx
  80b5af:	83 ec 34             	sub    $0x34,%esp
  80b5b2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b5b5:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b5b8:	8b 45 10             	mov    0x10(%ebp),%eax
  80b5bb:	8a 4d 14             	mov    0x14(%ebp),%cl
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80b5be:	85 db                	test   %ebx,%ebx
  80b5c0:	75 1c                	jne    80b5de <netconn_getaddr+0x33>
  80b5c2:	c7 44 24 08 4a 38 81 	movl   $0x81384a,0x8(%esp)
  80b5c9:	00 
  80b5ca:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80b5d1:	00 
  80b5d2:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b5d9:	e8 a2 38 00 00       	call   80ee80 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80b5de:	85 d2                	test   %edx,%edx
  80b5e0:	75 1c                	jne    80b5fe <netconn_getaddr+0x53>
  80b5e2:	c7 44 24 08 68 38 81 	movl   $0x813868,0x8(%esp)
  80b5e9:	00 
  80b5ea:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80b5f1:	00 
  80b5f2:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b5f9:	e8 82 38 00 00       	call   80ee80 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80b5fe:	85 c0                	test   %eax,%eax
  80b600:	75 1c                	jne    80b61e <netconn_getaddr+0x73>
  80b602:	c7 44 24 08 86 38 81 	movl   $0x813886,0x8(%esp)
  80b609:	00 
  80b60a:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80b611:	00 
  80b612:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b619:	e8 62 38 00 00       	call   80ee80 <_panic>

  msg.function = do_getaddr;
  80b61e:	c7 45 e4 1a cb 80 00 	movl   $0x80cb1a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b625:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80b628:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80b62b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80b62e:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80b631:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b634:	89 04 24             	mov    %eax,(%esp)
  80b637:	e8 8a 70 ff ff       	call   8026c6 <tcpip_apimsg>
  80b63c:	8a 43 0c             	mov    0xc(%ebx),%al

  return conn->err;
}
  80b63f:	83 c4 34             	add    $0x34,%esp
  80b642:	5b                   	pop    %ebx
  80b643:	5d                   	pop    %ebp
  80b644:	c3                   	ret    

0080b645 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b645:	55                   	push   %ebp
  80b646:	89 e5                	mov    %esp,%ebp
  80b648:	53                   	push   %ebx
  80b649:	83 ec 34             	sub    $0x34,%esp
  80b64c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b64f:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b652:	85 db                	test   %ebx,%ebx
  80b654:	75 1c                	jne    80b672 <netconn_bind+0x2d>
  80b656:	c7 44 24 08 a4 38 81 	movl   $0x8138a4,0x8(%esp)
  80b65d:	00 
  80b65e:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80b665:	00 
  80b666:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b66d:	e8 0e 38 00 00       	call   80ee80 <_panic>

  msg.function = do_bind;
  80b672:	c7 45 e4 5b c7 80 00 	movl   $0x80c75b,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b679:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b67c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b67f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b682:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80b686:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b689:	89 04 24             	mov    %eax,(%esp)
  80b68c:	e8 35 70 ff ff       	call   8026c6 <tcpip_apimsg>
  80b691:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80b694:	83 c4 34             	add    $0x34,%esp
  80b697:	5b                   	pop    %ebx
  80b698:	5d                   	pop    %ebp
  80b699:	c3                   	ret    

0080b69a <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b69a:	55                   	push   %ebp
  80b69b:	89 e5                	mov    %esp,%ebp
  80b69d:	53                   	push   %ebx
  80b69e:	83 ec 34             	sub    $0x34,%esp
  80b6a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b6a4:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b6a7:	85 db                	test   %ebx,%ebx
  80b6a9:	75 1c                	jne    80b6c7 <netconn_connect+0x2d>
  80b6ab:	c7 44 24 08 bf 38 81 	movl   $0x8138bf,0x8(%esp)
  80b6b2:	00 
  80b6b3:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80b6ba:	00 
  80b6bb:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b6c2:	e8 b9 37 00 00       	call   80ee80 <_panic>

  msg.function = do_connect;
  80b6c7:	c7 45 e4 f1 c7 80 00 	movl   $0x80c7f1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b6ce:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b6d1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b6d4:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b6d7:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80b6db:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b6de:	89 04 24             	mov    %eax,(%esp)
  80b6e1:	e8 e0 6f ff ff       	call   8026c6 <tcpip_apimsg>
  80b6e6:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80b6e9:	83 c4 34             	add    $0x34,%esp
  80b6ec:	5b                   	pop    %ebx
  80b6ed:	5d                   	pop    %ebp
  80b6ee:	c3                   	ret    

0080b6ef <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80b6ef:	55                   	push   %ebp
  80b6f0:	89 e5                	mov    %esp,%ebp
  80b6f2:	53                   	push   %ebx
  80b6f3:	83 ec 34             	sub    $0x34,%esp
  80b6f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b6f9:	85 db                	test   %ebx,%ebx
  80b6fb:	75 1c                	jne    80b719 <netconn_disconnect+0x2a>
  80b6fd:	c7 44 24 08 80 37 81 	movl   $0x813780,0x8(%esp)
  80b704:	00 
  80b705:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80b70c:	00 
  80b70d:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b714:	e8 67 37 00 00       	call   80ee80 <_panic>

  msg.function = do_disconnect;
  80b719:	c7 45 e4 b7 c8 80 00 	movl   $0x80c8b7,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b720:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80b723:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b726:	89 04 24             	mov    %eax,(%esp)
  80b729:	e8 98 6f ff ff       	call   8026c6 <tcpip_apimsg>
  80b72e:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80b731:	83 c4 34             	add    $0x34,%esp
  80b734:	5b                   	pop    %ebx
  80b735:	5d                   	pop    %ebp
  80b736:	c3                   	ret    

0080b737 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80b737:	55                   	push   %ebp
  80b738:	89 e5                	mov    %esp,%ebp
  80b73a:	53                   	push   %ebx
  80b73b:	83 ec 34             	sub    $0x34,%esp
  80b73e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b741:	85 db                	test   %ebx,%ebx
  80b743:	75 1c                	jne    80b761 <netconn_listen_with_backlog+0x2a>
  80b745:	c7 44 24 08 dd 38 81 	movl   $0x8138dd,0x8(%esp)
  80b74c:	00 
  80b74d:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80b754:	00 
  80b755:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b75c:	e8 1f 37 00 00       	call   80ee80 <_panic>

  msg.function = do_listen;
  80b761:	c7 45 e4 ee c8 80 00 	movl   $0x80c8ee,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b768:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80b76b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b76e:	89 04 24             	mov    %eax,(%esp)
  80b771:	e8 50 6f ff ff       	call   8026c6 <tcpip_apimsg>
  80b776:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80b779:	83 c4 34             	add    $0x34,%esp
  80b77c:	5b                   	pop    %ebx
  80b77d:	5d                   	pop    %ebp
  80b77e:	c3                   	ret    

0080b77f <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80b77f:	55                   	push   %ebp
  80b780:	89 e5                	mov    %esp,%ebp
  80b782:	53                   	push   %ebx
  80b783:	83 ec 24             	sub    $0x24,%esp
  80b786:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b789:	85 db                	test   %ebx,%ebx
  80b78b:	75 1c                	jne    80b7a9 <netconn_accept+0x2a>
  80b78d:	c7 44 24 08 fa 38 81 	movl   $0x8138fa,0x8(%esp)
  80b794:	00 
  80b795:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80b79c:	00 
  80b79d:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b7a4:	e8 d7 36 00 00       	call   80ee80 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b7a9:	8b 43 18             	mov    0x18(%ebx),%eax
  80b7ac:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b7af:	75 1c                	jne    80b7cd <netconn_accept+0x4e>
  80b7b1:	c7 44 24 08 a4 37 81 	movl   $0x8137a4,0x8(%esp)
  80b7b8:	00 
  80b7b9:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80b7c0:	00 
  80b7c1:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b7c8:	e8 b3 36 00 00       	call   80ee80 <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b7cd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b7d4:	00 
  80b7d5:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b7d8:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b7dc:	89 04 24             	mov    %eax,(%esp)
  80b7df:	e8 89 f2 ff ff       	call   80aa6d <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b7e4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7e7:	85 c0                	test   %eax,%eax
  80b7e9:	74 15                	je     80b800 <netconn_accept+0x81>
  80b7eb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b7f2:	00 
  80b7f3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b7fa:	00 
  80b7fb:	89 1c 24             	mov    %ebx,(%esp)
  80b7fe:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b800:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b803:	83 c4 24             	add    $0x24,%esp
  80b806:	5b                   	pop    %ebx
  80b807:	5d                   	pop    %ebp
  80b808:	c3                   	ret    

0080b809 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80b809:	55                   	push   %ebp
  80b80a:	89 e5                	mov    %esp,%ebp
  80b80c:	53                   	push   %ebx
  80b80d:	83 ec 34             	sub    $0x34,%esp
  80b810:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80b813:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b81a:	85 db                	test   %ebx,%ebx
  80b81c:	75 1c                	jne    80b83a <netconn_recv+0x31>
  80b81e:	c7 44 24 08 17 39 81 	movl   $0x813917,0x8(%esp)
  80b825:	00 
  80b826:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80b82d:	00 
  80b82e:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b835:	e8 46 36 00 00       	call   80ee80 <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80b83a:	8b 43 14             	mov    0x14(%ebx),%eax
  80b83d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b840:	75 0e                	jne    80b850 <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80b842:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b846:	b8 00 00 00 00       	mov    $0x0,%eax
  80b84b:	e9 5c 01 00 00       	jmp    80b9ac <netconn_recv+0x1a3>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b850:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b854:	0f 8c 46 01 00 00    	jl     80b9a0 <netconn_recv+0x197>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b85a:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b85d:	0f 85 f3 00 00 00    	jne    80b956 <netconn_recv+0x14d>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b863:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b867:	75 0e                	jne    80b877 <netconn_recv+0x6e>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80b869:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b86d:	b8 00 00 00 00       	mov    $0x0,%eax
  80b872:	e9 35 01 00 00       	jmp    80b9ac <netconn_recv+0x1a3>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b877:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80b87e:	e8 e3 90 ff ff       	call   804966 <memp_malloc>
  80b883:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b886:	85 c0                	test   %eax,%eax
  80b888:	75 09                	jne    80b893 <netconn_recv+0x8a>
      conn->err = ERR_MEM;
  80b88a:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b88e:	e9 19 01 00 00       	jmp    80b9ac <netconn_recv+0x1a3>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b893:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b89a:	00 
  80b89b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80b89e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b8a2:	8b 43 14             	mov    0x14(%ebx),%eax
  80b8a5:	89 04 24             	mov    %eax,(%esp)
  80b8a8:	e8 c0 f1 ff ff       	call   80aa6d <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b8ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b8b0:	85 c0                	test   %eax,%eax
  80b8b2:	74 09                	je     80b8bd <netconn_recv+0xb4>
      len = p->tot_len;
  80b8b4:	8b 50 08             	mov    0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b8b7:	66 29 53 20          	sub    %dx,0x20(%ebx)
  80b8bb:	eb 05                	jmp    80b8c2 <netconn_recv+0xb9>
    } else {
      len = 0;
  80b8bd:	ba 00 00 00 00       	mov    $0x0,%edx
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b8c2:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b8c5:	85 c0                	test   %eax,%eax
  80b8c7:	74 14                	je     80b8dd <netconn_recv+0xd4>
  80b8c9:	0f b7 d2             	movzwl %dx,%edx
  80b8cc:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b8d0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b8d7:	00 
  80b8d8:	89 1c 24             	mov    %ebx,(%esp)
  80b8db:	ff d0                	call   *%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80b8dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b8e0:	85 c0                	test   %eax,%eax
  80b8e2:	75 2b                	jne    80b90f <netconn_recv+0x106>
      memp_free(MEMP_NETBUF, buf);
  80b8e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b8e7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b8eb:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80b8f2:	e8 cf 90 ff ff       	call   8049c6 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80b8f7:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b8fb:	0f 85 a6 00 00 00    	jne    80b9a7 <netconn_recv+0x19e>
        conn->err = ERR_CLSD;
  80b901:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
      }
      return NULL;
  80b905:	b8 00 00 00 00       	mov    $0x0,%eax
  80b90a:	e9 9d 00 00 00       	jmp    80b9ac <netconn_recv+0x1a3>
    }

    buf->p = p;
  80b90f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b912:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80b914:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b917:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b91a:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80b91d:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80b923:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80b92a:	c7 45 e4 8c ca 80 00 	movl   $0x80ca8c,-0x1c(%ebp)
    msg.msg.conn = conn;
  80b931:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80b934:	85 c0                	test   %eax,%eax
  80b936:	74 0b                	je     80b943 <netconn_recv+0x13a>
      msg.msg.msg.r.len = buf->p->tot_len;
  80b938:	8b 00                	mov    (%eax),%eax
  80b93a:	8b 40 08             	mov    0x8(%eax),%eax
  80b93d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80b941:	eb 06                	jmp    80b949 <netconn_recv+0x140>
    } else {
      msg.msg.msg.r.len = 1;
  80b943:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80b949:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b94c:	89 04 24             	mov    %eax,(%esp)
  80b94f:	e8 72 6d ff ff       	call   8026c6 <tcpip_apimsg>
  80b954:	eb 45                	jmp    80b99b <netconn_recv+0x192>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b956:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b95d:	00 
  80b95e:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b961:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b965:	89 04 24             	mov    %eax,(%esp)
  80b968:	e8 00 f1 ff ff       	call   80aa6d <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80b96d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b970:	85 c0                	test   %eax,%eax
  80b972:	74 27                	je     80b99b <netconn_recv+0x192>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b974:	8b 10                	mov    (%eax),%edx
  80b976:	8b 52 08             	mov    0x8(%edx),%edx
  80b979:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b97d:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b980:	85 d2                	test   %edx,%edx
  80b982:	74 17                	je     80b99b <netconn_recv+0x192>
  80b984:	8b 00                	mov    (%eax),%eax
  80b986:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b98a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b98e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b995:	00 
  80b996:	89 1c 24             	mov    %ebx,(%esp)
  80b999:	ff d2                	call   *%edx
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b99b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b99e:	eb 0c                	jmp    80b9ac <netconn_recv+0x1a3>
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80b9a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9a5:	eb 05                	jmp    80b9ac <netconn_recv+0x1a3>
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
        conn->err = ERR_CLSD;
      }
      return NULL;
  80b9a7:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
}
  80b9ac:	83 c4 34             	add    $0x34,%esp
  80b9af:	5b                   	pop    %ebx
  80b9b0:	5d                   	pop    %ebp
  80b9b1:	c3                   	ret    

0080b9b2 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b9b2:	55                   	push   %ebp
  80b9b3:	89 e5                	mov    %esp,%ebp
  80b9b5:	53                   	push   %ebx
  80b9b6:	83 ec 34             	sub    $0x34,%esp
  80b9b9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b9bc:	85 db                	test   %ebx,%ebx
  80b9be:	75 1c                	jne    80b9dc <netconn_send+0x2a>
  80b9c0:	c7 44 24 08 32 39 81 	movl   $0x813932,0x8(%esp)
  80b9c7:	00 
  80b9c8:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80b9cf:	00 
  80b9d0:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80b9d7:	e8 a4 34 00 00       	call   80ee80 <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b9dc:	c7 45 e4 d4 c9 80 00 	movl   $0x80c9d4,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b9e3:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b9e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b9e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b9ec:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b9ef:	89 04 24             	mov    %eax,(%esp)
  80b9f2:	e8 cf 6c ff ff       	call   8026c6 <tcpip_apimsg>
  80b9f7:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80b9fa:	83 c4 34             	add    $0x34,%esp
  80b9fd:	5b                   	pop    %ebx
  80b9fe:	5d                   	pop    %ebp
  80b9ff:	c3                   	ret    

0080ba00 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80ba00:	55                   	push   %ebp
  80ba01:	89 e5                	mov    %esp,%ebp
  80ba03:	83 ec 18             	sub    $0x18,%esp
  80ba06:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ba09:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80ba0c:	85 c0                	test   %eax,%eax
  80ba0e:	74 1b                	je     80ba2b <netconn_sendto+0x2b>
    buf->addr = addr;
  80ba10:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80ba13:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80ba16:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80ba1a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ba1e:	8b 45 08             	mov    0x8(%ebp),%eax
  80ba21:	89 04 24             	mov    %eax,(%esp)
  80ba24:	e8 89 ff ff ff       	call   80b9b2 <netconn_send>
  80ba29:	eb 02                	jmp    80ba2d <netconn_sendto+0x2d>
  }
  return ERR_VAL;
  80ba2b:	b0 f7                	mov    $0xf7,%al
}
  80ba2d:	c9                   	leave  
  80ba2e:	c3                   	ret    

0080ba2f <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80ba2f:	55                   	push   %ebp
  80ba30:	89 e5                	mov    %esp,%ebp
  80ba32:	53                   	push   %ebx
  80ba33:	83 ec 34             	sub    $0x34,%esp
  80ba36:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ba39:	8a 45 14             	mov    0x14(%ebp),%al
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80ba3c:	85 db                	test   %ebx,%ebx
  80ba3e:	75 1c                	jne    80ba5c <netconn_write+0x2d>
  80ba40:	c7 44 24 08 4d 39 81 	movl   $0x81394d,0x8(%esp)
  80ba47:	00 
  80ba48:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80ba4f:	00 
  80ba50:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80ba57:	e8 24 34 00 00       	call   80ee80 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80ba5c:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ba5f:	74 1c                	je     80ba7d <netconn_write+0x4e>
  80ba61:	c7 44 24 08 c8 37 81 	movl   $0x8137c8,0x8(%esp)
  80ba68:	00 
  80ba69:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80ba70:	00 
  80ba71:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80ba78:	e8 03 34 00 00       	call   80ee80 <_panic>

  msg.function = do_write;
  80ba7d:	c7 45 e4 cd ca 80 00 	movl   $0x80cacd,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ba84:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80ba87:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ba8a:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80ba8d:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80ba90:	8b 45 10             	mov    0x10(%ebp),%eax
  80ba93:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80ba96:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ba99:	89 04 24             	mov    %eax,(%esp)
  80ba9c:	e8 25 6c ff ff       	call   8026c6 <tcpip_apimsg>
  80baa1:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80baa4:	83 c4 34             	add    $0x34,%esp
  80baa7:	5b                   	pop    %ebx
  80baa8:	5d                   	pop    %ebp
  80baa9:	c3                   	ret    

0080baaa <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80baaa:	55                   	push   %ebp
  80baab:	89 e5                	mov    %esp,%ebp
  80baad:	53                   	push   %ebx
  80baae:	83 ec 34             	sub    $0x34,%esp
  80bab1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80bab4:	85 db                	test   %ebx,%ebx
  80bab6:	75 1c                	jne    80bad4 <netconn_close+0x2a>
  80bab8:	c7 44 24 08 69 39 81 	movl   $0x813969,0x8(%esp)
  80babf:	00 
  80bac0:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80bac7:	00 
  80bac8:	c7 04 24 ea 37 81 00 	movl   $0x8137ea,(%esp)
  80bacf:	e8 ac 33 00 00       	call   80ee80 <_panic>

  msg.function = do_close;
  80bad4:	c7 45 e4 d9 cb 80 00 	movl   $0x80cbd9,-0x1c(%ebp)
  msg.msg.conn = conn;
  80badb:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80bade:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bae1:	89 04 24             	mov    %eax,(%esp)
  80bae4:	e8 dd 6b ff ff       	call   8026c6 <tcpip_apimsg>
  80bae9:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80baec:	83 c4 34             	add    $0x34,%esp
  80baef:	5b                   	pop    %ebx
  80baf0:	5d                   	pop    %ebp
  80baf1:	c3                   	ret    
	...

0080baf4 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80baf4:	55                   	push   %ebp
  80baf5:	89 e5                	mov    %esp,%ebp
  80baf7:	53                   	push   %ebx
  80baf8:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80bafb:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80bafe:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bb02:	89 1c 24             	mov    %ebx,(%esp)
  80bb05:	e8 80 a2 ff ff       	call   805d8a <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80bb0a:	c7 44 24 04 bd c0 80 	movl   $0x80c0bd,0x4(%esp)
  80bb11:	00 
  80bb12:	89 1c 24             	mov    %ebx,(%esp)
  80bb15:	e8 7e a2 ff ff       	call   805d98 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80bb1a:	c7 44 24 04 1d c0 80 	movl   $0x80c01d,0x4(%esp)
  80bb21:	00 
  80bb22:	89 1c 24             	mov    %ebx,(%esp)
  80bb25:	e8 7f a2 ff ff       	call   805da9 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80bb2a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80bb31:	00 
  80bb32:	c7 44 24 04 d7 bf 80 	movl   $0x80bfd7,0x4(%esp)
  80bb39:	00 
  80bb3a:	89 1c 24             	mov    %ebx,(%esp)
  80bb3d:	e8 97 a2 ff ff       	call   805dd9 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80bb42:	c7 44 24 04 96 bd 80 	movl   $0x80bd96,0x4(%esp)
  80bb49:	00 
  80bb4a:	89 1c 24             	mov    %ebx,(%esp)
  80bb4d:	e8 68 a2 ff ff       	call   805dba <tcp_err>
}
  80bb52:	83 c4 14             	add    $0x14,%esp
  80bb55:	5b                   	pop    %ebx
  80bb56:	5d                   	pop    %ebp
  80bb57:	c3                   	ret    

0080bb58 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80bb58:	55                   	push   %ebp
  80bb59:	89 e5                	mov    %esp,%ebp
  80bb5b:	53                   	push   %ebx
  80bb5c:	83 ec 14             	sub    $0x14,%esp
  80bb5f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bb62:	8a 45 10             	mov    0x10(%ebp),%al

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80bb65:	85 db                	test   %ebx,%ebx
  80bb67:	74 29                	je     80bb92 <do_connected+0x3a>
    return ERR_VAL;
  }

  conn->err = err;
  80bb69:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80bb6c:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bb6f:	75 0b                	jne    80bb7c <do_connected+0x24>
  80bb71:	84 c0                	test   %al,%al
  80bb73:	75 07                	jne    80bb7c <do_connected+0x24>
    setup_tcp(conn);
  80bb75:	89 d8                	mov    %ebx,%eax
  80bb77:	e8 78 ff ff ff       	call   80baf4 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80bb7c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80bb83:	8b 43 10             	mov    0x10(%ebx),%eax
  80bb86:	89 04 24             	mov    %eax,(%esp)
  80bb89:	e8 33 ec ff ff       	call   80a7c1 <sys_sem_signal>
  return ERR_OK;
  80bb8e:	b0 00                	mov    $0x0,%al
  80bb90:	eb 02                	jmp    80bb94 <do_connected+0x3c>
  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
    return ERR_VAL;
  80bb92:	b0 f7                	mov    $0xf7,%al
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  sys_sem_signal(conn->op_completed);
  return ERR_OK;
}
  80bb94:	83 c4 14             	add    $0x14,%esp
  80bb97:	5b                   	pop    %ebx
  80bb98:	5d                   	pop    %ebp
  80bb99:	c3                   	ret    

0080bb9a <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80bb9a:	55                   	push   %ebp
  80bb9b:	89 e5                	mov    %esp,%ebp
  80bb9d:	53                   	push   %ebx
  80bb9e:	83 ec 14             	sub    $0x14,%esp
  80bba1:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80bba3:	85 c0                	test   %eax,%eax
  80bba5:	75 1c                	jne    80bbc3 <do_close_internal+0x29>
  80bba7:	c7 44 24 08 40 39 81 	movl   $0x813940,0x8(%esp)
  80bbae:	00 
  80bbaf:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80bbb6:	00 
  80bbb7:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80bbbe:	e8 bd 32 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80bbc3:	83 38 10             	cmpl   $0x10,(%eax)
  80bbc6:	74 1c                	je     80bbe4 <do_close_internal+0x4a>
  80bbc8:	c7 44 24 08 9c 39 81 	movl   $0x81399c,0x8(%esp)
  80bbcf:	00 
  80bbd0:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80bbd7:	00 
  80bbd8:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80bbdf:	e8 9c 32 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80bbe4:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80bbe8:	74 1c                	je     80bc06 <do_close_internal+0x6c>
  80bbea:	c7 44 24 08 68 3a 81 	movl   $0x813a68,0x8(%esp)
  80bbf1:	00 
  80bbf2:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80bbf9:	00 
  80bbfa:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80bc01:	e8 7a 32 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80bc06:	8b 40 08             	mov    0x8(%eax),%eax
  80bc09:	85 c0                	test   %eax,%eax
  80bc0b:	75 1c                	jne    80bc29 <do_close_internal+0x8f>
  80bc0d:	c7 44 24 08 ba 39 81 	movl   $0x8139ba,0x8(%esp)
  80bc14:	00 
  80bc15:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80bc1c:	00 
  80bc1d:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80bc24:	e8 57 32 00 00       	call   80ee80 <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80bc29:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc30:	00 
  80bc31:	89 04 24             	mov    %eax,(%esp)
  80bc34:	e8 51 a1 ff ff       	call   805d8a <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80bc39:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc3c:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bc40:	75 12                	jne    80bc54 <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80bc42:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc49:	00 
  80bc4a:	89 04 24             	mov    %eax,(%esp)
  80bc4d:	e8 79 a1 ff ff       	call   805dcb <tcp_accept>
  80bc52:	eb 64                	jmp    80bcb8 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80bc54:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc5b:	00 
  80bc5c:	89 04 24             	mov    %eax,(%esp)
  80bc5f:	e8 34 a1 ff ff       	call   805d98 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80bc64:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc6b:	00 
  80bc6c:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc6f:	89 04 24             	mov    %eax,(%esp)
  80bc72:	e8 54 a1 ff ff       	call   805dcb <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80bc77:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc7e:	00 
  80bc7f:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc82:	89 04 24             	mov    %eax,(%esp)
  80bc85:	e8 1f a1 ff ff       	call   805da9 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80bc8a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80bc91:	00 
  80bc92:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc99:	00 
  80bc9a:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc9d:	89 04 24             	mov    %eax,(%esp)
  80bca0:	e8 34 a1 ff ff       	call   805dd9 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80bca5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bcac:	00 
  80bcad:	8b 43 08             	mov    0x8(%ebx),%eax
  80bcb0:	89 04 24             	mov    %eax,(%esp)
  80bcb3:	e8 02 a1 ff ff       	call   805dba <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80bcb8:	8b 43 08             	mov    0x8(%ebx),%eax
  80bcbb:	89 04 24             	mov    %eax,(%esp)
  80bcbe:	e8 0d a8 ff ff       	call   8064d0 <tcp_close>
  if (err == ERR_OK) {
  80bcc3:	84 c0                	test   %al,%al
  80bcc5:	75 57                	jne    80bd1e <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80bcc7:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80bcce:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80bcd5:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bcd9:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bcdc:	85 c0                	test   %eax,%eax
  80bcde:	74 31                	je     80bd11 <do_close_internal+0x177>
  80bce0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bce7:	00 
  80bce8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bcef:	00 
  80bcf0:	89 1c 24             	mov    %ebx,(%esp)
  80bcf3:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80bcf5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bcf8:	85 c0                	test   %eax,%eax
  80bcfa:	74 15                	je     80bd11 <do_close_internal+0x177>
  80bcfc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bd03:	00 
  80bd04:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80bd0b:	00 
  80bd0c:	89 1c 24             	mov    %ebx,(%esp)
  80bd0f:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80bd11:	8b 43 10             	mov    0x10(%ebx),%eax
  80bd14:	89 04 24             	mov    %eax,(%esp)
  80bd17:	e8 a5 ea ff ff       	call   80a7c1 <sys_sem_signal>
  80bd1c:	eb 72                	jmp    80bd90 <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bd1e:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd21:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bd25:	75 1c                	jne    80bd43 <do_close_internal+0x1a9>
  80bd27:	c7 44 24 08 8c 3a 81 	movl   $0x813a8c,0x8(%esp)
  80bd2e:	00 
  80bd2f:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80bd36:	00 
  80bd37:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80bd3e:	e8 3d 31 00 00       	call   80ee80 <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80bd43:	c7 44 24 04 1d c0 80 	movl   $0x80c01d,0x4(%esp)
  80bd4a:	00 
  80bd4b:	89 04 24             	mov    %eax,(%esp)
  80bd4e:	e8 56 a0 ff ff       	call   805da9 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80bd53:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80bd5a:	00 
  80bd5b:	c7 44 24 04 d7 bf 80 	movl   $0x80bfd7,0x4(%esp)
  80bd62:	00 
  80bd63:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd66:	89 04 24             	mov    %eax,(%esp)
  80bd69:	e8 6b a0 ff ff       	call   805dd9 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80bd6e:	c7 44 24 04 96 bd 80 	movl   $0x80bd96,0x4(%esp)
  80bd75:	00 
  80bd76:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd79:	89 04 24             	mov    %eax,(%esp)
  80bd7c:	e8 39 a0 ff ff       	call   805dba <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80bd81:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80bd85:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd88:	89 04 24             	mov    %eax,(%esp)
  80bd8b:	e8 fa 9f ff ff       	call   805d8a <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80bd90:	83 c4 14             	add    $0x14,%esp
  80bd93:	5b                   	pop    %ebx
  80bd94:	5d                   	pop    %ebp
  80bd95:	c3                   	ret    

0080bd96 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80bd96:	55                   	push   %ebp
  80bd97:	89 e5                	mov    %esp,%ebp
  80bd99:	53                   	push   %ebx
  80bd9a:	83 ec 14             	sub    $0x14,%esp
  80bd9d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bda0:	8a 45 0c             	mov    0xc(%ebp),%al
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bda3:	85 db                	test   %ebx,%ebx
  80bda5:	75 1c                	jne    80bdc3 <err_tcp+0x2d>
  80bda7:	c7 44 24 08 cd 39 81 	movl   $0x8139cd,0x8(%esp)
  80bdae:	00 
  80bdaf:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80bdb6:	00 
  80bdb7:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80bdbe:	e8 bd 30 00 00       	call   80ee80 <_panic>

  conn->pcb.tcp = NULL;
  80bdc3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80bdca:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bdcd:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bdd1:	74 2f                	je     80be02 <err_tcp+0x6c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bdd3:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bdd6:	85 c0                	test   %eax,%eax
  80bdd8:	74 15                	je     80bdef <err_tcp+0x59>
  80bdda:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bde1:	00 
  80bde2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bde9:	00 
  80bdea:	89 1c 24             	mov    %ebx,(%esp)
  80bded:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80bdef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bdf6:	00 
  80bdf7:	8b 43 14             	mov    0x14(%ebx),%eax
  80bdfa:	89 04 24             	mov    %eax,(%esp)
  80bdfd:	e8 29 ec ff ff       	call   80aa2b <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80be02:	8b 43 10             	mov    0x10(%ebx),%eax
  80be05:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be08:	74 15                	je     80be1f <err_tcp+0x89>
  80be0a:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80be0e:	75 0f                	jne    80be1f <err_tcp+0x89>
    conn->state = NETCONN_NONE;
  80be10:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80be17:	89 04 24             	mov    %eax,(%esp)
  80be1a:	e8 a2 e9 ff ff       	call   80a7c1 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80be1f:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80be23:	74 2f                	je     80be54 <err_tcp+0xbe>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80be25:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80be28:	85 c0                	test   %eax,%eax
  80be2a:	74 15                	je     80be41 <err_tcp+0xab>
  80be2c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80be33:	00 
  80be34:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80be3b:	00 
  80be3c:	89 1c 24             	mov    %ebx,(%esp)
  80be3f:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80be41:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80be48:	00 
  80be49:	8b 43 18             	mov    0x18(%ebx),%eax
  80be4c:	89 04 24             	mov    %eax,(%esp)
  80be4f:	e8 d7 eb ff ff       	call   80aa2b <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80be54:	8b 43 04             	mov    0x4(%ebx),%eax
  80be57:	83 f8 01             	cmp    $0x1,%eax
  80be5a:	74 05                	je     80be61 <err_tcp+0xcb>
  80be5c:	83 f8 04             	cmp    $0x4,%eax
  80be5f:	75 12                	jne    80be73 <err_tcp+0xdd>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80be61:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80be68:	8b 43 10             	mov    0x10(%ebx),%eax
  80be6b:	89 04 24             	mov    %eax,(%esp)
  80be6e:	e8 4e e9 ff ff       	call   80a7c1 <sys_sem_signal>
  }
}
  80be73:	83 c4 14             	add    $0x14,%esp
  80be76:	5b                   	pop    %ebx
  80be77:	5d                   	pop    %ebp
  80be78:	c3                   	ret    

0080be79 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80be79:	55                   	push   %ebp
  80be7a:	89 e5                	mov    %esp,%ebp
  80be7c:	57                   	push   %edi
  80be7d:	56                   	push   %esi
  80be7e:	53                   	push   %ebx
  80be7f:	83 ec 2c             	sub    $0x2c,%esp
  80be82:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80be84:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80be88:	74 1c                	je     80bea6 <do_writemore+0x2d>
  80be8a:	c7 44 24 08 da 39 81 	movl   $0x8139da,0x8(%esp)
  80be91:	00 
  80be92:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80be99:	00 
  80be9a:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80bea1:	e8 da 2f 00 00       	call   80ee80 <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80bea6:	8b 40 24             	mov    0x24(%eax),%eax
  80bea9:	8b 53 28             	mov    0x28(%ebx),%edx
  80beac:	8b 48 04             	mov    0x4(%eax),%ecx
  80beaf:	01 d1                	add    %edx,%ecx
  80beb1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80beb4:	8b 48 08             	mov    0x8(%eax),%ecx
  80beb7:	89 ce                	mov    %ecx,%esi
  80beb9:	29 d6                	sub    %edx,%esi
  80bebb:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  80bec1:	7f 05                	jg     80bec8 <do_writemore+0x4f>
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80bec3:	66 29 d1             	sub    %dx,%cx
  80bec6:	eb 05                	jmp    80becd <do_writemore+0x54>

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
    len = 0xffff;
  80bec8:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80becd:	8b 53 08             	mov    0x8(%ebx),%edx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80bed0:	66 8b 7a 6e          	mov    0x6e(%edx),%di
  80bed4:	89 ce                	mov    %ecx,%esi
  80bed6:	66 39 f9             	cmp    %di,%cx
  80bed9:	76 02                	jbe    80bedd <do_writemore+0x64>
  80bedb:	89 fe                	mov    %edi,%esi
  80bedd:	0f b7 f6             	movzwl %si,%esi
  80bee0:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80bee4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80bee8:	89 74 24 08          	mov    %esi,0x8(%esp)
  80beec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80beef:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bef3:	89 14 24             	mov    %edx,(%esp)
  80bef6:	e8 91 c6 ff ff       	call   80858c <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80befb:	89 f2                	mov    %esi,%edx
  80befd:	03 53 28             	add    0x28(%ebx),%edx
  80bf00:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80bf03:	3b 51 08             	cmp    0x8(%ecx),%edx
  80bf06:	7e 1c                	jle    80bf24 <do_writemore+0xab>
  80bf08:	c7 44 24 08 f7 39 81 	movl   $0x8139f7,0x8(%esp)
  80bf0f:	00 
  80bf10:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80bf17:	00 
  80bf18:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80bf1f:	e8 5c 2f 00 00       	call   80ee80 <_panic>
  if (err == ERR_OK) {
  80bf24:	84 c0                	test   %al,%al
  80bf26:	75 71                	jne    80bf99 <do_writemore+0x120>
    conn->write_offset += len;
  80bf28:	89 53 28             	mov    %edx,0x28(%ebx)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80bf2b:	3b 51 08             	cmp    0x8(%ecx),%edx
  80bf2e:	75 15                	jne    80bf45 <do_writemore+0xcc>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80bf30:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80bf37:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  80bf3e:	bf 01 00 00 00       	mov    $0x1,%edi
  80bf43:	eb 05                	jmp    80bf4a <do_writemore+0xd1>
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80bf45:	bf 00 00 00 00       	mov    $0x0,%edi
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80bf4a:	8b 43 08             	mov    0x8(%ebx),%eax
  80bf4d:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80bf51:	74 12                	je     80bf65 <do_writemore+0xec>
  80bf53:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80bf57:	75 0c                	jne    80bf65 <do_writemore+0xec>
  80bf59:	8b 50 74             	mov    0x74(%eax),%edx
  80bf5c:	85 d2                	test   %edx,%edx
  80bf5e:	74 71                	je     80bfd1 <do_writemore+0x158>
  80bf60:	83 3a 00             	cmpl   $0x0,(%edx)
  80bf63:	74 6c                	je     80bfd1 <do_writemore+0x158>
  80bf65:	89 04 24             	mov    %eax,(%esp)
  80bf68:	e8 d1 c6 ff ff       	call   80863e <tcp_output>
    conn->err = err;
  80bf6d:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80bf70:	84 c0                	test   %al,%al
  80bf72:	75 3b                	jne    80bfaf <do_writemore+0x136>
  80bf74:	8b 43 08             	mov    0x8(%ebx),%eax
  80bf77:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80bf7d:	77 30                	ja     80bfaf <do_writemore+0x136>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80bf7f:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bf82:	85 c0                	test   %eax,%eax
  80bf84:	74 29                	je     80bfaf <do_writemore+0x136>
  80bf86:	89 74 24 08          	mov    %esi,0x8(%esp)
  80bf8a:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80bf91:	00 
  80bf92:	89 1c 24             	mov    %ebx,(%esp)
  80bf95:	ff d0                	call   *%eax
  80bf97:	eb 16                	jmp    80bfaf <do_writemore+0x136>
    }
  } else if (err == ERR_MEM) {
  80bf99:	3c ff                	cmp    $0xff,%al
  80bf9b:	75 0d                	jne    80bfaa <do_writemore+0x131>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80bf9d:	8b 43 08             	mov    0x8(%ebx),%eax
  80bfa0:	89 04 24             	mov    %eax,(%esp)
  80bfa3:	e8 96 c6 ff ff       	call   80863e <tcp_output>
  80bfa8:	eb 1d                	jmp    80bfc7 <do_writemore+0x14e>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80bfaa:	88 43 0c             	mov    %al,0xc(%ebx)
  80bfad:	eb 06                	jmp    80bfb5 <do_writemore+0x13c>
    write_finished = 1;
  }

  if (write_finished) {
  80bfaf:	89 f9                	mov    %edi,%ecx
  80bfb1:	84 c9                	test   %cl,%cl
  80bfb3:	74 12                	je     80bfc7 <do_writemore+0x14e>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80bfb5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80bfbc:	8b 43 10             	mov    0x10(%ebx),%eax
  80bfbf:	89 04 24             	mov    %eax,(%esp)
  80bfc2:	e8 fa e7 ff ff       	call   80a7c1 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80bfc7:	b0 00                	mov    $0x0,%al
  80bfc9:	83 c4 2c             	add    $0x2c,%esp
  80bfcc:	5b                   	pop    %ebx
  80bfcd:	5e                   	pop    %esi
  80bfce:	5f                   	pop    %edi
  80bfcf:	5d                   	pop    %ebp
  80bfd0:	c3                   	ret    
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80bfd1:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80bfd5:	eb 9d                	jmp    80bf74 <do_writemore+0xfb>

0080bfd7 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80bfd7:	55                   	push   %ebp
  80bfd8:	89 e5                	mov    %esp,%ebp
  80bfda:	83 ec 18             	sub    $0x18,%esp
  80bfdd:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bfe0:	85 c0                	test   %eax,%eax
  80bfe2:	75 1c                	jne    80c000 <poll_tcp+0x29>
  80bfe4:	c7 44 24 08 cd 39 81 	movl   $0x8139cd,0x8(%esp)
  80bfeb:	00 
  80bfec:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80bff3:	00 
  80bff4:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80bffb:	e8 80 2e 00 00       	call   80ee80 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c000:	8b 50 04             	mov    0x4(%eax),%edx
  80c003:	83 fa 01             	cmp    $0x1,%edx
  80c006:	75 07                	jne    80c00f <poll_tcp+0x38>
    do_writemore(conn);
  80c008:	e8 6c fe ff ff       	call   80be79 <do_writemore>
  80c00d:	eb 0a                	jmp    80c019 <poll_tcp+0x42>
  } else if (conn->state == NETCONN_CLOSE) {
  80c00f:	83 fa 04             	cmp    $0x4,%edx
  80c012:	75 05                	jne    80c019 <poll_tcp+0x42>
    do_close_internal(conn);
  80c014:	e8 81 fb ff ff       	call   80bb9a <do_close_internal>
  }

  return ERR_OK;
}
  80c019:	b0 00                	mov    $0x0,%al
  80c01b:	c9                   	leave  
  80c01c:	c3                   	ret    

0080c01d <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80c01d:	55                   	push   %ebp
  80c01e:	89 e5                	mov    %esp,%ebp
  80c020:	56                   	push   %esi
  80c021:	53                   	push   %ebx
  80c022:	83 ec 10             	sub    $0x10,%esp
  80c025:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c028:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c02b:	85 db                	test   %ebx,%ebx
  80c02d:	75 1c                	jne    80c04b <sent_tcp+0x2e>
  80c02f:	c7 44 24 08 cd 39 81 	movl   $0x8139cd,0x8(%esp)
  80c036:	00 
  80c037:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80c03e:	00 
  80c03f:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c046:	e8 35 2e 00 00       	call   80ee80 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c04b:	8b 43 04             	mov    0x4(%ebx),%eax
  80c04e:	83 f8 01             	cmp    $0x1,%eax
  80c051:	75 2b                	jne    80c07e <sent_tcp+0x61>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80c053:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c057:	75 1c                	jne    80c075 <sent_tcp+0x58>
  80c059:	c7 44 24 08 15 3a 81 	movl   $0x813a15,0x8(%esp)
  80c060:	00 
  80c061:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80c068:	00 
  80c069:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c070:	e8 0b 2e 00 00       	call   80ee80 <_panic>
    do_writemore(conn);
  80c075:	89 d8                	mov    %ebx,%eax
  80c077:	e8 fd fd ff ff       	call   80be79 <do_writemore>
  80c07c:	eb 0c                	jmp    80c08a <sent_tcp+0x6d>
  } else if (conn->state == NETCONN_CLOSE) {
  80c07e:	83 f8 04             	cmp    $0x4,%eax
  80c081:	75 07                	jne    80c08a <sent_tcp+0x6d>
    do_close_internal(conn);
  80c083:	89 d8                	mov    %ebx,%eax
  80c085:	e8 10 fb ff ff       	call   80bb9a <do_close_internal>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80c08a:	8b 43 08             	mov    0x8(%ebx),%eax
  80c08d:	85 c0                	test   %eax,%eax
  80c08f:	74 23                	je     80c0b4 <sent_tcp+0x97>
  80c091:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80c097:	76 1b                	jbe    80c0b4 <sent_tcp+0x97>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80c099:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c09c:	85 c0                	test   %eax,%eax
  80c09e:	74 14                	je     80c0b4 <sent_tcp+0x97>
  80c0a0:	0f b7 f6             	movzwl %si,%esi
  80c0a3:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c0a7:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c0ae:	00 
  80c0af:	89 1c 24             	mov    %ebx,(%esp)
  80c0b2:	ff d0                	call   *%eax
    }
  }
  
  return ERR_OK;
}
  80c0b4:	b0 00                	mov    $0x0,%al
  80c0b6:	83 c4 10             	add    $0x10,%esp
  80c0b9:	5b                   	pop    %ebx
  80c0ba:	5e                   	pop    %esi
  80c0bb:	5d                   	pop    %ebp
  80c0bc:	c3                   	ret    

0080c0bd <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80c0bd:	55                   	push   %ebp
  80c0be:	89 e5                	mov    %esp,%ebp
  80c0c0:	56                   	push   %esi
  80c0c1:	53                   	push   %ebx
  80c0c2:	83 ec 10             	sub    $0x10,%esp
  80c0c5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c0c8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c0cb:	8b 75 10             	mov    0x10(%ebp),%esi
  80c0ce:	8a 55 14             	mov    0x14(%ebp),%dl
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80c0d1:	85 c0                	test   %eax,%eax
  80c0d3:	75 1c                	jne    80c0f1 <recv_tcp+0x34>
  80c0d5:	c7 44 24 08 b0 3a 81 	movl   $0x813ab0,0x8(%esp)
  80c0dc:	00 
  80c0dd:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80c0e4:	00 
  80c0e5:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c0ec:	e8 8f 2d 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80c0f1:	85 db                	test   %ebx,%ebx
  80c0f3:	75 1c                	jne    80c111 <recv_tcp+0x54>
  80c0f5:	c7 44 24 08 d4 3a 81 	movl   $0x813ad4,0x8(%esp)
  80c0fc:	00 
  80c0fd:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80c104:	00 
  80c105:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c10c:	e8 6f 2d 00 00       	call   80ee80 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80c111:	39 43 08             	cmp    %eax,0x8(%ebx)
  80c114:	74 1c                	je     80c132 <recv_tcp+0x75>
  80c116:	c7 44 24 08 2b 3a 81 	movl   $0x813a2b,0x8(%esp)
  80c11d:	00 
  80c11e:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80c125:	00 
  80c126:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c12d:	e8 4e 2d 00 00       	call   80ee80 <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80c132:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c136:	74 47                	je     80c17f <recv_tcp+0xc2>
    return ERR_VAL;
  }

  conn->err = err;
  80c138:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80c13b:	85 f6                	test   %esi,%esi
  80c13d:	74 09                	je     80c148 <recv_tcp+0x8b>
    len = p->tot_len;
  80c13f:	8b 56 08             	mov    0x8(%esi),%edx
    SYS_ARCH_INC(conn->recv_avail, len);
  80c142:	66 01 53 20          	add    %dx,0x20(%ebx)
  80c146:	eb 05                	jmp    80c14d <recv_tcp+0x90>
  } else {
    len = 0;
  80c148:	ba 00 00 00 00       	mov    $0x0,%edx
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80c14d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c150:	85 c0                	test   %eax,%eax
  80c152:	74 14                	je     80c168 <recv_tcp+0xab>
  80c154:	0f b7 d2             	movzwl %dx,%edx
  80c157:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c15b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c162:	00 
  80c163:	89 1c 24             	mov    %ebx,(%esp)
  80c166:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80c168:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c16c:	8b 43 14             	mov    0x14(%ebx),%eax
  80c16f:	89 04 24             	mov    %eax,(%esp)
  80c172:	e8 c3 e7 ff ff       	call   80a93a <sys_mbox_trypost>
    return ERR_MEM;
  80c177:	3c 01                	cmp    $0x1,%al
  80c179:	19 c0                	sbb    %eax,%eax
  80c17b:	f7 d0                	not    %eax
  80c17d:	eb 02                	jmp    80c181 <recv_tcp+0xc4>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  80c17f:	b0 f7                	mov    $0xf7,%al
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
    return ERR_MEM;
  }

  return ERR_OK;
}
  80c181:	83 c4 10             	add    $0x10,%esp
  80c184:	5b                   	pop    %ebx
  80c185:	5e                   	pop    %esi
  80c186:	5d                   	pop    %ebp
  80c187:	c3                   	ret    

0080c188 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80c188:	55                   	push   %ebp
  80c189:	89 e5                	mov    %esp,%ebp
  80c18b:	57                   	push   %edi
  80c18c:	56                   	push   %esi
  80c18d:	53                   	push   %ebx
  80c18e:	83 ec 1c             	sub    $0x1c,%esp
  80c191:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c194:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c197:	8b 7d 18             	mov    0x18(%ebp),%edi
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80c19a:	85 c0                	test   %eax,%eax
  80c19c:	75 1c                	jne    80c1ba <recv_udp+0x32>
  80c19e:	c7 44 24 08 f4 3a 81 	movl   $0x813af4,0x8(%esp)
  80c1a5:	00 
  80c1a6:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80c1ad:	00 
  80c1ae:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c1b5:	e8 c6 2c 00 00       	call   80ee80 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80c1ba:	85 db                	test   %ebx,%ebx
  80c1bc:	75 1c                	jne    80c1da <recv_udp+0x52>
  80c1be:	c7 44 24 08 18 3b 81 	movl   $0x813b18,0x8(%esp)
  80c1c5:	00 
  80c1c6:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80c1cd:	00 
  80c1ce:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c1d5:	e8 a6 2c 00 00       	call   80ee80 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80c1da:	39 43 08             	cmp    %eax,0x8(%ebx)
  80c1dd:	74 1c                	je     80c1fb <recv_udp+0x73>
  80c1df:	c7 44 24 08 49 3a 81 	movl   $0x813a49,0x8(%esp)
  80c1e6:	00 
  80c1e7:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80c1ee:	00 
  80c1ef:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c1f6:	e8 85 2c 00 00       	call   80ee80 <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80c1fb:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c1ff:	75 0d                	jne    80c20e <recv_udp+0x86>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80c201:	8b 45 10             	mov    0x10(%ebp),%eax
  80c204:	89 04 24             	mov    %eax,(%esp)
  80c207:	e8 45 8b ff ff       	call   804d51 <pbuf_free>
    return;
  80c20c:	eb 6f                	jmp    80c27d <recv_udp+0xf5>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80c20e:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80c215:	e8 4c 87 ff ff       	call   804966 <memp_malloc>
  80c21a:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80c21c:	85 c0                	test   %eax,%eax
  80c21e:	75 0d                	jne    80c22d <recv_udp+0xa5>
    pbuf_free(p);
  80c220:	8b 55 10             	mov    0x10(%ebp),%edx
  80c223:	89 14 24             	mov    %edx,(%esp)
  80c226:	e8 26 8b ff ff       	call   804d51 <pbuf_free>
    return;
  80c22b:	eb 50                	jmp    80c27d <recv_udp+0xf5>
  } else {
    buf->p = p;
  80c22d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80c230:	89 08                	mov    %ecx,(%eax)
    buf->ptr = p;
  80c232:	89 48 04             	mov    %ecx,0x4(%eax)
    buf->addr = addr;
  80c235:	8b 45 14             	mov    0x14(%ebp),%eax
  80c238:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80c23b:	66 89 7e 0c          	mov    %di,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80c23f:	8b 41 08             	mov    0x8(%ecx),%eax
  80c242:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80c246:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c249:	85 c0                	test   %eax,%eax
  80c24b:	74 15                	je     80c262 <recv_udp+0xda>
  80c24d:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
  80c251:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c255:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c25c:	00 
  80c25d:	89 1c 24             	mov    %ebx,(%esp)
  80c260:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80c262:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c266:	8b 43 14             	mov    0x14(%ebx),%eax
  80c269:	89 04 24             	mov    %eax,(%esp)
  80c26c:	e8 c9 e6 ff ff       	call   80a93a <sys_mbox_trypost>
  80c271:	84 c0                	test   %al,%al
  80c273:	74 08                	je     80c27d <recv_udp+0xf5>
    netbuf_delete(buf);
  80c275:	89 34 24             	mov    %esi,(%esp)
  80c278:	e8 67 65 ff ff       	call   8027e4 <netbuf_delete>
    return;
  }
}
  80c27d:	83 c4 1c             	add    $0x1c,%esp
  80c280:	5b                   	pop    %ebx
  80c281:	5e                   	pop    %esi
  80c282:	5f                   	pop    %edi
  80c283:	5d                   	pop    %ebp
  80c284:	c3                   	ret    

0080c285 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80c285:	55                   	push   %ebp
  80c286:	89 e5                	mov    %esp,%ebp
  80c288:	57                   	push   %edi
  80c289:	56                   	push   %esi
  80c28a:	53                   	push   %ebx
  80c28b:	83 ec 1c             	sub    $0x1c,%esp
  80c28e:	8b 75 08             	mov    0x8(%ebp),%esi
  80c291:	8b 7d 10             	mov    0x10(%ebp),%edi
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80c294:	85 f6                	test   %esi,%esi
  80c296:	0f 84 a7 00 00 00    	je     80c343 <recv_raw+0xbe>
  80c29c:	83 7e 14 ff          	cmpl   $0xffffffff,0x14(%esi)
  80c2a0:	0f 84 9d 00 00 00    	je     80c343 <recv_raw+0xbe>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80c2a6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c2ad:	00 
  80c2ae:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80c2b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c2b6:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80c2bd:	e8 90 8c ff ff       	call   804f52 <pbuf_alloc>
  80c2c2:	89 c3                	mov    %eax,%ebx
    if(q != NULL) {
  80c2c4:	85 c0                	test   %eax,%eax
  80c2c6:	74 7b                	je     80c343 <recv_raw+0xbe>
      if (pbuf_copy(q, p) != ERR_OK) {
  80c2c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80c2cc:	89 04 24             	mov    %eax,(%esp)
  80c2cf:	e8 65 90 ff ff       	call   805339 <pbuf_copy>
  80c2d4:	84 c0                	test   %al,%al
  80c2d6:	74 75                	je     80c34d <recv_raw+0xc8>
        pbuf_free(q);
  80c2d8:	89 1c 24             	mov    %ebx,(%esp)
  80c2db:	e8 71 8a ff ff       	call   804d51 <pbuf_free>
  80c2e0:	eb 61                	jmp    80c343 <recv_raw+0xbe>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80c2e2:	89 1c 24             	mov    %ebx,(%esp)
  80c2e5:	e8 67 8a ff ff       	call   804d51 <pbuf_free>
        return 0;
  80c2ea:	eb 57                	jmp    80c343 <recv_raw+0xbe>
      }

      buf->p = q;
  80c2ec:	89 1f                	mov    %ebx,(%edi)
      buf->ptr = q;
  80c2ee:	89 5f 04             	mov    %ebx,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80c2f1:	8b 43 04             	mov    0x4(%ebx),%eax
  80c2f4:	83 c0 0c             	add    $0xc,%eax
  80c2f7:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80c2fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c2fd:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80c301:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80c305:	8b 43 08             	mov    0x8(%ebx),%eax
  80c308:	66 01 46 20          	add    %ax,0x20(%esi)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80c30c:	8b 46 2c             	mov    0x2c(%esi),%eax
  80c30f:	85 c0                	test   %eax,%eax
  80c311:	74 15                	je     80c328 <recv_raw+0xa3>
  80c313:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  80c317:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c31b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c322:	00 
  80c323:	89 34 24             	mov    %esi,(%esp)
  80c326:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80c328:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80c32c:	8b 46 14             	mov    0x14(%esi),%eax
  80c32f:	89 04 24             	mov    %eax,(%esp)
  80c332:	e8 03 e6 ff ff       	call   80a93a <sys_mbox_trypost>
  80c337:	84 c0                	test   %al,%al
  80c339:	74 08                	je     80c343 <recv_raw+0xbe>
        netbuf_delete(buf);
  80c33b:	89 3c 24             	mov    %edi,(%esp)
  80c33e:	e8 a1 64 ff ff       	call   8027e4 <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80c343:	b0 00                	mov    $0x0,%al
  80c345:	83 c4 1c             	add    $0x1c,%esp
  80c348:	5b                   	pop    %ebx
  80c349:	5e                   	pop    %esi
  80c34a:	5f                   	pop    %edi
  80c34b:	5d                   	pop    %ebp
  80c34c:	c3                   	ret    
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80c34d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80c354:	e8 0d 86 ff ff       	call   804966 <memp_malloc>
  80c359:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80c35b:	85 c0                	test   %eax,%eax
  80c35d:	75 8d                	jne    80c2ec <recv_raw+0x67>
  80c35f:	eb 81                	jmp    80c2e2 <recv_raw+0x5d>

0080c361 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80c361:	55                   	push   %ebp
  80c362:	89 e5                	mov    %esp,%ebp
  80c364:	56                   	push   %esi
  80c365:	53                   	push   %ebx
  80c366:	83 ec 10             	sub    $0x10,%esp
  80c369:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80c36c:	8b 03                	mov    (%ebx),%eax
  80c36e:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c372:	0f 85 d4 00 00 00    	jne    80c44c <do_newconn+0xeb>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80c378:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80c37c:	8b 33                	mov    (%ebx),%esi
  80c37e:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80c382:	74 1c                	je     80c3a0 <do_newconn+0x3f>
  80c384:	c7 44 24 08 38 3b 81 	movl   $0x813b38,0x8(%esp)
  80c38b:	00 
  80c38c:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80c393:	00 
  80c394:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c39b:	e8 e0 2a 00 00       	call   80ee80 <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80c3a0:	8b 06                	mov    (%esi),%eax
  80c3a2:	25 f0 00 00 00       	and    $0xf0,%eax
  80c3a7:	83 f8 20             	cmp    $0x20,%eax
  80c3aa:	74 44                	je     80c3f0 <do_newconn+0x8f>
  80c3ac:	83 f8 40             	cmp    $0x40,%eax
  80c3af:	74 0b                	je     80c3bc <do_newconn+0x5b>
  80c3b1:	83 f8 10             	cmp    $0x10,%eax
  80c3b4:	0f 85 8e 00 00 00    	jne    80c448 <do_newconn+0xe7>
  80c3ba:	eb 6f                	jmp    80c42b <do_newconn+0xca>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80c3bc:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80c3c0:	89 04 24             	mov    %eax,(%esp)
  80c3c3:	e8 6a 24 00 00       	call   80e832 <raw_new>
  80c3c8:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80c3cb:	8b 03                	mov    (%ebx),%eax
  80c3cd:	8b 50 08             	mov    0x8(%eax),%edx
  80c3d0:	85 d2                	test   %edx,%edx
  80c3d2:	75 06                	jne    80c3da <do_newconn+0x79>
       msg->conn->err = ERR_MEM;
  80c3d4:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c3d8:	eb 72                	jmp    80c44c <do_newconn+0xeb>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80c3da:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c3de:	c7 44 24 04 85 c2 80 	movl   $0x80c285,0x4(%esp)
  80c3e5:	00 
  80c3e6:	89 14 24             	mov    %edx,(%esp)
  80c3e9:	e8 c4 22 00 00       	call   80e6b2 <raw_recv>
  80c3ee:	eb 5c                	jmp    80c44c <do_newconn+0xeb>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80c3f0:	e8 d1 d2 ff ff       	call   8096c6 <udp_new>
  80c3f5:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80c3f8:	8b 03                	mov    (%ebx),%eax
  80c3fa:	8b 50 08             	mov    0x8(%eax),%edx
  80c3fd:	85 d2                	test   %edx,%edx
  80c3ff:	75 06                	jne    80c407 <do_newconn+0xa6>
       msg->conn->err = ERR_MEM;
  80c401:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c405:	eb 45                	jmp    80c44c <do_newconn+0xeb>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80c407:	83 38 22             	cmpl   $0x22,(%eax)
  80c40a:	75 04                	jne    80c410 <do_newconn+0xaf>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80c40c:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80c410:	8b 03                	mov    (%ebx),%eax
  80c412:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c416:	c7 44 24 04 88 c1 80 	movl   $0x80c188,0x4(%esp)
  80c41d:	00 
  80c41e:	8b 40 08             	mov    0x8(%eax),%eax
  80c421:	89 04 24             	mov    %eax,(%esp)
  80c424:	e8 43 d2 ff ff       	call   80966c <udp_recv>
  80c429:	eb 21                	jmp    80c44c <do_newconn+0xeb>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80c42b:	e8 b2 a3 ff ff       	call   8067e2 <tcp_new>
  80c430:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80c433:	8b 03                	mov    (%ebx),%eax
  80c435:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c439:	75 06                	jne    80c441 <do_newconn+0xe0>
       msg->conn->err = ERR_MEM;
  80c43b:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c43f:	eb 0b                	jmp    80c44c <do_newconn+0xeb>
       break;
     }
     setup_tcp(msg->conn);
  80c441:	e8 ae f6 ff ff       	call   80baf4 <setup_tcp>
  80c446:	eb 04                	jmp    80c44c <do_newconn+0xeb>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80c448:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80c44c:	8b 03                	mov    (%ebx),%eax
  80c44e:	8b 40 10             	mov    0x10(%eax),%eax
  80c451:	89 04 24             	mov    %eax,(%esp)
  80c454:	e8 68 e3 ff ff       	call   80a7c1 <sys_sem_signal>
}
  80c459:	83 c4 10             	add    $0x10,%esp
  80c45c:	5b                   	pop    %ebx
  80c45d:	5e                   	pop    %esi
  80c45e:	5d                   	pop    %ebp
  80c45f:	c3                   	ret    

0080c460 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80c460:	55                   	push   %ebp
  80c461:	89 e5                	mov    %esp,%ebp
  80c463:	53                   	push   %ebx
  80c464:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80c467:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c46e:	e8 f3 84 ff ff       	call   804966 <memp_malloc>
  80c473:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80c475:	85 c0                	test   %eax,%eax
  80c477:	0f 84 92 00 00 00    	je     80c50f <netconn_alloc+0xaf>
    return NULL;
  }

  conn->err = ERR_OK;
  80c47d:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80c481:	8b 45 08             	mov    0x8(%ebp),%eax
  80c484:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80c486:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80c48d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c494:	e8 1a e0 ff ff       	call   80a4b3 <sys_sem_new>
  80c499:	89 43 10             	mov    %eax,0x10(%ebx)
  80c49c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c49f:	75 17                	jne    80c4b8 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80c4a1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c4a5:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c4ac:	e8 15 85 ff ff       	call   8049c6 <memp_free>
    return NULL;
  80c4b1:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c4b6:	eb 57                	jmp    80c50f <netconn_alloc+0xaf>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80c4b8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c4bf:	e8 c8 e1 ff ff       	call   80a68c <sys_mbox_new>
  80c4c4:	89 43 14             	mov    %eax,0x14(%ebx)
  80c4c7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c4ca:	75 22                	jne    80c4ee <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80c4cc:	8b 43 10             	mov    0x10(%ebx),%eax
  80c4cf:	89 04 24             	mov    %eax,(%esp)
  80c4d2:	e8 78 e0 ff ff       	call   80a54f <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80c4d7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c4db:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c4e2:	e8 df 84 ff ff       	call   8049c6 <memp_free>
    return NULL;
  80c4e7:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c4ec:	eb 21                	jmp    80c50f <netconn_alloc+0xaf>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80c4ee:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80c4f5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80c4fc:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80c503:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c506:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80c509:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80c50f:	89 d8                	mov    %ebx,%eax
  80c511:	83 c4 14             	add    $0x14,%esp
  80c514:	5b                   	pop    %ebx
  80c515:	5d                   	pop    %ebp
  80c516:	c3                   	ret    

0080c517 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80c517:	55                   	push   %ebp
  80c518:	89 e5                	mov    %esp,%ebp
  80c51a:	56                   	push   %esi
  80c51b:	53                   	push   %ebx
  80c51c:	83 ec 20             	sub    $0x20,%esp
  80c51f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80c522:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c526:	74 1c                	je     80c544 <netconn_free+0x2d>
  80c528:	c7 44 24 08 58 3b 81 	movl   $0x813b58,0x8(%esp)
  80c52f:	00 
  80c530:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80c537:	00 
  80c538:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c53f:	e8 3c 29 00 00       	call   80ee80 <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80c544:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c548:	75 25                	jne    80c56f <netconn_free+0x58>
  80c54a:	eb 4c                	jmp    80c598 <netconn_free+0x81>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80c54c:	83 3b 10             	cmpl   $0x10,(%ebx)
  80c54f:	75 11                	jne    80c562 <netconn_free+0x4b>
        if(mem != NULL) {
  80c551:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c554:	85 c0                	test   %eax,%eax
  80c556:	74 1a                	je     80c572 <netconn_free+0x5b>
          pbuf_free((struct pbuf *)mem);
  80c558:	89 04 24             	mov    %eax,(%esp)
  80c55b:	e8 f1 87 ff ff       	call   804d51 <pbuf_free>
  80c560:	eb 10                	jmp    80c572 <netconn_free+0x5b>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80c562:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c565:	89 04 24             	mov    %eax,(%esp)
  80c568:	e8 77 62 ff ff       	call   8027e4 <netbuf_delete>
  80c56d:	eb 03                	jmp    80c572 <netconn_free+0x5b>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80c56f:	8d 75 f4             	lea    -0xc(%ebp),%esi
  80c572:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c576:	8b 43 14             	mov    0x14(%ebx),%eax
  80c579:	89 04 24             	mov    %eax,(%esp)
  80c57c:	e8 f7 e5 ff ff       	call   80ab78 <sys_arch_mbox_tryfetch>
  80c581:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c584:	75 c6                	jne    80c54c <netconn_free+0x35>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80c586:	8b 43 14             	mov    0x14(%ebx),%eax
  80c589:	89 04 24             	mov    %eax,(%esp)
  80c58c:	e8 32 e0 ff ff       	call   80a5c3 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80c591:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80c598:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c59c:	75 0f                	jne    80c5ad <netconn_free+0x96>
  80c59e:	eb 36                	jmp    80c5d6 <netconn_free+0xbf>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80c5a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c5a3:	89 04 24             	mov    %eax,(%esp)
  80c5a6:	e8 99 ef ff ff       	call   80b544 <netconn_delete>
  80c5ab:	eb 03                	jmp    80c5b0 <netconn_free+0x99>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c5ad:	8d 75 f4             	lea    -0xc(%ebp),%esi
  80c5b0:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c5b4:	8b 43 18             	mov    0x18(%ebx),%eax
  80c5b7:	89 04 24             	mov    %eax,(%esp)
  80c5ba:	e8 b9 e5 ff ff       	call   80ab78 <sys_arch_mbox_tryfetch>
  80c5bf:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c5c2:	75 dc                	jne    80c5a0 <netconn_free+0x89>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80c5c4:	8b 43 18             	mov    0x18(%ebx),%eax
  80c5c7:	89 04 24             	mov    %eax,(%esp)
  80c5ca:	e8 f4 df ff ff       	call   80a5c3 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80c5cf:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80c5d6:	8b 43 10             	mov    0x10(%ebx),%eax
  80c5d9:	89 04 24             	mov    %eax,(%esp)
  80c5dc:	e8 6e df ff ff       	call   80a54f <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80c5e1:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80c5e8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c5ec:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c5f3:	e8 ce 83 ff ff       	call   8049c6 <memp_free>
}
  80c5f8:	83 c4 20             	add    $0x20,%esp
  80c5fb:	5b                   	pop    %ebx
  80c5fc:	5e                   	pop    %esi
  80c5fd:	5d                   	pop    %ebp
  80c5fe:	c3                   	ret    

0080c5ff <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80c5ff:	55                   	push   %ebp
  80c600:	89 e5                	mov    %esp,%ebp
  80c602:	56                   	push   %esi
  80c603:	53                   	push   %ebx
  80c604:	83 ec 20             	sub    $0x20,%esp
  80c607:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c60a:	8a 45 10             	mov    0x10(%ebp),%al
  80c60d:	88 45 f7             	mov    %al,-0x9(%ebp)
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80c610:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c614:	75 1c                	jne    80c632 <accept_function+0x33>
  80c616:	c7 44 24 08 88 3b 81 	movl   $0x813b88,0x8(%esp)
  80c61d:	00 
  80c61e:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80c625:	00 
  80c626:	c7 04 24 85 39 81 00 	movl   $0x813985,(%esp)
  80c62d:	e8 4e 28 00 00       	call   80ee80 <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80c632:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c635:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c639:	8b 03                	mov    (%ebx),%eax
  80c63b:	89 04 24             	mov    %eax,(%esp)
  80c63e:	e8 1d fe ff ff       	call   80c460 <netconn_alloc>
  80c643:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80c645:	85 c0                	test   %eax,%eax
  80c647:	74 55                	je     80c69e <accept_function+0x9f>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80c649:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c64c:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80c64f:	89 f0                	mov    %esi,%eax
  80c651:	e8 9e f4 ff ff       	call   80baf4 <setup_tcp>
  newconn->err = err;
  80c656:	8a 45 f7             	mov    -0x9(%ebp),%al
  80c659:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c65c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c65f:	85 c0                	test   %eax,%eax
  80c661:	74 15                	je     80c678 <accept_function+0x79>
  80c663:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c66a:	00 
  80c66b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c672:	00 
  80c673:	89 1c 24             	mov    %ebx,(%esp)
  80c676:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80c678:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c67c:	8b 43 18             	mov    0x18(%ebx),%eax
  80c67f:	89 04 24             	mov    %eax,(%esp)
  80c682:	e8 b3 e2 ff ff       	call   80a93a <sys_mbox_trypost>
  80c687:	84 c0                	test   %al,%al
  80c689:	74 17                	je     80c6a2 <accept_function+0xa3>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80c68b:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80c692:	89 34 24             	mov    %esi,(%esp)
  80c695:	e8 7d fe ff ff       	call   80c517 <netconn_free>
    return ERR_MEM;
  80c69a:	b0 ff                	mov    $0xff,%al
  80c69c:	eb 06                	jmp    80c6a4 <accept_function+0xa5>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
  80c69e:	b0 ff                	mov    $0xff,%al
  80c6a0:	eb 02                	jmp    80c6a4 <accept_function+0xa5>
       so do nothing here! */
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
  80c6a2:	b0 00                	mov    $0x0,%al
}
  80c6a4:	83 c4 20             	add    $0x20,%esp
  80c6a7:	5b                   	pop    %ebx
  80c6a8:	5e                   	pop    %esi
  80c6a9:	5d                   	pop    %ebp
  80c6aa:	c3                   	ret    

0080c6ab <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80c6ab:	55                   	push   %ebp
  80c6ac:	89 e5                	mov    %esp,%ebp
  80c6ae:	53                   	push   %ebx
  80c6af:	83 ec 14             	sub    $0x14,%esp
  80c6b2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80c6b5:	8b 03                	mov    (%ebx),%eax
  80c6b7:	8b 48 08             	mov    0x8(%eax),%ecx
  80c6ba:	85 c9                	test   %ecx,%ecx
  80c6bc:	74 49                	je     80c707 <do_delconn+0x5c>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c6be:	8b 10                	mov    (%eax),%edx
  80c6c0:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c6c6:	83 fa 20             	cmp    $0x20,%edx
  80c6c9:	74 16                	je     80c6e1 <do_delconn+0x36>
  80c6cb:	83 fa 40             	cmp    $0x40,%edx
  80c6ce:	74 07                	je     80c6d7 <do_delconn+0x2c>
  80c6d0:	83 fa 10             	cmp    $0x10,%edx
  80c6d3:	75 32                	jne    80c707 <do_delconn+0x5c>
  80c6d5:	eb 20                	jmp    80c6f7 <do_delconn+0x4c>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80c6d7:	89 0c 24             	mov    %ecx,(%esp)
  80c6da:	e8 0d 21 00 00       	call   80e7ec <raw_remove>
      break;
  80c6df:	eb 26                	jmp    80c707 <do_delconn+0x5c>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80c6e1:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80c6e8:	8b 03                	mov    (%ebx),%eax
  80c6ea:	8b 40 08             	mov    0x8(%eax),%eax
  80c6ed:	89 04 24             	mov    %eax,(%esp)
  80c6f0:	e8 8b cf ff ff       	call   809680 <udp_remove>
      break;
  80c6f5:	eb 10                	jmp    80c707 <do_delconn+0x5c>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80c6f7:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c6fe:	8b 03                	mov    (%ebx),%eax
  80c700:	e8 95 f4 ff ff       	call   80bb9a <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80c705:	eb 4e                	jmp    80c755 <do_delconn+0xaa>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80c707:	8b 13                	mov    (%ebx),%edx
  80c709:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c70c:	85 c0                	test   %eax,%eax
  80c70e:	74 33                	je     80c743 <do_delconn+0x98>
  80c710:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c717:	00 
  80c718:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c71f:	00 
  80c720:	89 14 24             	mov    %edx,(%esp)
  80c723:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80c725:	8b 13                	mov    (%ebx),%edx
  80c727:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c72a:	85 c0                	test   %eax,%eax
  80c72c:	74 15                	je     80c743 <do_delconn+0x98>
  80c72e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c735:	00 
  80c736:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c73d:	00 
  80c73e:	89 14 24             	mov    %edx,(%esp)
  80c741:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80c743:	8b 03                	mov    (%ebx),%eax
  80c745:	8b 40 10             	mov    0x10(%eax),%eax
  80c748:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c74b:	74 08                	je     80c755 <do_delconn+0xaa>
    sys_sem_signal(msg->conn->op_completed);
  80c74d:	89 04 24             	mov    %eax,(%esp)
  80c750:	e8 6c e0 ff ff       	call   80a7c1 <sys_sem_signal>
  }
}
  80c755:	83 c4 14             	add    $0x14,%esp
  80c758:	5b                   	pop    %ebx
  80c759:	5d                   	pop    %ebp
  80c75a:	c3                   	ret    

0080c75b <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80c75b:	55                   	push   %ebp
  80c75c:	89 e5                	mov    %esp,%ebp
  80c75e:	56                   	push   %esi
  80c75f:	53                   	push   %ebx
  80c760:	83 ec 10             	sub    $0x10,%esp
  80c763:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c766:	8b 1e                	mov    (%esi),%ebx
  80c768:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80c76c:	7c 6f                	jl     80c7dd <do_bind+0x82>
    if (msg->conn->pcb.tcp != NULL) {
  80c76e:	8b 53 08             	mov    0x8(%ebx),%edx
  80c771:	85 d2                	test   %edx,%edx
  80c773:	74 64                	je     80c7d9 <do_bind+0x7e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c775:	8b 03                	mov    (%ebx),%eax
  80c777:	25 f0 00 00 00       	and    $0xf0,%eax
  80c77c:	83 f8 20             	cmp    $0x20,%eax
  80c77f:	74 20                	je     80c7a1 <do_bind+0x46>
  80c781:	83 f8 40             	cmp    $0x40,%eax
  80c784:	74 07                	je     80c78d <do_bind+0x32>
  80c786:	83 f8 10             	cmp    $0x10,%eax
  80c789:	75 52                	jne    80c7dd <do_bind+0x82>
  80c78b:	eb 30                	jmp    80c7bd <do_bind+0x62>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c78d:	8b 46 04             	mov    0x4(%esi),%eax
  80c790:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c794:	89 14 24             	mov    %edx,(%esp)
  80c797:	e8 dd 1e 00 00       	call   80e679 <raw_bind>
  80c79c:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80c79f:	eb 3c                	jmp    80c7dd <do_bind+0x82>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c7a1:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c7a5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c7a9:	8b 46 04             	mov    0x4(%esi),%eax
  80c7ac:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c7b0:	89 14 24             	mov    %edx,(%esp)
  80c7b3:	e8 46 cb ff ff       	call   8092fe <udp_bind>
  80c7b8:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80c7bb:	eb 20                	jmp    80c7dd <do_bind+0x82>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c7bd:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c7c1:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c7c5:	8b 46 04             	mov    0x4(%esi),%eax
  80c7c8:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c7cc:	89 14 24             	mov    %edx,(%esp)
  80c7cf:	e8 6a 91 ff ff       	call   80593e <tcp_bind>
  80c7d4:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80c7d7:	eb 04                	jmp    80c7dd <do_bind+0x82>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80c7d9:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c7dd:	8b 06                	mov    (%esi),%eax
  80c7df:	8b 40 10             	mov    0x10(%eax),%eax
  80c7e2:	89 04 24             	mov    %eax,(%esp)
  80c7e5:	e8 d7 df ff ff       	call   80a7c1 <sys_sem_signal>
}
  80c7ea:	83 c4 10             	add    $0x10,%esp
  80c7ed:	5b                   	pop    %ebx
  80c7ee:	5e                   	pop    %esi
  80c7ef:	5d                   	pop    %ebp
  80c7f0:	c3                   	ret    

0080c7f1 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80c7f1:	55                   	push   %ebp
  80c7f2:	89 e5                	mov    %esp,%ebp
  80c7f4:	56                   	push   %esi
  80c7f5:	53                   	push   %ebx
  80c7f6:	83 ec 10             	sub    $0x10,%esp
  80c7f9:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  80c7fc:	8b 1e                	mov    (%esi),%ebx
  80c7fe:	8b 53 08             	mov    0x8(%ebx),%edx
  80c801:	85 d2                	test   %edx,%edx
  80c803:	75 10                	jne    80c815 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80c805:	8b 43 10             	mov    0x10(%ebx),%eax
  80c808:	89 04 24             	mov    %eax,(%esp)
  80c80b:	e8 b1 df ff ff       	call   80a7c1 <sys_sem_signal>
    return;
  80c810:	e9 9b 00 00 00       	jmp    80c8b0 <do_connect+0xbf>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c815:	8b 03                	mov    (%ebx),%eax
  80c817:	25 f0 00 00 00       	and    $0xf0,%eax
  80c81c:	83 f8 20             	cmp    $0x20,%eax
  80c81f:	74 31                	je     80c852 <do_connect+0x61>
  80c821:	83 f8 40             	cmp    $0x40,%eax
  80c824:	74 0b                	je     80c831 <do_connect+0x40>
  80c826:	83 f8 10             	cmp    $0x10,%eax
  80c829:	0f 85 81 00 00 00    	jne    80c8b0 <do_connect+0xbf>
  80c82f:	eb 4a                	jmp    80c87b <do_connect+0x8a>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c831:	8b 46 04             	mov    0x4(%esi),%eax
  80c834:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c838:	89 14 24             	mov    %edx,(%esp)
  80c83b:	e8 55 1e 00 00       	call   80e695 <raw_connect>
  80c840:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80c843:	8b 06                	mov    (%esi),%eax
  80c845:	8b 40 10             	mov    0x10(%eax),%eax
  80c848:	89 04 24             	mov    %eax,(%esp)
  80c84b:	e8 71 df ff ff       	call   80a7c1 <sys_sem_signal>
    break;
  80c850:	eb 5e                	jmp    80c8b0 <do_connect+0xbf>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c852:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c856:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c85a:	8b 46 04             	mov    0x4(%esi),%eax
  80c85d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c861:	89 14 24             	mov    %edx,(%esp)
  80c864:	e8 75 cd ff ff       	call   8095de <udp_connect>
  80c869:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80c86c:	8b 06                	mov    (%esi),%eax
  80c86e:	8b 40 10             	mov    0x10(%eax),%eax
  80c871:	89 04 24             	mov    %eax,(%esp)
  80c874:	e8 48 df ff ff       	call   80a7c1 <sys_sem_signal>
    break;
  80c879:	eb 35                	jmp    80c8b0 <do_connect+0xbf>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80c87b:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%ebx)
    setup_tcp(msg->conn);
  80c882:	8b 06                	mov    (%esi),%eax
  80c884:	e8 6b f2 ff ff       	call   80baf4 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80c889:	8b 1e                	mov    (%esi),%ebx
  80c88b:	c7 44 24 0c 58 bb 80 	movl   $0x80bb58,0xc(%esp)
  80c892:	00 
  80c893:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c897:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c89b:	8b 46 04             	mov    0x4(%esi),%eax
  80c89e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c8a2:	8b 43 08             	mov    0x8(%ebx),%eax
  80c8a5:	89 04 24             	mov    %eax,(%esp)
  80c8a8:	e8 7c 9f ff ff       	call   806829 <tcp_connect>
  80c8ad:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80c8b0:	83 c4 10             	add    $0x10,%esp
  80c8b3:	5b                   	pop    %ebx
  80c8b4:	5e                   	pop    %esi
  80c8b5:	5d                   	pop    %ebp
  80c8b6:	c3                   	ret    

0080c8b7 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80c8b7:	55                   	push   %ebp
  80c8b8:	89 e5                	mov    %esp,%ebp
  80c8ba:	53                   	push   %ebx
  80c8bb:	83 ec 14             	sub    $0x14,%esp
  80c8be:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80c8c1:	8b 03                	mov    (%ebx),%eax
  80c8c3:	8b 10                	mov    (%eax),%edx
  80c8c5:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c8cb:	83 fa 20             	cmp    $0x20,%edx
  80c8ce:	75 0b                	jne    80c8db <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80c8d0:	8b 40 08             	mov    0x8(%eax),%eax
  80c8d3:	89 04 24             	mov    %eax,(%esp)
  80c8d6:	e8 76 cd ff ff       	call   809651 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80c8db:	8b 03                	mov    (%ebx),%eax
  80c8dd:	8b 40 10             	mov    0x10(%eax),%eax
  80c8e0:	89 04 24             	mov    %eax,(%esp)
  80c8e3:	e8 d9 de ff ff       	call   80a7c1 <sys_sem_signal>
}
  80c8e8:	83 c4 14             	add    $0x14,%esp
  80c8eb:	5b                   	pop    %ebx
  80c8ec:	5d                   	pop    %ebp
  80c8ed:	c3                   	ret    

0080c8ee <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80c8ee:	55                   	push   %ebp
  80c8ef:	89 e5                	mov    %esp,%ebp
  80c8f1:	57                   	push   %edi
  80c8f2:	56                   	push   %esi
  80c8f3:	53                   	push   %ebx
  80c8f4:	83 ec 1c             	sub    $0x1c,%esp
  80c8f7:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c8fa:	8b 06                	mov    (%esi),%eax
  80c8fc:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c900:	0f 8c b9 00 00 00    	jl     80c9bf <do_listen+0xd1>
    if (msg->conn->pcb.tcp != NULL) {
  80c906:	8b 50 08             	mov    0x8(%eax),%edx
  80c909:	85 d2                	test   %edx,%edx
  80c90b:	0f 84 ae 00 00 00    	je     80c9bf <do_listen+0xd1>
      if (msg->conn->type == NETCONN_TCP) {
  80c911:	83 38 10             	cmpl   $0x10,(%eax)
  80c914:	0f 85 a5 00 00 00    	jne    80c9bf <do_listen+0xd1>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80c91a:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80c91e:	0f 85 97 00 00 00    	jne    80c9bb <do_listen+0xcd>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80c924:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80c92b:	00 
  80c92c:	89 14 24             	mov    %edx,(%esp)
  80c92f:	e8 94 91 ff ff       	call   805ac8 <tcp_listen_with_backlog>
  80c934:	89 c7                	mov    %eax,%edi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80c936:	85 c0                	test   %eax,%eax
  80c938:	75 08                	jne    80c942 <do_listen+0x54>
            msg->conn->err = ERR_MEM;
  80c93a:	8b 06                	mov    (%esi),%eax
  80c93c:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c940:	eb 7d                	jmp    80c9bf <do_listen+0xd1>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80c942:	8b 06                	mov    (%esi),%eax
  80c944:	8b 40 14             	mov    0x14(%eax),%eax
  80c947:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c94a:	74 11                	je     80c95d <do_listen+0x6f>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80c94c:	89 04 24             	mov    %eax,(%esp)
  80c94f:	e8 6f dc ff ff       	call   80a5c3 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c954:	8b 06                	mov    (%esi),%eax
  80c956:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80c95d:	8b 1e                	mov    (%esi),%ebx
  80c95f:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c963:	75 1a                	jne    80c97f <do_listen+0x91>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c965:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c96c:	e8 1b dd ff ff       	call   80a68c <sys_mbox_new>
  80c971:	89 43 18             	mov    %eax,0x18(%ebx)
  80c974:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c977:	75 06                	jne    80c97f <do_listen+0x91>
                msg->conn->err = ERR_MEM;
  80c979:	8b 06                	mov    (%esi),%eax
  80c97b:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80c97f:	8b 06                	mov    (%esi),%eax
  80c981:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c985:	75 38                	jne    80c9bf <do_listen+0xd1>
              msg->conn->state = NETCONN_LISTEN;
  80c987:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80c98e:	8b 06                	mov    (%esi),%eax
  80c990:	89 78 08             	mov    %edi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80c993:	8b 06                	mov    (%esi),%eax
  80c995:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c999:	8b 40 08             	mov    0x8(%eax),%eax
  80c99c:	89 04 24             	mov    %eax,(%esp)
  80c99f:	e8 e6 93 ff ff       	call   805d8a <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80c9a4:	c7 44 24 04 ff c5 80 	movl   $0x80c5ff,0x4(%esp)
  80c9ab:	00 
  80c9ac:	8b 06                	mov    (%esi),%eax
  80c9ae:	8b 40 08             	mov    0x8(%eax),%eax
  80c9b1:	89 04 24             	mov    %eax,(%esp)
  80c9b4:	e8 12 94 ff ff       	call   805dcb <tcp_accept>
  80c9b9:	eb 04                	jmp    80c9bf <do_listen+0xd1>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80c9bb:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80c9bf:	8b 06                	mov    (%esi),%eax
  80c9c1:	8b 40 10             	mov    0x10(%eax),%eax
  80c9c4:	89 04 24             	mov    %eax,(%esp)
  80c9c7:	e8 f5 dd ff ff       	call   80a7c1 <sys_sem_signal>
}
  80c9cc:	83 c4 1c             	add    $0x1c,%esp
  80c9cf:	5b                   	pop    %ebx
  80c9d0:	5e                   	pop    %esi
  80c9d1:	5f                   	pop    %edi
  80c9d2:	5d                   	pop    %ebp
  80c9d3:	c3                   	ret    

0080c9d4 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80c9d4:	55                   	push   %ebp
  80c9d5:	89 e5                	mov    %esp,%ebp
  80c9d7:	57                   	push   %edi
  80c9d8:	56                   	push   %esi
  80c9d9:	53                   	push   %ebx
  80c9da:	83 ec 1c             	sub    $0x1c,%esp
  80c9dd:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c9e0:	8b 1e                	mov    (%esi),%ebx
  80c9e2:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80c9e6:	0f 8c 8b 00 00 00    	jl     80ca77 <do_send+0xa3>
    if (msg->conn->pcb.tcp != NULL) {
  80c9ec:	8b 43 08             	mov    0x8(%ebx),%eax
  80c9ef:	85 c0                	test   %eax,%eax
  80c9f1:	0f 84 80 00 00 00    	je     80ca77 <do_send+0xa3>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c9f7:	8b 13                	mov    (%ebx),%edx
  80c9f9:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c9ff:	83 fa 20             	cmp    $0x20,%edx
  80ca02:	74 39                	je     80ca3d <do_send+0x69>
  80ca04:	83 fa 40             	cmp    $0x40,%edx
  80ca07:	75 6e                	jne    80ca77 <do_send+0xa3>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80ca09:	8b 56 04             	mov    0x4(%esi),%edx
  80ca0c:	8b 4a 08             	mov    0x8(%edx),%ecx
  80ca0f:	85 c9                	test   %ecx,%ecx
  80ca11:	75 13                	jne    80ca26 <do_send+0x52>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80ca13:	8b 12                	mov    (%edx),%edx
  80ca15:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ca19:	89 04 24             	mov    %eax,(%esp)
  80ca1c:	e8 aa 1d 00 00       	call   80e7cb <raw_send>
  80ca21:	88 43 0c             	mov    %al,0xc(%ebx)
  80ca24:	eb 51                	jmp    80ca77 <do_send+0xa3>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80ca26:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ca2a:	8b 12                	mov    (%edx),%edx
  80ca2c:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ca30:	89 04 24             	mov    %eax,(%esp)
  80ca33:	e8 8e 1c 00 00       	call   80e6c6 <raw_sendto>
  80ca38:	88 43 0c             	mov    %al,0xc(%ebx)
  80ca3b:	eb 3a                	jmp    80ca77 <do_send+0xa3>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80ca3d:	8b 56 04             	mov    0x4(%esi),%edx
  80ca40:	8b 4a 08             	mov    0x8(%edx),%ecx
  80ca43:	85 c9                	test   %ecx,%ecx
  80ca45:	75 13                	jne    80ca5a <do_send+0x86>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80ca47:	8b 12                	mov    (%edx),%edx
  80ca49:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ca4d:	89 04 24             	mov    %eax,(%esp)
  80ca50:	e8 60 cb ff ff       	call   8095b5 <udp_send>
  80ca55:	88 43 0c             	mov    %al,0xc(%ebx)
  80ca58:	eb 1d                	jmp    80ca77 <do_send+0xa3>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80ca5a:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80ca5e:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80ca62:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ca66:	8b 12                	mov    (%edx),%edx
  80ca68:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ca6c:	89 04 24             	mov    %eax,(%esp)
  80ca6f:	e8 fb ca ff ff       	call   80956f <udp_sendto>
  80ca74:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80ca77:	8b 06                	mov    (%esi),%eax
  80ca79:	8b 40 10             	mov    0x10(%eax),%eax
  80ca7c:	89 04 24             	mov    %eax,(%esp)
  80ca7f:	e8 3d dd ff ff       	call   80a7c1 <sys_sem_signal>
}
  80ca84:	83 c4 1c             	add    $0x1c,%esp
  80ca87:	5b                   	pop    %ebx
  80ca88:	5e                   	pop    %esi
  80ca89:	5f                   	pop    %edi
  80ca8a:	5d                   	pop    %ebp
  80ca8b:	c3                   	ret    

0080ca8c <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80ca8c:	55                   	push   %ebp
  80ca8d:	89 e5                	mov    %esp,%ebp
  80ca8f:	53                   	push   %ebx
  80ca90:	83 ec 14             	sub    $0x14,%esp
  80ca93:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ca96:	8b 03                	mov    (%ebx),%eax
  80ca98:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80ca9c:	7c 1c                	jl     80caba <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80ca9e:	8b 50 08             	mov    0x8(%eax),%edx
  80caa1:	85 d2                	test   %edx,%edx
  80caa3:	74 15                	je     80caba <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80caa5:	83 38 10             	cmpl   $0x10,(%eax)
  80caa8:	75 10                	jne    80caba <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80caaa:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80caae:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cab2:	89 14 24             	mov    %edx,(%esp)
  80cab5:	e8 09 91 ff ff       	call   805bc3 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80caba:	8b 03                	mov    (%ebx),%eax
  80cabc:	8b 40 10             	mov    0x10(%eax),%eax
  80cabf:	89 04 24             	mov    %eax,(%esp)
  80cac2:	e8 fa dc ff ff       	call   80a7c1 <sys_sem_signal>
}
  80cac7:	83 c4 14             	add    $0x14,%esp
  80caca:	5b                   	pop    %ebx
  80cacb:	5d                   	pop    %ebp
  80cacc:	c3                   	ret    

0080cacd <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80cacd:	55                   	push   %ebp
  80cace:	89 e5                	mov    %esp,%ebp
  80cad0:	83 ec 18             	sub    $0x18,%esp
  80cad3:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cad6:	8b 02                	mov    (%edx),%eax
  80cad8:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80cadc:	7c 2d                	jl     80cb0b <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80cade:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80cae2:	74 23                	je     80cb07 <do_write+0x3a>
  80cae4:	83 38 10             	cmpl   $0x10,(%eax)
  80cae7:	75 1e                	jne    80cb07 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80cae9:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80caf0:	8b 02                	mov    (%edx),%eax
  80caf2:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80caf5:	8b 02                	mov    (%edx),%eax
  80caf7:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80cafe:	8b 02                	mov    (%edx),%eax
  80cb00:	e8 74 f3 ff ff       	call   80be79 <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80cb05:	eb 11                	jmp    80cb18 <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80cb07:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80cb0b:	8b 02                	mov    (%edx),%eax
  80cb0d:	8b 40 10             	mov    0x10(%eax),%eax
  80cb10:	89 04 24             	mov    %eax,(%esp)
  80cb13:	e8 a9 dc ff ff       	call   80a7c1 <sys_sem_signal>
}
  80cb18:	c9                   	leave  
  80cb19:	c3                   	ret    

0080cb1a <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80cb1a:	55                   	push   %ebp
  80cb1b:	89 e5                	mov    %esp,%ebp
  80cb1d:	83 ec 18             	sub    $0x18,%esp
  80cb20:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80cb23:	8b 08                	mov    (%eax),%ecx
  80cb25:	8b 51 08             	mov    0x8(%ecx),%edx
  80cb28:	85 d2                	test   %edx,%edx
  80cb2a:	0f 84 96 00 00 00    	je     80cbc6 <do_getaddr+0xac>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80cb30:	8b 48 04             	mov    0x4(%eax),%ecx
  80cb33:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cb37:	74 06                	je     80cb3f <do_getaddr+0x25>
  80cb39:	8b 12                	mov    (%edx),%edx
  80cb3b:	89 11                	mov    %edx,(%ecx)
  80cb3d:	eb 05                	jmp    80cb44 <do_getaddr+0x2a>
  80cb3f:	8b 52 04             	mov    0x4(%edx),%edx
  80cb42:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80cb44:	8b 08                	mov    (%eax),%ecx
  80cb46:	8b 11                	mov    (%ecx),%edx
  80cb48:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80cb4e:	83 fa 20             	cmp    $0x20,%edx
  80cb51:	74 27                	je     80cb7a <do_getaddr+0x60>
  80cb53:	83 fa 40             	cmp    $0x40,%edx
  80cb56:	74 07                	je     80cb5f <do_getaddr+0x45>
  80cb58:	83 fa 10             	cmp    $0x10,%edx
  80cb5b:	75 6d                	jne    80cbca <do_getaddr+0xb0>
  80cb5d:	eb 4a                	jmp    80cba9 <do_getaddr+0x8f>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80cb5f:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cb63:	74 0f                	je     80cb74 <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80cb65:	8b 50 08             	mov    0x8(%eax),%edx
  80cb68:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cb6b:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80cb6f:	66 89 0a             	mov    %cx,(%edx)
  80cb72:	eb 56                	jmp    80cbca <do_getaddr+0xb0>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80cb74:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80cb78:	eb 50                	jmp    80cbca <do_getaddr+0xb0>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80cb7a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cb7e:	74 0f                	je     80cb8f <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80cb80:	8b 50 08             	mov    0x8(%eax),%edx
  80cb83:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cb86:	66 8b 49 12          	mov    0x12(%ecx),%cx
  80cb8a:	66 89 0a             	mov    %cx,(%edx)
  80cb8d:	eb 3b                	jmp    80cbca <do_getaddr+0xb0>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80cb8f:	8b 51 08             	mov    0x8(%ecx),%edx
  80cb92:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80cb96:	75 06                	jne    80cb9e <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80cb98:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80cb9c:	eb 2c                	jmp    80cbca <do_getaddr+0xb0>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80cb9e:	8b 48 08             	mov    0x8(%eax),%ecx
  80cba1:	8b 52 14             	mov    0x14(%edx),%edx
  80cba4:	66 89 11             	mov    %dx,(%ecx)
  80cba7:	eb 21                	jmp    80cbca <do_getaddr+0xb0>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80cba9:	8b 50 08             	mov    0x8(%eax),%edx
  80cbac:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cbb0:	74 08                	je     80cbba <do_getaddr+0xa0>
  80cbb2:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cbb5:	8b 49 1c             	mov    0x1c(%ecx),%ecx
  80cbb8:	eb 07                	jmp    80cbc1 <do_getaddr+0xa7>
  80cbba:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cbbd:	66 8b 49 1e          	mov    0x1e(%ecx),%cx
  80cbc1:	66 89 0a             	mov    %cx,(%edx)
      break;
  80cbc4:	eb 04                	jmp    80cbca <do_getaddr+0xb0>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80cbc6:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80cbca:	8b 00                	mov    (%eax),%eax
  80cbcc:	8b 40 10             	mov    0x10(%eax),%eax
  80cbcf:	89 04 24             	mov    %eax,(%esp)
  80cbd2:	e8 ea db ff ff       	call   80a7c1 <sys_sem_signal>
}
  80cbd7:	c9                   	leave  
  80cbd8:	c3                   	ret    

0080cbd9 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80cbd9:	55                   	push   %ebp
  80cbda:	89 e5                	mov    %esp,%ebp
  80cbdc:	83 ec 18             	sub    $0x18,%esp
  80cbdf:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80cbe2:	8b 02                	mov    (%edx),%eax
  80cbe4:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80cbe8:	74 15                	je     80cbff <do_close+0x26>
  80cbea:	83 38 10             	cmpl   $0x10,(%eax)
  80cbed:	75 10                	jne    80cbff <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80cbef:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80cbf6:	8b 02                	mov    (%edx),%eax
  80cbf8:	e8 9d ef ff ff       	call   80bb9a <do_close_internal>
  80cbfd:	eb 11                	jmp    80cc10 <do_close+0x37>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80cbff:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80cc03:	8b 02                	mov    (%edx),%eax
  80cc05:	8b 40 10             	mov    0x10(%eax),%eax
  80cc08:	89 04 24             	mov    %eax,(%esp)
  80cc0b:	e8 b1 db ff ff       	call   80a7c1 <sys_sem_signal>
  }
}
  80cc10:	c9                   	leave  
  80cc11:	c3                   	ret    
	...

0080cc14 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80cc14:	55                   	push   %ebp
  80cc15:	89 e5                	mov    %esp,%ebp
  80cc17:	57                   	push   %edi
  80cc18:	56                   	push   %esi
  80cc19:	53                   	push   %ebx
  80cc1a:	83 ec 1c             	sub    $0x1c,%esp
  80cc1d:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80cc1f:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  80cc24:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80cc27:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc2b:	89 04 24             	mov    %eax,(%esp)
  80cc2e:	e8 32 b0 ff ff       	call   807c65 <ntohs>
  80cc33:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80cc37:	77 4e                	ja     80cc87 <tcp_parseopt+0x73>
  80cc39:	eb 74                	jmp    80ccaf <tcp_parseopt+0x9b>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80cc3b:	0f b6 d3             	movzbl %bl,%edx
  80cc3e:	8a 04 16             	mov    (%esi,%edx,1),%al
      if (opt == 0x00) {
  80cc41:	84 c0                	test   %al,%al
  80cc43:	74 6a                	je     80ccaf <tcp_parseopt+0x9b>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80cc45:	3c 01                	cmp    $0x1,%al
  80cc47:	75 03                	jne    80cc4c <tcp_parseopt+0x38>
        ++c;
  80cc49:	43                   	inc    %ebx
  80cc4a:	eb 3d                	jmp    80cc89 <tcp_parseopt+0x75>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80cc4c:	3c 02                	cmp    $0x2,%al
  80cc4e:	75 2b                	jne    80cc7b <tcp_parseopt+0x67>
  80cc50:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80cc55:	75 24                	jne    80cc7b <tcp_parseopt+0x67>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80cc57:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80cc5c:	c1 e0 08             	shl    $0x8,%eax
  80cc5f:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80cc64:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80cc66:	8d 50 ff             	lea    -0x1(%eax),%edx
  80cc69:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  80cc6e:	76 05                	jbe    80cc75 <tcp_parseopt+0x61>
  80cc70:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80cc75:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80cc79:	eb 34                	jmp    80ccaf <tcp_parseopt+0x9b>
      } else {
        if (opts[c + 1] == 0) {
  80cc7b:	8a 44 16 01          	mov    0x1(%esi,%edx,1),%al
  80cc7f:	84 c0                	test   %al,%al
  80cc81:	74 2c                	je     80ccaf <tcp_parseopt+0x9b>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80cc83:	01 c3                	add    %eax,%ebx
  80cc85:	eb 02                	jmp    80cc89 <tcp_parseopt+0x75>
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80cc87:	b3 00                	mov    $0x0,%bl
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80cc89:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  80cc8e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc92:	89 04 24             	mov    %eax,(%esp)
  80cc95:	e8 cb af ff ff       	call   807c65 <ntohs>
  80cc9a:	0f b6 d3             	movzbl %bl,%edx
  80cc9d:	66 c1 e8 0c          	shr    $0xc,%ax
  80cca1:	0f b7 c0             	movzwl %ax,%eax
  80cca4:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80ccab:	39 c2                	cmp    %eax,%edx
  80ccad:	7c 8c                	jl     80cc3b <tcp_parseopt+0x27>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80ccaf:	83 c4 1c             	add    $0x1c,%esp
  80ccb2:	5b                   	pop    %ebx
  80ccb3:	5e                   	pop    %esi
  80ccb4:	5f                   	pop    %edi
  80ccb5:	5d                   	pop    %ebp
  80ccb6:	c3                   	ret    

0080ccb7 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80ccb7:	55                   	push   %ebp
  80ccb8:	89 e5                	mov    %esp,%ebp
  80ccba:	57                   	push   %edi
  80ccbb:	56                   	push   %esi
  80ccbc:	53                   	push   %ebx
  80ccbd:	83 ec 2c             	sub    $0x2c,%esp
  80ccc0:	89 c3                	mov    %eax,%ebx
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80ccc2:	f6 05 ec c1 b3 00 10 	testb  $0x10,0xb3c1ec
  80ccc9:	0f 84 41 04 00 00    	je     80d110 <tcp_receive+0x459>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80cccf:	8b 70 5c             	mov    0x5c(%eax),%esi
  80ccd2:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80ccd5:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80ccda:	39 c2                	cmp    %eax,%edx
  80ccdc:	78 26                	js     80cd04 <tcp_receive+0x4d>
  80ccde:	39 c2                	cmp    %eax,%edx
  80cce0:	75 0b                	jne    80cced <tcp_receive+0x36>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80cce2:	8b 0d e8 c1 b3 00    	mov    0xb3c1e8,%ecx
  80cce8:	39 4b 64             	cmp    %ecx,0x64(%ebx)
  80cceb:	78 17                	js     80cd04 <tcp_receive+0x4d>
  80cced:	8b 3d e8 c1 b3 00    	mov    0xb3c1e8,%edi
  80ccf3:	39 7b 64             	cmp    %edi,0x64(%ebx)
  80ccf6:	75 3a                	jne    80cd32 <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80ccf8:	8b 0d e0 c1 b3 00    	mov    0xb3c1e0,%ecx
  80ccfe:	66 3b 71 0e          	cmp    0xe(%ecx),%si
  80cd02:	73 2e                	jae    80cd32 <tcp_receive+0x7b>
      pcb->snd_wnd = tcphdr->wnd;
  80cd04:	8b 0d e0 c1 b3 00    	mov    0xb3c1e0,%ecx
  80cd0a:	66 8b 49 0e          	mov    0xe(%ecx),%cx
  80cd0e:	66 89 4b 5c          	mov    %cx,0x5c(%ebx)
      pcb->snd_wl1 = seqno;
  80cd12:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->snd_wl2 = ackno;
  80cd15:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80cd1a:	89 43 64             	mov    %eax,0x64(%ebx)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80cd1d:	66 85 c9             	test   %cx,%cx
  80cd20:	74 10                	je     80cd32 <tcp_receive+0x7b>
  80cd22:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  80cd29:	74 07                	je     80cd32 <tcp_receive+0x7b>
          pcb->persist_backoff = 0;
  80cd2b:	c6 83 a4 00 00 00 00 	movb   $0x0,0xa4(%ebx)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80cd32:	8b 4b 48             	mov    0x48(%ebx),%ecx
  80cd35:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80cd3a:	39 c1                	cmp    %eax,%ecx
  80cd3c:	0f 85 a2 00 00 00    	jne    80cde4 <tcp_receive+0x12d>
      pcb->acked = 0;
  80cd42:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80cd48:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  80cd4c:	03 43 60             	add    0x60(%ebx),%eax
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80cd4f:	0f b7 f6             	movzwl %si,%esi
  80cd52:	01 f2                	add    %esi,%edx
    }

    if (pcb->lastack == ackno) {
      pcb->acked = 0;

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80cd54:	39 d0                	cmp    %edx,%eax
  80cd56:	0f 85 e3 02 00 00    	jne    80d03f <tcp_receive+0x388>
        ++pcb->dupacks;
  80cd5c:	8a 43 4c             	mov    0x4c(%ebx),%al
  80cd5f:	40                   	inc    %eax
  80cd60:	88 43 4c             	mov    %al,0x4c(%ebx)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80cd63:	3c 02                	cmp    $0x2,%al
  80cd65:	0f 86 d4 02 00 00    	jbe    80d03f <tcp_receive+0x388>
  80cd6b:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80cd6f:	0f 84 ca 02 00 00    	je     80d03f <tcp_receive+0x388>
          if (!(pcb->flags & TF_INFR)) {
  80cd75:	f6 43 20 04          	testb  $0x4,0x20(%ebx)
  80cd79:	75 4e                	jne    80cdc9 <tcp_receive+0x112>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80cd7b:	89 1c 24             	mov    %ebx,(%esp)
  80cd7e:	e8 f6 be ff ff       	call   808c79 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80cd83:	66 8b 43 4e          	mov    0x4e(%ebx),%ax
  80cd87:	8b 53 5c             	mov    0x5c(%ebx),%edx
  80cd8a:	66 39 d0             	cmp    %dx,%ax
  80cd8d:	76 09                	jbe    80cd98 <tcp_receive+0xe1>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80cd8f:	66 d1 ea             	shr    %dx
  80cd92:	66 89 53 50          	mov    %dx,0x50(%ebx)
  80cd96:	eb 07                	jmp    80cd9f <tcp_receive+0xe8>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80cd98:	66 d1 e8             	shr    %ax
  80cd9b:	66 89 43 50          	mov    %ax,0x50(%ebx)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80cd9f:	8b 43 34             	mov    0x34(%ebx),%eax
  80cda2:	0f b7 4b 50          	movzwl 0x50(%ebx),%ecx
  80cda6:	0f b7 d0             	movzwl %ax,%edx
  80cda9:	d1 e2                	shl    %edx
  80cdab:	39 d1                	cmp    %edx,%ecx
  80cdad:	7d 07                	jge    80cdb6 <tcp_receive+0xff>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80cdaf:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80cdb2:	66 89 53 50          	mov    %dx,0x50(%ebx)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80cdb6:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80cdb9:	03 43 50             	add    0x50(%ebx),%eax
  80cdbc:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
            pcb->flags |= TF_INFR;
  80cdc0:	80 4b 20 04          	orb    $0x4,0x20(%ebx)
  80cdc4:	e9 76 02 00 00       	jmp    80d03f <tcp_receive+0x388>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80cdc9:	66 8b 53 4e          	mov    0x4e(%ebx),%dx
  80cdcd:	89 d0                	mov    %edx,%eax
  80cdcf:	03 43 34             	add    0x34(%ebx),%eax
  80cdd2:	66 39 c2             	cmp    %ax,%dx
  80cdd5:	0f 83 64 02 00 00    	jae    80d03f <tcp_receive+0x388>
              pcb->cwnd += pcb->mss;
  80cddb:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80cddf:	e9 5b 02 00 00       	jmp    80d03f <tcp_receive+0x388>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80cde4:	89 ca                	mov    %ecx,%edx
  80cde6:	f7 d2                	not    %edx
  80cde8:	01 c2                	add    %eax,%edx
  80cdea:	0f 88 a2 01 00 00    	js     80cf92 <tcp_receive+0x2db>
  80cdf0:	89 c2                	mov    %eax,%edx
  80cdf2:	2b 53 58             	sub    0x58(%ebx),%edx
  80cdf5:	85 d2                	test   %edx,%edx
  80cdf7:	0f 8f 95 01 00 00    	jg     80cf92 <tcp_receive+0x2db>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80cdfd:	8a 53 20             	mov    0x20(%ebx),%dl
  80ce00:	f6 c2 04             	test   $0x4,%dl
  80ce03:	74 0d                	je     80ce12 <tcp_receive+0x15b>
        pcb->flags &= ~TF_INFR;
  80ce05:	83 e2 fb             	and    $0xfffffffb,%edx
  80ce08:	88 53 20             	mov    %dl,0x20(%ebx)
        pcb->cwnd = pcb->ssthresh;
  80ce0b:	8b 53 50             	mov    0x50(%ebx),%edx
  80ce0e:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80ce12:	c6 43 46 00          	movb   $0x0,0x46(%ebx)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80ce16:	8b 53 40             	mov    0x40(%ebx),%edx
  80ce19:	66 c1 fa 03          	sar    $0x3,%dx
  80ce1d:	66 03 53 42          	add    0x42(%ebx),%dx
  80ce21:	66 89 53 44          	mov    %dx,0x44(%ebx)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80ce25:	89 c2                	mov    %eax,%edx
  80ce27:	66 29 ca             	sub    %cx,%dx
  80ce2a:	66 89 53 6c          	mov    %dx,0x6c(%ebx)

      pcb->snd_buf += pcb->acked;
  80ce2e:	66 01 53 6e          	add    %dx,0x6e(%ebx)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80ce32:	c6 43 4c 00          	movb   $0x0,0x4c(%ebx)
      pcb->lastack = ackno;
  80ce36:	89 43 48             	mov    %eax,0x48(%ebx)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80ce39:	83 7b 10 03          	cmpl   $0x3,0x10(%ebx)
  80ce3d:	0f 86 cb 00 00 00    	jbe    80cf0e <tcp_receive+0x257>
        if (pcb->cwnd < pcb->ssthresh) {
  80ce43:	66 8b 4b 4e          	mov    0x4e(%ebx),%cx
  80ce47:	66 3b 4b 50          	cmp    0x50(%ebx),%cx
  80ce4b:	73 17                	jae    80ce64 <tcp_receive+0x1ad>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80ce4d:	89 c8                	mov    %ecx,%eax
  80ce4f:	03 43 34             	add    0x34(%ebx),%eax
  80ce52:	66 39 c1             	cmp    %ax,%cx
  80ce55:	0f 83 b3 00 00 00    	jae    80cf0e <tcp_receive+0x257>
            pcb->cwnd += pcb->mss;
  80ce5b:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80ce5f:	e9 aa 00 00 00       	jmp    80cf0e <tcp_receive+0x257>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80ce64:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80ce68:	0f af c0             	imul   %eax,%eax
  80ce6b:	0f b7 f1             	movzwl %cx,%esi
  80ce6e:	99                   	cltd   
  80ce6f:	f7 fe                	idiv   %esi
  80ce71:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80ce73:	66 39 c1             	cmp    %ax,%cx
  80ce76:	0f 83 92 00 00 00    	jae    80cf0e <tcp_receive+0x257>
            pcb->cwnd = new_cwnd;
  80ce7c:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80ce80:	e9 89 00 00 00       	jmp    80cf0e <tcp_receive+0x257>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80ce85:	8b 73 78             	mov    0x78(%ebx),%esi
        pcb->unacked = pcb->unacked->next;
  80ce88:	8b 06                	mov    (%esi),%eax
  80ce8a:	89 43 78             	mov    %eax,0x78(%ebx)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80ce8d:	8b 7b 70             	mov    0x70(%ebx),%edi
  80ce90:	8b 46 04             	mov    0x4(%esi),%eax
  80ce93:	89 04 24             	mov    %eax,(%esp)
  80ce96:	e8 3d 83 ff ff       	call   8051d8 <pbuf_clen>
  80ce9b:	0f b6 c0             	movzbl %al,%eax
  80ce9e:	66 39 c7             	cmp    %ax,%di
  80cea1:	73 1c                	jae    80cebf <tcp_receive+0x208>
  80cea3:	c7 44 24 08 b4 3b 81 	movl   $0x813bb4,0x8(%esp)
  80ceaa:	00 
  80ceab:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  80ceb2:	00 
  80ceb3:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80ceba:	e8 c1 1f 00 00       	call   80ee80 <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80cebf:	8b 7b 70             	mov    0x70(%ebx),%edi
  80cec2:	8b 46 04             	mov    0x4(%esi),%eax
  80cec5:	89 04 24             	mov    %eax,(%esp)
  80cec8:	e8 0b 83 ff ff       	call   8051d8 <pbuf_clen>
  80cecd:	0f b6 c0             	movzbl %al,%eax
  80ced0:	66 29 c7             	sub    %ax,%di
  80ced3:	66 89 7b 70          	mov    %di,0x70(%ebx)
        tcp_seg_free(next);
  80ced7:	89 34 24             	mov    %esi,(%esp)
  80ceda:	e8 e6 8d ff ff       	call   805cc5 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80cedf:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  80cee4:	74 28                	je     80cf0e <tcp_receive+0x257>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80cee6:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80ceea:	75 22                	jne    80cf0e <tcp_receive+0x257>
  80ceec:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  80cef0:	75 1c                	jne    80cf0e <tcp_receive+0x257>
  80cef2:	c7 44 24 08 dc 3b 81 	movl   $0x813bdc,0x8(%esp)
  80cef9:	00 
  80cefa:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  80cf01:	00 
  80cf02:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80cf09:	e8 72 1f 00 00       	call   80ee80 <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80cf0e:	8b 43 78             	mov    0x78(%ebx),%eax
  80cf11:	85 c0                	test   %eax,%eax
  80cf13:	74 6b                	je     80cf80 <tcp_receive+0x2c9>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80cf15:	8b 40 10             	mov    0x10(%eax),%eax
  80cf18:	8b 40 04             	mov    0x4(%eax),%eax
  80cf1b:	89 04 24             	mov    %eax,(%esp)
  80cf1e:	e8 ac af ff ff       	call   807ecf <ntohl>
  80cf23:	89 c6                	mov    %eax,%esi
  80cf25:	8b 43 78             	mov    0x78(%ebx),%eax
  80cf28:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80cf2c:	8b 40 10             	mov    0x10(%eax),%eax
  80cf2f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf33:	89 04 24             	mov    %eax,(%esp)
  80cf36:	e8 2a ad ff ff       	call   807c65 <ntohs>
  80cf3b:	a8 01                	test   $0x1,%al
  80cf3d:	75 1d                	jne    80cf5c <tcp_receive+0x2a5>
  80cf3f:	8b 43 78             	mov    0x78(%ebx),%eax
  80cf42:	8b 40 10             	mov    0x10(%eax),%eax
  80cf45:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf49:	89 04 24             	mov    %eax,(%esp)
  80cf4c:	e8 14 ad ff ff       	call   807c65 <ntohs>
  80cf51:	83 e0 02             	and    $0x2,%eax
  80cf54:	0f 95 c0             	setne  %al
  80cf57:	0f b6 c0             	movzbl %al,%eax
  80cf5a:	eb 05                	jmp    80cf61 <tcp_receive+0x2aa>
  80cf5c:	b8 01 00 00 00       	mov    $0x1,%eax
  80cf61:	2b 35 e8 c1 b3 00    	sub    0xb3c1e8,%esi
  80cf67:	01 c7                	add    %eax,%edi
  80cf69:	01 fe                	add    %edi,%esi
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80cf6b:	85 f6                	test   %esi,%esi
  80cf6d:	0f 8e 12 ff ff ff    	jle    80ce85 <tcp_receive+0x1ce>
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
  80cf73:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80cf77:	0f 95 c0             	setne  %al
  80cf7a:	0f b6 c0             	movzbl %al,%eax
  80cf7d:	48                   	dec    %eax
  80cf7e:	eb 05                	jmp    80cf85 <tcp_receive+0x2ce>
  80cf80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80cf85:	66 89 43 32          	mov    %ax,0x32(%ebx)
        pcb->rtime = -1;
      else
        pcb->rtime = 0;

      pcb->polltmr = 0;
  80cf89:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
  80cf8d:	e9 ad 00 00 00       	jmp    80d03f <tcp_receive+0x388>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80cf92:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)
  80cf98:	e9 a2 00 00 00       	jmp    80d03f <tcp_receive+0x388>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80cf9d:	8b 73 74             	mov    0x74(%ebx),%esi
      pcb->unsent = pcb->unsent->next;
  80cfa0:	8b 06                	mov    (%esi),%eax
  80cfa2:	89 43 74             	mov    %eax,0x74(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80cfa5:	8b 7b 70             	mov    0x70(%ebx),%edi
  80cfa8:	8b 46 04             	mov    0x4(%esi),%eax
  80cfab:	89 04 24             	mov    %eax,(%esp)
  80cfae:	e8 25 82 ff ff       	call   8051d8 <pbuf_clen>
  80cfb3:	0f b6 c0             	movzbl %al,%eax
  80cfb6:	66 39 c7             	cmp    %ax,%di
  80cfb9:	73 1c                	jae    80cfd7 <tcp_receive+0x320>
  80cfbb:	c7 44 24 08 b4 3b 81 	movl   $0x813bb4,0x8(%esp)
  80cfc2:	00 
  80cfc3:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  80cfca:	00 
  80cfcb:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80cfd2:	e8 a9 1e 00 00       	call   80ee80 <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80cfd7:	8b 7b 70             	mov    0x70(%ebx),%edi
  80cfda:	8b 46 04             	mov    0x4(%esi),%eax
  80cfdd:	89 04 24             	mov    %eax,(%esp)
  80cfe0:	e8 f3 81 ff ff       	call   8051d8 <pbuf_clen>
  80cfe5:	0f b6 c0             	movzbl %al,%eax
  80cfe8:	66 29 c7             	sub    %ax,%di
  80cfeb:	66 89 7b 70          	mov    %di,0x70(%ebx)
      tcp_seg_free(next);
  80cfef:	89 34 24             	mov    %esi,(%esp)
  80cff2:	e8 ce 8c ff ff       	call   805cc5 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80cff7:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  80cffc:	74 29                	je     80d027 <tcp_receive+0x370>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80cffe:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80d002:	75 23                	jne    80d027 <tcp_receive+0x370>
  80d004:	8b 43 74             	mov    0x74(%ebx),%eax
  80d007:	85 c0                	test   %eax,%eax
  80d009:	75 23                	jne    80d02e <tcp_receive+0x377>
  80d00b:	c7 44 24 08 dc 3b 81 	movl   $0x813bdc,0x8(%esp)
  80d012:	00 
  80d013:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  80d01a:	00 
  80d01b:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80d022:	e8 59 1e 00 00       	call   80ee80 <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80d027:	8b 43 74             	mov    0x74(%ebx),%eax
  80d02a:	85 c0                	test   %eax,%eax
  80d02c:	74 11                	je     80d03f <tcp_receive+0x388>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80d02e:	8b 40 10             	mov    0x10(%eax),%eax
  80d031:	8b 40 04             	mov    0x4(%eax),%eax
  80d034:	89 04 24             	mov    %eax,(%esp)
  80d037:	e8 3d ac ff ff       	call   807c79 <htonl>
  80d03c:	89 43 54             	mov    %eax,0x54(%ebx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d03f:	8b 43 74             	mov    0x74(%ebx),%eax
  80d042:	85 c0                	test   %eax,%eax
  80d044:	74 6e                	je     80d0b4 <tcp_receive+0x3fd>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d046:	8b 35 e8 c1 b3 00    	mov    0xb3c1e8,%esi
  80d04c:	8b 40 10             	mov    0x10(%eax),%eax
  80d04f:	8b 40 04             	mov    0x4(%eax),%eax
  80d052:	89 04 24             	mov    %eax,(%esp)
  80d055:	e8 75 ae ff ff       	call   807ecf <ntohl>
  80d05a:	89 c7                	mov    %eax,%edi
  80d05c:	8b 43 74             	mov    0x74(%ebx),%eax
  80d05f:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  80d063:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80d066:	8b 40 10             	mov    0x10(%eax),%eax
  80d069:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d06d:	89 04 24             	mov    %eax,(%esp)
  80d070:	e8 f0 ab ff ff       	call   807c65 <ntohs>
  80d075:	a8 01                	test   $0x1,%al
  80d077:	75 1d                	jne    80d096 <tcp_receive+0x3df>
  80d079:	8b 43 74             	mov    0x74(%ebx),%eax
  80d07c:	8b 40 10             	mov    0x10(%eax),%eax
  80d07f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d083:	89 04 24             	mov    %eax,(%esp)
  80d086:	e8 da ab ff ff       	call   807c65 <ntohs>
  80d08b:	83 e0 02             	and    $0x2,%eax
  80d08e:	0f 95 c0             	setne  %al
  80d091:	0f b6 c0             	movzbl %al,%eax
  80d094:	eb 05                	jmp    80d09b <tcp_receive+0x3e4>
  80d096:	b8 01 00 00 00       	mov    $0x1,%eax
  80d09b:	29 fe                	sub    %edi,%esi
  80d09d:	03 45 e4             	add    -0x1c(%ebp),%eax
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d0a0:	39 c6                	cmp    %eax,%esi
  80d0a2:	78 10                	js     80d0b4 <tcp_receive+0x3fd>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d0a4:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80d0a9:	2b 43 58             	sub    0x58(%ebx),%eax
  80d0ac:	85 c0                	test   %eax,%eax
  80d0ae:	0f 8e e9 fe ff ff    	jle    80cf9d <tcp_receive+0x2e6>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80d0b4:	8b 43 38             	mov    0x38(%ebx),%eax
  80d0b7:	85 c0                	test   %eax,%eax
  80d0b9:	74 55                	je     80d110 <tcp_receive+0x459>
  80d0bb:	8b 0d e8 c1 b3 00    	mov    0xb3c1e8,%ecx
  80d0c1:	39 4b 3c             	cmp    %ecx,0x3c(%ebx)
  80d0c4:	79 4a                	jns    80d110 <tcp_receive+0x459>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d0c6:	8b 53 40             	mov    0x40(%ebx),%edx
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80d0c9:	8b 0d 80 c2 b3 00    	mov    0xb3c280,%ecx
  80d0cf:	66 29 c1             	sub    %ax,%cx
  80d0d2:	89 c8                	mov    %ecx,%eax

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d0d4:	89 d1                	mov    %edx,%ecx
  80d0d6:	66 c1 f9 03          	sar    $0x3,%cx
  80d0da:	66 29 c8             	sub    %cx,%ax
  80d0dd:	89 c1                	mov    %eax,%ecx
      pcb->sa += m;
  80d0df:	01 c2                	add    %eax,%edx
  80d0e1:	66 89 53 40          	mov    %dx,0x40(%ebx)
      if (m < 0) {
  80d0e5:	66 85 c0             	test   %ax,%ax
  80d0e8:	79 02                	jns    80d0ec <tcp_receive+0x435>
        m = -m;
  80d0ea:	f7 d9                	neg    %ecx
      }
      m = m - (pcb->sv >> 2);
  80d0ec:	66 8b 43 42          	mov    0x42(%ebx),%ax
  80d0f0:	89 c6                	mov    %eax,%esi
  80d0f2:	66 c1 fe 02          	sar    $0x2,%si
  80d0f6:	66 29 f0             	sub    %si,%ax
      pcb->sv += m;
  80d0f9:	01 c8                	add    %ecx,%eax
  80d0fb:	66 89 43 42          	mov    %ax,0x42(%ebx)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80d0ff:	66 c1 fa 03          	sar    $0x3,%dx
  80d103:	01 d0                	add    %edx,%eax
  80d105:	66 89 43 44          	mov    %ax,0x44(%ebx)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80d109:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80d110:	66 8b 0d ee c1 b3 00 	mov    0xb3c1ee,%cx
  80d117:	66 85 c9             	test   %cx,%cx
  80d11a:	0f 84 39 07 00 00    	je     80d859 <tcp_receive+0xba2>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80d120:	8b 53 24             	mov    0x24(%ebx),%edx
  80d123:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d128:	89 c6                	mov    %eax,%esi
  80d12a:	f7 d6                	not    %esi
  80d12c:	01 d6                	add    %edx,%esi
  80d12e:	0f 88 3a 01 00 00    	js     80d26e <tcp_receive+0x5b7>
  80d134:	8d 7a 01             	lea    0x1(%edx),%edi
  80d137:	29 c7                	sub    %eax,%edi
  80d139:	0f b7 f1             	movzwl %cx,%esi
  80d13c:	89 f9                	mov    %edi,%ecx
  80d13e:	29 f1                	sub    %esi,%ecx
  80d140:	85 c9                	test   %ecx,%ecx
  80d142:	0f 8f 26 01 00 00    	jg     80d26e <tcp_receive+0x5b7>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
  80d148:	8b 35 f4 c1 b3 00    	mov    0xb3c1f4,%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80d14e:	85 f6                	test   %esi,%esi
  80d150:	75 1c                	jne    80d16e <tcp_receive+0x4b7>
  80d152:	c7 44 24 08 37 3d 81 	movl   $0x813d37,0x8(%esp)
  80d159:	00 
  80d15a:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  80d161:	00 
  80d162:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80d169:	e8 12 1d 00 00       	call   80ee80 <_panic>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80d16e:	29 c2                	sub    %eax,%edx
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80d170:	81 fa fe 7f 00 00    	cmp    $0x7ffe,%edx
  80d176:	7e 1c                	jle    80d194 <tcp_receive+0x4dd>
  80d178:	c7 44 24 08 47 3d 81 	movl   $0x813d47,0x8(%esp)
  80d17f:	00 
  80d180:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  80d187:	00 
  80d188:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80d18f:	e8 ec 1c 00 00       	call   80ee80 <_panic>
      if (inseg.p->len < off) {
  80d194:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80d198:	39 c2                	cmp    %eax,%edx
  80d19a:	7e 70                	jle    80d20c <tcp_receive+0x555>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80d19c:	8b 4e 08             	mov    0x8(%esi),%ecx
  80d19f:	0f b7 f9             	movzwl %cx,%edi
  80d1a2:	39 fa                	cmp    %edi,%edx
  80d1a4:	7e 1c                	jle    80d1c2 <tcp_receive+0x50b>
  80d1a6:	c7 44 24 08 56 3d 81 	movl   $0x813d56,0x8(%esp)
  80d1ad:	00 
  80d1ae:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  80d1b5:	00 
  80d1b6:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80d1bd:	e8 be 1c 00 00       	call   80ee80 <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80d1c2:	66 29 d1             	sub    %dx,%cx
        while (p->len < off) {
          off -= p->len;
  80d1c5:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80d1c7:	66 89 4e 08          	mov    %cx,0x8(%esi)
          p->len = 0;
  80d1cb:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
          p = p->next;
  80d1d1:	8b 36                	mov    (%esi),%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80d1d3:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80d1d7:	39 d0                	cmp    %edx,%eax
  80d1d9:	7c ea                	jl     80d1c5 <tcp_receive+0x50e>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80d1db:	f7 da                	neg    %edx
  80d1dd:	0f bf c2             	movswl %dx,%eax
  80d1e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d1e4:	89 34 24             	mov    %esi,(%esp)
  80d1e7:	e8 80 7a ff ff       	call   804c6c <pbuf_header>
  80d1ec:	84 c0                	test   %al,%al
  80d1ee:	74 4d                	je     80d23d <tcp_receive+0x586>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d1f0:	c7 44 24 08 66 3d 81 	movl   $0x813d66,0x8(%esp)
  80d1f7:	00 
  80d1f8:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  80d1ff:	00 
  80d200:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80d207:	e8 74 1c 00 00       	call   80ee80 <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80d20c:	f7 da                	neg    %edx
  80d20e:	0f bf c2             	movswl %dx,%eax
  80d211:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d215:	89 34 24             	mov    %esi,(%esp)
  80d218:	e8 4f 7a ff ff       	call   804c6c <pbuf_header>
  80d21d:	84 c0                	test   %al,%al
  80d21f:	74 1c                	je     80d23d <tcp_receive+0x586>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d221:	c7 44 24 08 66 3d 81 	movl   $0x813d66,0x8(%esp)
  80d228:	00 
  80d229:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  80d230:	00 
  80d231:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80d238:	e8 43 1c 00 00       	call   80ee80 <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80d23d:	8b 46 04             	mov    0x4(%esi),%eax
  80d240:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80d245:	8b 43 24             	mov    0x24(%ebx),%eax
  80d248:	8b 15 e4 c1 b3 00    	mov    0xb3c1e4,%edx
  80d24e:	03 15 fc c1 b3 00    	add    0xb3c1fc,%edx
  80d254:	66 29 c2             	sub    %ax,%dx
  80d257:	66 89 15 fc c1 b3 00 	mov    %dx,0xb3c1fc
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80d25e:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4
  80d263:	8b 15 00 c2 b3 00    	mov    0xb3c200,%edx
  80d269:	89 42 04             	mov    %eax,0x4(%edx)
  80d26c:	eb 10                	jmp    80d27e <tcp_receive+0x5c7>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80d26e:	39 d0                	cmp    %edx,%eax
  80d270:	79 1c                	jns    80d28e <tcp_receive+0x5d7>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80d272:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d276:	89 1c 24             	mov    %ebx,(%esp)
  80d279:	e8 c0 b3 ff ff       	call   80863e <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d27e:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d283:	8b 53 24             	mov    0x24(%ebx),%edx
  80d286:	39 d0                	cmp    %edx,%eax
  80d288:	0f 88 bb 05 00 00    	js     80d849 <tcp_receive+0xb92>
  80d28e:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d292:	89 c6                	mov    %eax,%esi
  80d294:	29 ce                	sub    %ecx,%esi
  80d296:	8d 4e 01             	lea    0x1(%esi),%ecx
  80d299:	29 d1                	sub    %edx,%ecx
  80d29b:	85 c9                	test   %ecx,%ecx
  80d29d:	0f 8f a6 05 00 00    	jg     80d849 <tcp_receive+0xb92>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80d2a3:	39 d0                	cmp    %edx,%eax
  80d2a5:	0f 85 6b 03 00 00    	jne    80d616 <tcp_receive+0x95f>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d2ab:	8b 53 7c             	mov    0x7c(%ebx),%edx
  80d2ae:	85 d2                	test   %edx,%edx
  80d2b0:	0f 84 87 00 00 00    	je     80d33d <tcp_receive+0x686>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80d2b6:	8b 4a 10             	mov    0x10(%edx),%ecx
  80d2b9:	8b 49 04             	mov    0x4(%ecx),%ecx
  80d2bc:	0f b7 35 fc c1 b3 00 	movzwl 0xb3c1fc,%esi
  80d2c3:	89 cf                	mov    %ecx,%edi
  80d2c5:	29 f7                	sub    %esi,%edi
  80d2c7:	89 fe                	mov    %edi,%esi
  80d2c9:	29 c6                	sub    %eax,%esi
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d2cb:	85 f6                	test   %esi,%esi
  80d2cd:	7f 6e                	jg     80d33d <tcp_receive+0x686>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80d2cf:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  80d2d4:	74 20                	je     80d2f6 <tcp_receive+0x63f>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80d2d6:	66 29 c1             	sub    %ax,%cx
  80d2d9:	66 89 0d fc c1 b3 00 	mov    %cx,0xb3c1fc
            pbuf_realloc(inseg.p, inseg.len);
  80d2e0:	0f b7 c9             	movzwl %cx,%ecx
  80d2e3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80d2e7:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  80d2ec:	89 04 24             	mov    %eax,(%esp)
  80d2ef:	e8 2f 7b ff ff       	call   804e23 <pbuf_realloc>
  80d2f4:	eb 47                	jmp    80d33d <tcp_receive+0x686>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d2f6:	a1 00 c2 b3 00       	mov    0xb3c200,%eax
  80d2fb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d2ff:	89 04 24             	mov    %eax,(%esp)
  80d302:	e8 5e a9 ff ff       	call   807c65 <ntohs>
  80d307:	89 c6                	mov    %eax,%esi
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80d309:	8b 43 7c             	mov    0x7c(%ebx),%eax
  80d30c:	8b 40 10             	mov    0x10(%eax),%eax
  80d30f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d313:	89 04 24             	mov    %eax,(%esp)
  80d316:	e8 4a a9 ff ff       	call   807c65 <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d31b:	31 c6                	xor    %eax,%esi
  80d31d:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80d323:	75 18                	jne    80d33d <tcp_receive+0x686>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80d325:	8b 43 7c             	mov    0x7c(%ebx),%eax
              pcb->ooseq = pcb->ooseq->next;
  80d328:	8b 10                	mov    (%eax),%edx
  80d32a:	89 53 7c             	mov    %edx,0x7c(%ebx)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80d32d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d331:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80d338:	e8 89 76 ff ff       	call   8049c6 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80d33d:	8b 35 fc c1 b3 00    	mov    0xb3c1fc,%esi
  80d343:	a1 00 c2 b3 00       	mov    0xb3c200,%eax
  80d348:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d34c:	89 04 24             	mov    %eax,(%esp)
  80d34f:	e8 11 a9 ff ff       	call   807c65 <ntohs>
  80d354:	a8 01                	test   $0x1,%al
  80d356:	75 1c                	jne    80d374 <tcp_receive+0x6bd>
  80d358:	a1 00 c2 b3 00       	mov    0xb3c200,%eax
  80d35d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d361:	89 04 24             	mov    %eax,(%esp)
  80d364:	e8 fc a8 ff ff       	call   807c65 <ntohs>
  80d369:	83 e0 02             	and    $0x2,%eax
  80d36c:	0f 95 c0             	setne  %al
  80d36f:	0f b6 c0             	movzbl %al,%eax
  80d372:	eb 05                	jmp    80d379 <tcp_receive+0x6c2>
  80d374:	b8 01 00 00 00       	mov    $0x1,%eax
  80d379:	01 c6                	add    %eax,%esi
  80d37b:	66 89 35 ee c1 b3 00 	mov    %si,0xb3c1ee

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80d382:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  80d386:	74 06                	je     80d38e <tcp_receive+0x6d7>
          pcb->rcv_nxt += tcplen;
  80d388:	0f b7 c6             	movzwl %si,%eax
  80d38b:	01 43 24             	add    %eax,0x24(%ebx)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80d38e:	8b 43 28             	mov    0x28(%ebx),%eax
  80d391:	66 39 c6             	cmp    %ax,%si
  80d394:	76 08                	jbe    80d39e <tcp_receive+0x6e7>
          pcb->rcv_wnd = 0;
  80d396:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  80d39c:	eb 07                	jmp    80d3a5 <tcp_receive+0x6ee>
        } else {
          pcb->rcv_wnd -= tcplen;
  80d39e:	66 29 f0             	sub    %si,%ax
  80d3a1:	66 89 43 28          	mov    %ax,0x28(%ebx)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80d3a5:	66 8b 43 2a          	mov    0x2a(%ebx),%ax
  80d3a9:	66 39 c6             	cmp    %ax,%si
  80d3ac:	76 08                	jbe    80d3b6 <tcp_receive+0x6ff>
          pcb->rcv_ann_wnd = 0;
  80d3ae:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  80d3b4:	eb 07                	jmp    80d3bd <tcp_receive+0x706>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80d3b6:	66 29 f0             	sub    %si,%ax
  80d3b9:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80d3bd:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  80d3c2:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d3c7:	74 0f                	je     80d3d8 <tcp_receive+0x721>
          recv_data = inseg.p;
  80d3c9:	a3 04 c2 b3 00       	mov    %eax,0xb3c204
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80d3ce:	c7 05 f4 c1 b3 00 00 	movl   $0x0,0xb3c1f4
  80d3d5:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80d3d8:	a1 00 c2 b3 00       	mov    0xb3c200,%eax
  80d3dd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d3e1:	89 04 24             	mov    %eax,(%esp)
  80d3e4:	e8 7c a8 ff ff       	call   807c65 <ntohs>
  80d3e9:	a8 01                	test   $0x1,%al
  80d3eb:	0f 84 df 01 00 00    	je     80d5d0 <tcp_receive+0x919>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80d3f1:	c6 05 08 c2 b3 00 20 	movb   $0x20,0xb3c208
  80d3f8:	89 de                	mov    %ebx,%esi
  80d3fa:	e9 d3 01 00 00       	jmp    80d5d2 <tcp_receive+0x91b>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80d3ff:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80d404:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d408:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d40b:	8b 43 10             	mov    0x10(%ebx),%eax
  80d40e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d412:	89 04 24             	mov    %eax,(%esp)
  80d415:	e8 4b a8 ff ff       	call   807c65 <ntohs>
  80d41a:	a8 01                	test   $0x1,%al
  80d41c:	75 1a                	jne    80d438 <tcp_receive+0x781>
  80d41e:	8b 43 10             	mov    0x10(%ebx),%eax
  80d421:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d425:	89 04 24             	mov    %eax,(%esp)
  80d428:	e8 38 a8 ff ff       	call   807c65 <ntohs>
  80d42d:	83 e0 02             	and    $0x2,%eax
  80d430:	0f 95 c0             	setne  %al
  80d433:	0f b6 c0             	movzbl %al,%eax
  80d436:	eb 05                	jmp    80d43d <tcp_receive+0x786>
  80d438:	b8 01 00 00 00       	mov    $0x1,%eax
  80d43d:	03 45 e4             	add    -0x1c(%ebp),%eax
  80d440:	01 c7                	add    %eax,%edi
  80d442:	89 7e 24             	mov    %edi,0x24(%esi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80d445:	0f b7 7e 28          	movzwl 0x28(%esi),%edi
  80d449:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80d44c:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80d450:	8b 43 10             	mov    0x10(%ebx),%eax
  80d453:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d457:	89 04 24             	mov    %eax,(%esp)
  80d45a:	e8 06 a8 ff ff       	call   807c65 <ntohs>
  80d45f:	a8 01                	test   $0x1,%al
  80d461:	75 1a                	jne    80d47d <tcp_receive+0x7c6>
  80d463:	8b 43 10             	mov    0x10(%ebx),%eax
  80d466:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d46a:	89 04 24             	mov    %eax,(%esp)
  80d46d:	e8 f3 a7 ff ff       	call   807c65 <ntohs>
  80d472:	83 e0 02             	and    $0x2,%eax
  80d475:	0f 95 c0             	setne  %al
  80d478:	0f b6 c0             	movzbl %al,%eax
  80d47b:	eb 05                	jmp    80d482 <tcp_receive+0x7cb>
  80d47d:	b8 01 00 00 00       	mov    $0x1,%eax
  80d482:	01 c7                	add    %eax,%edi
  80d484:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  80d487:	7d 08                	jge    80d491 <tcp_receive+0x7da>
            pcb->rcv_wnd = 0;
  80d489:	66 c7 46 28 00 00    	movw   $0x0,0x28(%esi)
  80d48f:	eb 47                	jmp    80d4d8 <tcp_receive+0x821>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80d491:	8b 7e 28             	mov    0x28(%esi),%edi
  80d494:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d497:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d49b:	8b 43 10             	mov    0x10(%ebx),%eax
  80d49e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4a2:	89 04 24             	mov    %eax,(%esp)
  80d4a5:	e8 bb a7 ff ff       	call   807c65 <ntohs>
  80d4aa:	a8 01                	test   $0x1,%al
  80d4ac:	75 1a                	jne    80d4c8 <tcp_receive+0x811>
  80d4ae:	8b 43 10             	mov    0x10(%ebx),%eax
  80d4b1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4b5:	89 04 24             	mov    %eax,(%esp)
  80d4b8:	e8 a8 a7 ff ff       	call   807c65 <ntohs>
  80d4bd:	83 e0 02             	and    $0x2,%eax
  80d4c0:	0f 95 c0             	setne  %al
  80d4c3:	0f b6 c0             	movzbl %al,%eax
  80d4c6:	eb 05                	jmp    80d4cd <tcp_receive+0x816>
  80d4c8:	b8 01 00 00 00       	mov    $0x1,%eax
  80d4cd:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  80d4d1:	66 29 c7             	sub    %ax,%di
  80d4d4:	66 89 7e 28          	mov    %di,0x28(%esi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80d4d8:	0f b7 7e 2a          	movzwl 0x2a(%esi),%edi
  80d4dc:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80d4df:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80d4e3:	8b 43 10             	mov    0x10(%ebx),%eax
  80d4e6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4ea:	89 04 24             	mov    %eax,(%esp)
  80d4ed:	e8 73 a7 ff ff       	call   807c65 <ntohs>
  80d4f2:	a8 01                	test   $0x1,%al
  80d4f4:	75 1a                	jne    80d510 <tcp_receive+0x859>
  80d4f6:	8b 43 10             	mov    0x10(%ebx),%eax
  80d4f9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4fd:	89 04 24             	mov    %eax,(%esp)
  80d500:	e8 60 a7 ff ff       	call   807c65 <ntohs>
  80d505:	83 e0 02             	and    $0x2,%eax
  80d508:	0f 95 c0             	setne  %al
  80d50b:	0f b6 c0             	movzbl %al,%eax
  80d50e:	eb 05                	jmp    80d515 <tcp_receive+0x85e>
  80d510:	b8 01 00 00 00       	mov    $0x1,%eax
  80d515:	01 c7                	add    %eax,%edi
  80d517:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  80d51a:	7d 08                	jge    80d524 <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80d51c:	66 c7 46 2a 00 00    	movw   $0x0,0x2a(%esi)
  80d522:	eb 48                	jmp    80d56c <tcp_receive+0x8b5>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80d524:	66 8b 7e 2a          	mov    0x2a(%esi),%di
  80d528:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d52b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d52f:	8b 43 10             	mov    0x10(%ebx),%eax
  80d532:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d536:	89 04 24             	mov    %eax,(%esp)
  80d539:	e8 27 a7 ff ff       	call   807c65 <ntohs>
  80d53e:	a8 01                	test   $0x1,%al
  80d540:	75 1a                	jne    80d55c <tcp_receive+0x8a5>
  80d542:	8b 43 10             	mov    0x10(%ebx),%eax
  80d545:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d549:	89 04 24             	mov    %eax,(%esp)
  80d54c:	e8 14 a7 ff ff       	call   807c65 <ntohs>
  80d551:	83 e0 02             	and    $0x2,%eax
  80d554:	0f 95 c0             	setne  %al
  80d557:	0f b6 c0             	movzbl %al,%eax
  80d55a:	eb 05                	jmp    80d561 <tcp_receive+0x8aa>
  80d55c:	b8 01 00 00 00       	mov    $0x1,%eax
  80d561:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  80d565:	66 29 c7             	sub    %ax,%di
  80d568:	66 89 7e 2a          	mov    %di,0x2a(%esi)
          }

          if (cseg->p->tot_len > 0) {
  80d56c:	8b 43 04             	mov    0x4(%ebx),%eax
  80d56f:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d574:	74 24                	je     80d59a <tcp_receive+0x8e3>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80d576:	8b 15 04 c2 b3 00    	mov    0xb3c204,%edx
  80d57c:	85 d2                	test   %edx,%edx
  80d57e:	74 0e                	je     80d58e <tcp_receive+0x8d7>
              pbuf_cat(recv_data, cseg->p);
  80d580:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d584:	89 14 24             	mov    %edx,(%esp)
  80d587:	e8 6f 7c ff ff       	call   8051fb <pbuf_cat>
  80d58c:	eb 05                	jmp    80d593 <tcp_receive+0x8dc>
            } else {
              recv_data = cseg->p;
  80d58e:	a3 04 c2 b3 00       	mov    %eax,0xb3c204
            }
            cseg->p = NULL;
  80d593:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80d59a:	8b 43 10             	mov    0x10(%ebx),%eax
  80d59d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5a1:	89 04 24             	mov    %eax,(%esp)
  80d5a4:	e8 bc a6 ff ff       	call   807c65 <ntohs>
  80d5a9:	a8 01                	test   $0x1,%al
  80d5ab:	74 14                	je     80d5c1 <tcp_receive+0x90a>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80d5ad:	c6 05 08 c2 b3 00 20 	movb   $0x20,0xb3c208
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80d5b4:	83 7e 10 04          	cmpl   $0x4,0x10(%esi)
  80d5b8:	75 07                	jne    80d5c1 <tcp_receive+0x90a>
              pcb->state = CLOSE_WAIT;
  80d5ba:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
            } 
          }


          pcb->ooseq = cseg->next;
  80d5c1:	8b 03                	mov    (%ebx),%eax
  80d5c3:	89 46 7c             	mov    %eax,0x7c(%esi)
          tcp_seg_free(cseg);
  80d5c6:	89 1c 24             	mov    %ebx,(%esp)
  80d5c9:	e8 f7 86 ff ff       	call   805cc5 <tcp_seg_free>
  80d5ce:	eb 02                	jmp    80d5d2 <tcp_receive+0x91b>
  80d5d0:	89 de                	mov    %ebx,%esi
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d5d2:	8b 5e 7c             	mov    0x7c(%esi),%ebx
  80d5d5:	85 db                	test   %ebx,%ebx
  80d5d7:	74 11                	je     80d5ea <tcp_receive+0x933>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80d5d9:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5dc:	8b 40 04             	mov    0x4(%eax),%eax
  80d5df:	8b 7e 24             	mov    0x24(%esi),%edi
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d5e2:	39 f8                	cmp    %edi,%eax
  80d5e4:	0f 84 15 fe ff ff    	je     80d3ff <tcp_receive+0x748>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d5ea:	8a 46 20             	mov    0x20(%esi),%al
  80d5ed:	a8 01                	test   $0x1,%al
  80d5ef:	74 18                	je     80d609 <tcp_receive+0x952>
  80d5f1:	83 e0 fe             	and    $0xfffffffe,%eax
  80d5f4:	83 c8 02             	or     $0x2,%eax
  80d5f7:	88 46 20             	mov    %al,0x20(%esi)
  80d5fa:	89 34 24             	mov    %esi,(%esp)
  80d5fd:	e8 3c b0 ff ff       	call   80863e <tcp_output>
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80d602:	b0 01                	mov    $0x1,%al
  80d604:	e9 a4 02 00 00       	jmp    80d8ad <tcp_receive+0xbf6>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d609:	83 c8 01             	or     $0x1,%eax
  80d60c:	88 46 20             	mov    %al,0x20(%esi)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80d60f:	b0 01                	mov    $0x1,%al
  80d611:	e9 97 02 00 00       	jmp    80d8ad <tcp_receive+0xbf6>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80d616:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d61a:	89 1c 24             	mov    %ebx,(%esp)
  80d61d:	e8 1c b0 ff ff       	call   80863e <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80d622:	8b 73 7c             	mov    0x7c(%ebx),%esi
  80d625:	85 f6                	test   %esi,%esi
  80d627:	75 16                	jne    80d63f <tcp_receive+0x988>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80d629:	c7 04 24 f0 c1 b3 00 	movl   $0xb3c1f0,(%esp)
  80d630:	e8 12 87 ff ff       	call   805d47 <tcp_seg_copy>
  80d635:	89 43 7c             	mov    %eax,0x7c(%ebx)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d638:	b0 00                	mov    $0x0,%al
  80d63a:	e9 6e 02 00 00       	jmp    80d8ad <tcp_receive+0xbf6>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80d63f:	8b 0d e4 c1 b3 00    	mov    0xb3c1e4,%ecx
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d645:	8d 41 01             	lea    0x1(%ecx),%eax

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  80d648:	bf 00 00 00 00       	mov    $0x0,%edi
  80d64d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80d650:	89 c3                	mov    %eax,%ebx
  80d652:	eb 04                	jmp    80d658 <tcp_receive+0x9a1>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d654:	89 f7                	mov    %esi,%edi
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  80d656:	89 d6                	mov    %edx,%esi
            if (seqno == next->tcphdr->seqno) {
  80d658:	8b 46 10             	mov    0x10(%esi),%eax
  80d65b:	8b 40 04             	mov    0x4(%eax),%eax
  80d65e:	39 c8                	cmp    %ecx,%eax
  80d660:	0f 85 93 00 00 00    	jne    80d6f9 <tcp_receive+0xa42>
  80d666:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80d669:	8b 56 0c             	mov    0xc(%esi),%edx
  80d66c:	66 39 15 fc c1 b3 00 	cmp    %dx,0xb3c1fc
  80d673:	0f 86 0a 02 00 00    	jbe    80d883 <tcp_receive+0xbcc>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80d679:	c7 04 24 f0 c1 b3 00 	movl   $0xb3c1f0,(%esp)
  80d680:	e8 c2 86 ff ff       	call   805d47 <tcp_seg_copy>
  80d685:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80d688:	85 c0                	test   %eax,%eax
  80d68a:	0f 84 f7 01 00 00    	je     80d887 <tcp_receive+0xbd0>
                  cseg->next = next->next;
  80d690:	8b 06                	mov    (%esi),%eax
  80d692:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80d695:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80d697:	85 ff                	test   %edi,%edi
  80d699:	74 04                	je     80d69f <tcp_receive+0x9e8>
                    prev->next = cseg;
  80d69b:	89 0f                	mov    %ecx,(%edi)
  80d69d:	eb 06                	jmp    80d6a5 <tcp_receive+0x9ee>
                  } else {
                    pcb->ooseq = cseg;
  80d69f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d6a2:	89 43 7c             	mov    %eax,0x7c(%ebx)
                  }
                  tcp_seg_free(next);
  80d6a5:	89 34 24             	mov    %esi,(%esp)
  80d6a8:	e8 18 86 ff ff       	call   805cc5 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80d6ad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d6b0:	8b 02                	mov    (%edx),%eax
  80d6b2:	85 c0                	test   %eax,%eax
  80d6b4:	0f 84 d1 01 00 00    	je     80d88b <tcp_receive+0xbd4>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d6ba:	8b 15 e4 c1 b3 00    	mov    0xb3c1e4,%edx
  80d6c0:	8b 40 10             	mov    0x10(%eax),%eax
  80d6c3:	8b 40 04             	mov    0x4(%eax),%eax
  80d6c6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80d6c9:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80d6cd:	29 c1                	sub    %eax,%ecx
  80d6cf:	01 d1                	add    %edx,%ecx
  80d6d1:	85 c9                	test   %ecx,%ecx
  80d6d3:	0f 8e b6 01 00 00    	jle    80d88f <tcp_receive+0xbd8>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80d6d9:	66 29 d0             	sub    %dx,%ax
  80d6dc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                      pbuf_realloc(cseg->p, cseg->len);
  80d6e0:	0f b7 c0             	movzwl %ax,%eax
  80d6e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d6e7:	8b 43 04             	mov    0x4(%ebx),%eax
  80d6ea:	89 04 24             	mov    %eax,(%esp)
  80d6ed:	e8 31 77 ff ff       	call   804e23 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d6f2:	b0 00                	mov    $0x0,%al
  80d6f4:	e9 b4 01 00 00       	jmp    80d8ad <tcp_receive+0xbf6>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80d6f9:	85 ff                	test   %edi,%edi
  80d6fb:	75 57                	jne    80d754 <tcp_receive+0xa9d>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80d6fd:	39 c1                	cmp    %eax,%ecx
  80d6ff:	0f 89 e6 00 00 00    	jns    80d7eb <tcp_receive+0xb34>
  80d705:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d708:	0f b7 15 fc c1 b3 00 	movzwl 0xb3c1fc,%edx
  80d70f:	01 ca                	add    %ecx,%edx
  80d711:	29 c2                	sub    %eax,%edx
  80d713:	85 d2                	test   %edx,%edx
  80d715:	7e 1d                	jle    80d734 <tcp_receive+0xa7d>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d717:	66 29 c8             	sub    %cx,%ax
  80d71a:	66 a3 fc c1 b3 00    	mov    %ax,0xb3c1fc
                    pbuf_realloc(inseg.p, inseg.len);
  80d720:	0f b7 c0             	movzwl %ax,%eax
  80d723:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d727:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  80d72c:	89 04 24             	mov    %eax,(%esp)
  80d72f:	e8 ef 76 ff ff       	call   804e23 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  80d734:	c7 04 24 f0 c1 b3 00 	movl   $0xb3c1f0,(%esp)
  80d73b:	e8 07 86 ff ff       	call   805d47 <tcp_seg_copy>
                  if (cseg != NULL) {
  80d740:	85 c0                	test   %eax,%eax
  80d742:	0f 84 4b 01 00 00    	je     80d893 <tcp_receive+0xbdc>
                    cseg->next = next;
  80d748:	89 30                	mov    %esi,(%eax)
                    pcb->ooseq = cseg;
  80d74a:	89 43 7c             	mov    %eax,0x7c(%ebx)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d74d:	b0 00                	mov    $0x0,%al
  80d74f:	e9 59 01 00 00       	jmp    80d8ad <tcp_receive+0xbf6>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d754:	8b 57 10             	mov    0x10(%edi),%edx
  80d757:	8b 52 04             	mov    0x4(%edx),%edx
  80d75a:	f7 d2                	not    %edx
  80d75c:	01 ca                	add    %ecx,%edx
  80d75e:	0f 88 87 00 00 00    	js     80d7eb <tcp_receive+0xb34>
  80d764:	89 da                	mov    %ebx,%edx
  80d766:	29 c2                	sub    %eax,%edx
  80d768:	85 d2                	test   %edx,%edx
  80d76a:	7f 7f                	jg     80d7eb <tcp_receive+0xb34>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d76c:	0f b7 15 fc c1 b3 00 	movzwl 0xb3c1fc,%edx
  80d773:	01 ca                	add    %ecx,%edx
  80d775:	29 c2                	sub    %eax,%edx
  80d777:	85 d2                	test   %edx,%edx
  80d779:	7e 1d                	jle    80d798 <tcp_receive+0xae1>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d77b:	66 29 c8             	sub    %cx,%ax
  80d77e:	66 a3 fc c1 b3 00    	mov    %ax,0xb3c1fc
                  pbuf_realloc(inseg.p, inseg.len);
  80d784:	0f b7 c0             	movzwl %ax,%eax
  80d787:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d78b:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  80d790:	89 04 24             	mov    %eax,(%esp)
  80d793:	e8 8b 76 ff ff       	call   804e23 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  80d798:	c7 04 24 f0 c1 b3 00 	movl   $0xb3c1f0,(%esp)
  80d79f:	e8 a3 85 ff ff       	call   805d47 <tcp_seg_copy>
                if (cseg != NULL) {
  80d7a4:	85 c0                	test   %eax,%eax
  80d7a6:	0f 84 eb 00 00 00    	je     80d897 <tcp_receive+0xbe0>
                  cseg->next = next;
  80d7ac:	89 30                	mov    %esi,(%eax)
                  prev->next = cseg;
  80d7ae:	89 07                	mov    %eax,(%edi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d7b0:	8b 47 10             	mov    0x10(%edi),%eax
  80d7b3:	8b 50 04             	mov    0x4(%eax),%edx
  80d7b6:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d7bb:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  80d7bf:	29 c1                	sub    %eax,%ecx
  80d7c1:	01 d1                	add    %edx,%ecx
  80d7c3:	85 c9                	test   %ecx,%ecx
  80d7c5:	0f 8e d0 00 00 00    	jle    80d89b <tcp_receive+0xbe4>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80d7cb:	66 29 d0             	sub    %dx,%ax
  80d7ce:	66 89 47 0c          	mov    %ax,0xc(%edi)
                    pbuf_realloc(prev->p, prev->len);
  80d7d2:	0f b7 c0             	movzwl %ax,%eax
  80d7d5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d7d9:	8b 47 04             	mov    0x4(%edi),%eax
  80d7dc:	89 04 24             	mov    %eax,(%esp)
  80d7df:	e8 3f 76 ff ff       	call   804e23 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d7e4:	b0 00                	mov    $0x0,%al
  80d7e6:	e9 c2 00 00 00       	jmp    80d8ad <tcp_receive+0xbf6>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d7eb:	8b 16                	mov    (%esi),%edx
  80d7ed:	85 d2                	test   %edx,%edx
  80d7ef:	0f 85 5f fe ff ff    	jne    80d654 <tcp_receive+0x99d>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d7f5:	29 c1                	sub    %eax,%ecx
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d7f7:	85 c9                	test   %ecx,%ecx
  80d7f9:	0f 8e a0 00 00 00    	jle    80d89f <tcp_receive+0xbe8>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80d7ff:	c7 04 24 f0 c1 b3 00 	movl   $0xb3c1f0,(%esp)
  80d806:	e8 3c 85 ff ff       	call   805d47 <tcp_seg_copy>
  80d80b:	89 06                	mov    %eax,(%esi)
                if (next->next != NULL) {
  80d80d:	85 c0                	test   %eax,%eax
  80d80f:	0f 84 8e 00 00 00    	je     80d8a3 <tcp_receive+0xbec>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d815:	8b 46 10             	mov    0x10(%esi),%eax
  80d818:	8b 50 04             	mov    0x4(%eax),%edx
  80d81b:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d820:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80d824:	29 c1                	sub    %eax,%ecx
  80d826:	01 d1                	add    %edx,%ecx
  80d828:	85 c9                	test   %ecx,%ecx
  80d82a:	7e 7b                	jle    80d8a7 <tcp_receive+0xbf0>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d82c:	66 29 d0             	sub    %dx,%ax
  80d82f:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(next->p, next->len);
  80d833:	0f b7 c0             	movzwl %ax,%eax
  80d836:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d83a:	8b 46 04             	mov    0x4(%esi),%eax
  80d83d:	89 04 24             	mov    %eax,(%esp)
  80d840:	e8 de 75 ff ff       	call   804e23 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d845:	b0 00                	mov    $0x0,%al
  80d847:	eb 64                	jmp    80d8ad <tcp_receive+0xbf6>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80d849:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d84d:	89 1c 24             	mov    %ebx,(%esp)
  80d850:	e8 e9 ad ff ff       	call   80863e <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d855:	b0 00                	mov    $0x0,%al
  80d857:	eb 54                	jmp    80d8ad <tcp_receive+0xbf6>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d859:	8b 15 e4 c1 b3 00    	mov    0xb3c1e4,%edx
  80d85f:	8b 43 24             	mov    0x24(%ebx),%eax
  80d862:	39 c2                	cmp    %eax,%edx
  80d864:	78 0d                	js     80d873 <tcp_receive+0xbbc>
  80d866:	42                   	inc    %edx
  80d867:	29 c2                	sub    %eax,%edx
  80d869:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
  80d86d:	29 c2                	sub    %eax,%edx
  80d86f:	85 d2                	test   %edx,%edx
  80d871:	7e 38                	jle    80d8ab <tcp_receive+0xbf4>
      tcp_ack_now(pcb);
  80d873:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d877:	89 1c 24             	mov    %ebx,(%esp)
  80d87a:	e8 bf ad ff ff       	call   80863e <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d87f:	b0 00                	mov    $0x0,%al
  80d881:	eb 2a                	jmp    80d8ad <tcp_receive+0xbf6>
  80d883:	b0 00                	mov    $0x0,%al
  80d885:	eb 26                	jmp    80d8ad <tcp_receive+0xbf6>
  80d887:	b0 00                	mov    $0x0,%al
  80d889:	eb 22                	jmp    80d8ad <tcp_receive+0xbf6>
  80d88b:	b0 00                	mov    $0x0,%al
  80d88d:	eb 1e                	jmp    80d8ad <tcp_receive+0xbf6>
  80d88f:	b0 00                	mov    $0x0,%al
  80d891:	eb 1a                	jmp    80d8ad <tcp_receive+0xbf6>
  80d893:	b0 00                	mov    $0x0,%al
  80d895:	eb 16                	jmp    80d8ad <tcp_receive+0xbf6>
  80d897:	b0 00                	mov    $0x0,%al
  80d899:	eb 12                	jmp    80d8ad <tcp_receive+0xbf6>
  80d89b:	b0 00                	mov    $0x0,%al
  80d89d:	eb 0e                	jmp    80d8ad <tcp_receive+0xbf6>
  80d89f:	b0 00                	mov    $0x0,%al
  80d8a1:	eb 0a                	jmp    80d8ad <tcp_receive+0xbf6>
  80d8a3:	b0 00                	mov    $0x0,%al
  80d8a5:	eb 06                	jmp    80d8ad <tcp_receive+0xbf6>
  80d8a7:	b0 00                	mov    $0x0,%al
  80d8a9:	eb 02                	jmp    80d8ad <tcp_receive+0xbf6>
  80d8ab:	b0 00                	mov    $0x0,%al
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  80d8ad:	83 c4 2c             	add    $0x2c,%esp
  80d8b0:	5b                   	pop    %ebx
  80d8b1:	5e                   	pop    %esi
  80d8b2:	5f                   	pop    %edi
  80d8b3:	5d                   	pop    %ebp
  80d8b4:	c3                   	ret    

0080d8b5 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80d8b5:	55                   	push   %ebp
  80d8b6:	89 e5                	mov    %esp,%ebp
  80d8b8:	57                   	push   %edi
  80d8b9:	56                   	push   %esi
  80d8ba:	53                   	push   %ebx
  80d8bb:	83 ec 4c             	sub    $0x4c,%esp
  80d8be:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80d8c1:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d8c4:	89 1d dc c1 b3 00    	mov    %ebx,0xb3c1dc
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d8ca:	0f b7 03             	movzwl (%ebx),%eax
  80d8cd:	89 04 24             	mov    %eax,(%esp)
  80d8d0:	e8 90 a3 ff ff       	call   807c65 <ntohs>
  80d8d5:	c1 e8 06             	shr    $0x6,%eax
  80d8d8:	83 e0 3c             	and    $0x3c,%eax
  80d8db:	01 c3                	add    %eax,%ebx
  80d8dd:	89 1d e0 c1 b3 00    	mov    %ebx,0xb3c1e0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d8e3:	a1 dc c1 b3 00       	mov    0xb3c1dc,%eax
  80d8e8:	0f b7 00             	movzwl (%eax),%eax
  80d8eb:	89 04 24             	mov    %eax,(%esp)
  80d8ee:	e8 72 a3 ff ff       	call   807c65 <ntohs>
  80d8f3:	66 c1 e8 06          	shr    $0x6,%ax
  80d8f7:	83 e0 3c             	and    $0x3c,%eax
  80d8fa:	f7 d8                	neg    %eax
  80d8fc:	98                   	cwtl   
  80d8fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d901:	89 34 24             	mov    %esi,(%esp)
  80d904:	e8 63 73 ff ff       	call   804c6c <pbuf_header>
  80d909:	84 c0                	test   %al,%al
  80d90b:	75 07                	jne    80d914 <tcp_input+0x5f>
  80d90d:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d912:	77 0d                	ja     80d921 <tcp_input+0x6c>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80d914:	89 34 24             	mov    %esi,(%esp)
  80d917:	e8 35 74 ff ff       	call   804d51 <pbuf_free>
    return;
  80d91c:	e9 b9 0c 00 00       	jmp    80e5da <tcp_input+0xd25>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d921:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d924:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d928:	a1 dc c1 b3 00       	mov    0xb3c1dc,%eax
  80d92d:	83 c0 10             	add    $0x10,%eax
  80d930:	89 04 24             	mov    %eax,(%esp)
  80d933:	e8 64 90 ff ff       	call   80699c <ip_addr_isbroadcast>
  80d938:	84 c0                	test   %al,%al
  80d93a:	75 26                	jne    80d962 <tcp_input+0xad>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d93c:	a1 dc c1 b3 00       	mov    0xb3c1dc,%eax
  80d941:	8b 58 10             	mov    0x10(%eax),%ebx
  80d944:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80d94b:	e8 7f a5 ff ff       	call   807ecf <ntohl>
  80d950:	21 c3                	and    %eax,%ebx
  80d952:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d959:	e8 71 a5 ff ff       	call   807ecf <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d95e:	39 c3                	cmp    %eax,%ebx
  80d960:	75 0d                	jne    80d96f <tcp_input+0xba>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80d962:	89 34 24             	mov    %esi,(%esp)
  80d965:	e8 e7 73 ff ff       	call   804d51 <pbuf_free>
    return;
  80d96a:	e9 6b 0c 00 00       	jmp    80e5da <tcp_input+0xd25>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80d96f:	a1 dc c1 b3 00       	mov    0xb3c1dc,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d974:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d978:	89 54 24 10          	mov    %edx,0x10(%esp)
  80d97c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80d983:	00 
  80d984:	8d 50 10             	lea    0x10(%eax),%edx
  80d987:	89 54 24 08          	mov    %edx,0x8(%esp)
  80d98b:	83 c0 0c             	add    $0xc,%eax
  80d98e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d992:	89 34 24             	mov    %esi,(%esp)
  80d995:	e8 7a 9f ff ff       	call   807914 <inet_chksum_pseudo>
  80d99a:	66 85 c0             	test   %ax,%ax
  80d99d:	74 0d                	je     80d9ac <tcp_input+0xf7>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80d99f:	89 34 24             	mov    %esi,(%esp)
  80d9a2:	e8 aa 73 ff ff       	call   804d51 <pbuf_free>
    return;
  80d9a7:	e9 2e 0c 00 00       	jmp    80e5da <tcp_input+0xd25>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d9ac:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  80d9b1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d9b5:	89 04 24             	mov    %eax,(%esp)
  80d9b8:	e8 a8 a2 ff ff       	call   807c65 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d9bd:	66 c1 e8 0c          	shr    $0xc,%ax
  80d9c1:	f7 d8                	neg    %eax
  80d9c3:	c1 e0 02             	shl    $0x2,%eax
  80d9c6:	98                   	cwtl   
  80d9c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d9cb:	89 34 24             	mov    %esi,(%esp)
  80d9ce:	e8 99 72 ff ff       	call   804c6c <pbuf_header>
  80d9d3:	84 c0                	test   %al,%al
  80d9d5:	74 0d                	je     80d9e4 <tcp_input+0x12f>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80d9d7:	89 34 24             	mov    %esi,(%esp)
  80d9da:	e8 72 73 ff ff       	call   804d51 <pbuf_free>
    return;
  80d9df:	e9 f6 0b 00 00       	jmp    80e5da <tcp_input+0xd25>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80d9e4:	8b 1d e0 c1 b3 00    	mov    0xb3c1e0,%ebx
  80d9ea:	0f b7 03             	movzwl (%ebx),%eax
  80d9ed:	89 04 24             	mov    %eax,(%esp)
  80d9f0:	e8 70 a2 ff ff       	call   807c65 <ntohs>
  80d9f5:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d9f8:	8b 1d e0 c1 b3 00    	mov    0xb3c1e0,%ebx
  80d9fe:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80da02:	89 04 24             	mov    %eax,(%esp)
  80da05:	e8 5b a2 ff ff       	call   807c65 <ntohs>
  80da0a:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80da0e:	8b 1d e0 c1 b3 00    	mov    0xb3c1e0,%ebx
  80da14:	8b 43 04             	mov    0x4(%ebx),%eax
  80da17:	89 04 24             	mov    %eax,(%esp)
  80da1a:	e8 b0 a4 ff ff       	call   807ecf <ntohl>
  80da1f:	89 43 04             	mov    %eax,0x4(%ebx)
  80da22:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80da27:	8b 1d e0 c1 b3 00    	mov    0xb3c1e0,%ebx
  80da2d:	8b 43 08             	mov    0x8(%ebx),%eax
  80da30:	89 04 24             	mov    %eax,(%esp)
  80da33:	e8 97 a4 ff ff       	call   807ecf <ntohl>
  80da38:	89 43 08             	mov    %eax,0x8(%ebx)
  80da3b:	a3 e8 c1 b3 00       	mov    %eax,0xb3c1e8
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80da40:	8b 1d e0 c1 b3 00    	mov    0xb3c1e0,%ebx
  80da46:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80da4a:	89 04 24             	mov    %eax,(%esp)
  80da4d:	e8 13 a2 ff ff       	call   807c65 <ntohs>
  80da52:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80da56:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  80da5b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80da5f:	89 04 24             	mov    %eax,(%esp)
  80da62:	e8 fe a1 ff ff       	call   807c65 <ntohs>
  80da67:	83 e0 3f             	and    $0x3f,%eax
  80da6a:	88 45 d7             	mov    %al,-0x29(%ebp)
  80da6d:	a2 ec c1 b3 00       	mov    %al,0xb3c1ec
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80da72:	8b 46 08             	mov    0x8(%esi),%eax
  80da75:	f6 45 d7 01          	testb  $0x1,-0x29(%ebp)
  80da79:	75 0c                	jne    80da87 <tcp_input+0x1d2>
  80da7b:	f6 45 d7 02          	testb  $0x2,-0x29(%ebp)
  80da7f:	0f 95 c2             	setne  %dl
  80da82:	0f b6 d2             	movzbl %dl,%edx
  80da85:	eb 05                	jmp    80da8c <tcp_input+0x1d7>
  80da87:	ba 01 00 00 00       	mov    $0x1,%edx
  80da8c:	01 d0                	add    %edx,%eax
  80da8e:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80da92:	66 a3 ee c1 b3 00    	mov    %ax,0xb3c1ee
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80da98:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  80da9d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80daa0:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80daa5:	8b 15 dc c1 b3 00    	mov    0xb3c1dc,%edx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80daab:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80daae:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dab3:	e9 e1 00 00 00       	jmp    80db99 <tcp_input+0x2e4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80dab8:	8b 4b 10             	mov    0x10(%ebx),%ecx
  80dabb:	85 c9                	test   %ecx,%ecx
  80dabd:	75 1c                	jne    80dadb <tcp_input+0x226>
  80dabf:	c7 44 24 08 fc 3b 81 	movl   $0x813bfc,0x8(%esp)
  80dac6:	00 
  80dac7:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80dace:	00 
  80dacf:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80dad6:	e8 a5 13 00 00       	call   80ee80 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80dadb:	83 f9 0a             	cmp    $0xa,%ecx
  80dade:	75 1c                	jne    80dafc <tcp_input+0x247>
  80dae0:	c7 44 24 08 24 3c 81 	movl   $0x813c24,0x8(%esp)
  80dae7:	00 
  80dae8:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  80daef:	00 
  80daf0:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80daf7:	e8 84 13 00 00       	call   80ee80 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80dafc:	83 f9 01             	cmp    $0x1,%ecx
  80daff:	75 1c                	jne    80db1d <tcp_input+0x268>
  80db01:	c7 44 24 08 50 3c 81 	movl   $0x813c50,0x8(%esp)
  80db08:	00 
  80db09:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  80db10:	00 
  80db11:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80db18:	e8 63 13 00 00       	call   80ee80 <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80db1d:	8b 08                	mov    (%eax),%ecx
  80db1f:	66 39 4b 1e          	cmp    %cx,0x1e(%ebx)
  80db23:	75 6f                	jne    80db94 <tcp_input+0x2df>
  80db25:	66 8b 48 02          	mov    0x2(%eax),%cx
  80db29:	66 39 4b 1c          	cmp    %cx,0x1c(%ebx)
  80db2d:	75 65                	jne    80db94 <tcp_input+0x2df>
       pcb->local_port == tcphdr->dest &&
  80db2f:	8b 4a 0c             	mov    0xc(%edx),%ecx
  80db32:	39 4b 04             	cmp    %ecx,0x4(%ebx)
  80db35:	75 5d                	jne    80db94 <tcp_input+0x2df>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80db37:	8b 4a 10             	mov    0x10(%edx),%ecx
  80db3a:	39 0b                	cmp    %ecx,(%ebx)
  80db3c:	75 56                	jne    80db94 <tcp_input+0x2df>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80db3e:	8b 43 0c             	mov    0xc(%ebx),%eax
  80db41:	39 d8                	cmp    %ebx,%eax
  80db43:	75 1c                	jne    80db61 <tcp_input+0x2ac>
  80db45:	c7 44 24 08 78 3c 81 	movl   $0x813c78,0x8(%esp)
  80db4c:	00 
  80db4d:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  80db54:	00 
  80db55:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80db5c:	e8 1f 13 00 00       	call   80ee80 <_panic>
      if (prev != NULL) {
  80db61:	85 ff                	test   %edi,%edi
  80db63:	74 41                	je     80dba6 <tcp_input+0x2f1>
        prev->next = pcb->next;
  80db65:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80db68:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80db6b:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80db6e:	89 1d 7c c2 b3 00    	mov    %ebx,0xb3c27c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80db74:	39 d8                	cmp    %ebx,%eax
  80db76:	75 2e                	jne    80dba6 <tcp_input+0x2f1>
  80db78:	c7 44 24 08 a4 3c 81 	movl   $0x813ca4,0x8(%esp)
  80db7f:	00 
  80db80:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  80db87:	00 
  80db88:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80db8f:	e8 ec 12 00 00       	call   80ee80 <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80db94:	89 df                	mov    %ebx,%edi
  80db96:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80db99:	85 db                	test   %ebx,%ebx
  80db9b:	0f 85 17 ff ff ff    	jne    80dab8 <tcp_input+0x203>
  80dba1:	e9 08 0a 00 00       	jmp    80e5ae <tcp_input+0xcf9>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80dba6:	c7 05 f0 c1 b3 00 00 	movl   $0x0,0xb3c1f0
  80dbad:	00 00 00 
    inseg.len = p->tot_len;
  80dbb0:	8b 46 08             	mov    0x8(%esi),%eax
  80dbb3:	66 a3 fc c1 b3 00    	mov    %ax,0xb3c1fc
    inseg.dataptr = p->payload;
  80dbb9:	8b 46 04             	mov    0x4(%esi),%eax
  80dbbc:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8
    inseg.p = p;
  80dbc1:	89 35 f4 c1 b3 00    	mov    %esi,0xb3c1f4
    inseg.tcphdr = tcphdr;
  80dbc7:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  80dbcc:	a3 00 c2 b3 00       	mov    %eax,0xb3c200

    recv_data = NULL;
  80dbd1:	c7 05 04 c2 b3 00 00 	movl   $0x0,0xb3c204
  80dbd8:	00 00 00 
    recv_flags = 0;
  80dbdb:	c6 05 08 c2 b3 00 00 	movb   $0x0,0xb3c208

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80dbe2:	8b 93 80 00 00 00    	mov    0x80(%ebx),%edx
  80dbe8:	85 d2                	test   %edx,%edx
  80dbea:	0f 85 5f 02 00 00    	jne    80de4f <tcp_input+0x59a>
  80dbf0:	e9 a3 02 00 00       	jmp    80de98 <tcp_input+0x5e3>

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80dbf5:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80dbf9:	74 1c                	je     80dc17 <tcp_input+0x362>
  80dbfb:	c7 44 24 08 d0 3c 81 	movl   $0x813cd0,0x8(%esp)
  80dc02:	00 
  80dc03:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  80dc0a:	00 
  80dc0b:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80dc12:	e8 69 12 00 00       	call   80ee80 <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80dc17:	8b 08                	mov    (%eax),%ecx
  80dc19:	66 39 4b 1e          	cmp    %cx,0x1e(%ebx)
  80dc1d:	75 57                	jne    80dc76 <tcp_input+0x3c1>
  80dc1f:	66 8b 48 02          	mov    0x2(%eax),%cx
  80dc23:	66 39 4b 1c          	cmp    %cx,0x1c(%ebx)
  80dc27:	75 4d                	jne    80dc76 <tcp_input+0x3c1>
         pcb->local_port == tcphdr->dest &&
  80dc29:	8b 4a 0c             	mov    0xc(%edx),%ecx
  80dc2c:	39 4b 04             	cmp    %ecx,0x4(%ebx)
  80dc2f:	75 45                	jne    80dc76 <tcp_input+0x3c1>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dc31:	8b 4a 10             	mov    0x10(%edx),%ecx
  80dc34:	39 0b                	cmp    %ecx,(%ebx)
  80dc36:	75 3e                	jne    80dc76 <tcp_input+0x3c1>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80dc38:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80dc3c:	03 05 e4 c1 b3 00    	add    0xb3c1e4,%eax
  80dc42:	89 c2                	mov    %eax,%edx
  80dc44:	2b 53 24             	sub    0x24(%ebx),%edx
  80dc47:	85 d2                	test   %edx,%edx
  80dc49:	7e 03                	jle    80dc4e <tcp_input+0x399>
    pcb->rcv_nxt = seqno + tcplen;
  80dc4b:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80dc4e:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80dc53:	74 0c                	je     80dc61 <tcp_input+0x3ac>
    tcp_ack_now(pcb);
  80dc55:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dc59:	89 1c 24             	mov    %ebx,(%esp)
  80dc5c:	e8 dd a9 ff ff       	call   80863e <tcp_output>
  }
  return tcp_output(pcb);
  80dc61:	89 1c 24             	mov    %ebx,(%esp)
  80dc64:	e8 d5 a9 ff ff       	call   80863e <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80dc69:	89 34 24             	mov    %esi,(%esp)
  80dc6c:	e8 e0 70 ff ff       	call   804d51 <pbuf_free>
        return;
  80dc71:	e9 64 09 00 00       	jmp    80e5da <tcp_input+0xd25>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc76:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80dc79:	85 db                	test   %ebx,%ebx
  80dc7b:	0f 85 74 ff ff ff    	jne    80dbf5 <tcp_input+0x340>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80dc81:	8b 0d 84 c2 b3 00    	mov    0xb3c284,%ecx
  80dc87:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  80dc8a:	89 cb                	mov    %ecx,%ebx
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80dc8c:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80dc91:	e9 ac 01 00 00       	jmp    80de42 <tcp_input+0x58d>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80dc96:	85 db                	test   %ebx,%ebx
  80dc98:	74 0f                	je     80dca9 <tcp_input+0x3f4>
  80dc9a:	8b 0b                	mov    (%ebx),%ecx
  80dc9c:	85 c9                	test   %ecx,%ecx
  80dc9e:	74 09                	je     80dca9 <tcp_input+0x3f4>
  80dca0:	3b 4a 10             	cmp    0x10(%edx),%ecx
  80dca3:	0f 85 94 01 00 00    	jne    80de3d <tcp_input+0x588>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80dca9:	66 8b 48 02          	mov    0x2(%eax),%cx
  80dcad:	66 39 4b 1c          	cmp    %cx,0x1c(%ebx)
  80dcb1:	0f 85 86 01 00 00    	jne    80de3d <tcp_input+0x588>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80dcb7:	85 ff                	test   %edi,%edi
  80dcb9:	74 12                	je     80dccd <tcp_input+0x418>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80dcbb:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dcbe:	89 57 0c             	mov    %edx,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80dcc1:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80dcc4:	89 53 0c             	mov    %edx,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80dcc7:	89 1d 84 c2 b3 00    	mov    %ebx,0xb3c284
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80dccd:	0f b6 55 d7          	movzbl -0x29(%ebp),%edx
  80dcd1:	f6 c2 10             	test   $0x10,%dl
  80dcd4:	74 44                	je     80dd1a <tcp_input+0x465>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  80dcd6:	8b 15 dc c1 b3 00    	mov    0xb3c1dc,%edx
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80dcdc:	0f b7 08             	movzwl (%eax),%ecx
  80dcdf:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80dce3:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  80dce7:	89 44 24 10          	mov    %eax,0x10(%esp)
  80dceb:	8d 42 0c             	lea    0xc(%edx),%eax
  80dcee:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80dcf2:	83 c2 10             	add    $0x10,%edx
  80dcf5:	89 54 24 08          	mov    %edx,0x8(%esp)
  80dcf9:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80dcfd:	03 05 e4 c1 b3 00    	add    0xb3c1e4,%eax
  80dd03:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dd07:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80dd0c:	40                   	inc    %eax
  80dd0d:	89 04 24             	mov    %eax,(%esp)
  80dd10:	e8 b3 ad ff ff       	call   808ac8 <tcp_rst>
  80dd15:	e9 16 01 00 00       	jmp    80de30 <tcp_input+0x57b>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80dd1a:	f6 c2 02             	test   $0x2,%dl
  80dd1d:	0f 84 0d 01 00 00    	je     80de30 <tcp_input+0x57b>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80dd23:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80dd27:	89 04 24             	mov    %eax,(%esp)
  80dd2a:	e8 3f 89 ff ff       	call   80666e <tcp_alloc>
  80dd2f:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80dd31:	85 c0                	test   %eax,%eax
  80dd33:	0f 84 f7 00 00 00    	je     80de30 <tcp_input+0x57b>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80dd39:	a1 dc c1 b3 00       	mov    0xb3c1dc,%eax
  80dd3e:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80dd41:	74 05                	je     80dd48 <tcp_input+0x493>
  80dd43:	8b 50 10             	mov    0x10(%eax),%edx
  80dd46:	eb 05                	jmp    80dd4d <tcp_input+0x498>
  80dd48:	ba 00 00 00 00       	mov    $0x0,%edx
  80dd4d:	89 17                	mov    %edx,(%edi)
    npcb->local_port = pcb->local_port;
  80dd4f:	8b 53 1c             	mov    0x1c(%ebx),%edx
  80dd52:	66 89 57 1c          	mov    %dx,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80dd56:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80dd59:	74 05                	je     80dd60 <tcp_input+0x4ab>
  80dd5b:	8b 40 0c             	mov    0xc(%eax),%eax
  80dd5e:	eb 05                	jmp    80dd65 <tcp_input+0x4b0>
  80dd60:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd65:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80dd68:	8b 15 e0 c1 b3 00    	mov    0xb3c1e0,%edx
  80dd6e:	8b 02                	mov    (%edx),%eax
  80dd70:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80dd74:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80dd7b:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80dd80:	8d 48 01             	lea    0x1(%eax),%ecx
  80dd83:	89 4f 24             	mov    %ecx,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80dd86:	66 8b 52 0e          	mov    0xe(%edx),%dx
  80dd8a:	66 89 57 5c          	mov    %dx,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80dd8e:	66 89 57 50          	mov    %dx,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80dd92:	48                   	dec    %eax
  80dd93:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80dd96:	8b 43 18             	mov    0x18(%ebx),%eax
  80dd99:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80dd9c:	8b 43 20             	mov    0x20(%ebx),%eax
  80dd9f:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80dda5:	8b 43 08             	mov    0x8(%ebx),%eax
  80dda8:	25 99 01 00 00       	and    $0x199,%eax
  80ddad:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80ddb1:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  80ddb6:	89 47 0c             	mov    %eax,0xc(%edi)
  80ddb9:	89 3d 7c c2 b3 00    	mov    %edi,0xb3c27c
  80ddbf:	e8 6a 47 ff ff       	call   80252e <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80ddc4:	89 f8                	mov    %edi,%eax
  80ddc6:	e8 49 ee ff ff       	call   80cc14 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80ddcb:	8d 47 04             	lea    0x4(%edi),%eax
  80ddce:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ddd2:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80ddd6:	89 04 24             	mov    %eax,(%esp)
  80ddd9:	e8 18 8a ff ff       	call   8067f6 <tcp_eff_send_mss>
  80ddde:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80dde2:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80dde9:	e8 8b 9e ff ff       	call   807c79 <htonl>
  80ddee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80ddf1:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  80ddf8:	00 
  80ddf9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ddfc:	89 44 24 14          	mov    %eax,0x14(%esp)
  80de00:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80de07:	00 
  80de08:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  80de0f:	00 
  80de10:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80de17:	00 
  80de18:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80de1f:	00 
  80de20:	89 3c 24             	mov    %edi,(%esp)
  80de23:	e8 bc a0 ff ff       	call   807ee4 <tcp_enqueue>
    return tcp_output(npcb);
  80de28:	89 3c 24             	mov    %edi,(%esp)
  80de2b:	e8 0e a8 ff ff       	call   80863e <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80de30:	89 34 24             	mov    %esi,(%esp)
  80de33:	e8 19 6f ff ff       	call   804d51 <pbuf_free>
        return;
  80de38:	e9 9d 07 00 00       	jmp    80e5da <tcp_input+0xd25>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80de3d:	89 df                	mov    %ebx,%edi
  80de3f:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80de42:	85 db                	test   %ebx,%ebx
  80de44:	0f 85 4c fe ff ff    	jne    80dc96 <tcp_input+0x3e1>
  80de4a:	e9 6a 07 00 00       	jmp    80e5b9 <tcp_input+0xd04>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80de4f:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80de55:	85 c0                	test   %eax,%eax
  80de57:	74 1e                	je     80de77 <tcp_input+0x5c2>
  80de59:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80de60:	00 
  80de61:	89 54 24 08          	mov    %edx,0x8(%esp)
  80de65:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80de69:	8b 53 18             	mov    0x18(%ebx),%edx
  80de6c:	89 14 24             	mov    %edx,(%esp)
  80de6f:	ff d0                	call   *%eax
      if (err == ERR_OK) {
  80de71:	84 c0                	test   %al,%al
  80de73:	74 0a                	je     80de7f <tcp_input+0x5ca>
  80de75:	eb 14                	jmp    80de8b <tcp_input+0x5d6>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80de77:	89 14 24             	mov    %edx,(%esp)
  80de7a:	e8 d2 6e ff ff       	call   804d51 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80de7f:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80de86:	00 00 00 
  80de89:	eb 0d                	jmp    80de98 <tcp_input+0x5e3>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80de8b:	89 34 24             	mov    %esi,(%esp)
  80de8e:	e8 be 6e ff ff       	call   804d51 <pbuf_free>
        return;
  80de93:	e9 42 07 00 00       	jmp    80e5da <tcp_input+0xd25>
      }
    }

    tcp_input_pcb = pcb;
  80de98:	89 1d 98 c2 b3 00    	mov    %ebx,0xb3c298
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80de9e:	0f b6 05 ec c1 b3 00 	movzbl 0xb3c1ec,%eax
  80dea5:	a8 04                	test   $0x4,%al
  80dea7:	74 68                	je     80df11 <tcp_input+0x65c>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80dea9:	8b 43 10             	mov    0x10(%ebx),%eax
  80deac:	83 f8 02             	cmp    $0x2,%eax
  80deaf:	75 0e                	jne    80debf <tcp_input+0x60a>
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  80deb1:	8b 0d e8 c1 b3 00    	mov    0xb3c1e8,%ecx
  80deb7:	39 4b 54             	cmp    %ecx,0x54(%ebx)
  80deba:	0f 94 c2             	sete   %dl
  80debd:	eb 1a                	jmp    80ded9 <tcp_input+0x624>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80debf:	8b 15 e4 c1 b3 00    	mov    0xb3c1e4,%edx
  80dec5:	2b 53 24             	sub    0x24(%ebx),%edx
  80dec8:	0f 88 fd 06 00 00    	js     80e5cb <tcp_input+0xd16>
  80dece:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80ded2:	29 ca                	sub    %ecx,%edx
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  80ded4:	85 d2                	test   %edx,%edx
  80ded6:	0f 9e c2             	setle  %dl
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80ded9:	84 d2                	test   %dl,%dl
  80dedb:	0f 84 ea 06 00 00    	je     80e5cb <tcp_input+0xd16>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80dee1:	85 c0                	test   %eax,%eax
  80dee3:	75 1c                	jne    80df01 <tcp_input+0x64c>
  80dee5:	c7 44 24 08 00 3d 81 	movl   $0x813d00,0x8(%esp)
  80deec:	00 
  80deed:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  80def4:	00 
  80def5:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80defc:	e8 7f 0f 00 00       	call   80ee80 <_panic>
      recv_flags = TF_RESET;
  80df01:	c6 05 08 c2 b3 00 08 	movb   $0x8,0xb3c208
      pcb->flags &= ~TF_ACK_DELAY;
  80df08:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80df0c:	e9 ba 06 00 00       	jmp    80e5cb <tcp_input+0xd16>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80df11:	8b 15 80 c2 b3 00    	mov    0xb3c280,%edx
  80df17:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80df1a:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80df21:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80df25:	0f 87 d6 04 00 00    	ja     80e401 <tcp_input+0xb4c>
  80df2b:	8b 53 10             	mov    0x10(%ebx),%edx
  80df2e:	ff 24 95 a4 3d 81 00 	jmp    *0x813da4(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80df35:	83 e0 12             	and    $0x12,%eax
  80df38:	83 f8 12             	cmp    $0x12,%eax
  80df3b:	0f 85 fc 00 00 00    	jne    80e03d <tcp_input+0x788>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80df41:	8b 43 78             	mov    0x78(%ebx),%eax
  80df44:	8b 40 10             	mov    0x10(%eax),%eax
  80df47:	8b 40 04             	mov    0x4(%eax),%eax
  80df4a:	89 04 24             	mov    %eax,(%esp)
  80df4d:	e8 7d 9f ff ff       	call   807ecf <ntohl>
  80df52:	8d 50 01             	lea    0x1(%eax),%edx
  80df55:	3b 15 e8 c1 b3 00    	cmp    0xb3c1e8,%edx
  80df5b:	0f 85 dc 00 00 00    	jne    80e03d <tcp_input+0x788>
      pcb->snd_buf++;
  80df61:	66 ff 43 6e          	incw   0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80df65:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80df6a:	8d 48 01             	lea    0x1(%eax),%ecx
  80df6d:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80df70:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80df73:	8b 15 e0 c1 b3 00    	mov    0xb3c1e0,%edx
  80df79:	66 8b 52 0e          	mov    0xe(%edx),%dx
  80df7d:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80df81:	48                   	dec    %eax
  80df82:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80df85:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80df8c:	89 d8                	mov    %ebx,%eax
  80df8e:	e8 81 ec ff ff       	call   80cc14 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80df93:	8d 43 04             	lea    0x4(%ebx),%eax
  80df96:	89 44 24 04          	mov    %eax,0x4(%esp)
  80df9a:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80df9e:	89 04 24             	mov    %eax,(%esp)
  80dfa1:	e8 50 88 ff ff       	call   8067f6 <tcp_eff_send_mss>
  80dfa6:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80dfaa:	66 6b d0 0a          	imul   $0xa,%ax,%dx
  80dfae:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80dfb2:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80dfb7:	75 02                	jne    80dfbb <tcp_input+0x706>
  80dfb9:	d1 e0                	shl    %eax
  80dfbb:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80dfbf:	8b 43 70             	mov    0x70(%ebx),%eax
  80dfc2:	66 85 c0             	test   %ax,%ax
  80dfc5:	75 1c                	jne    80dfe3 <tcp_input+0x72e>
  80dfc7:	c7 44 24 08 79 3d 81 	movl   $0x813d79,0x8(%esp)
  80dfce:	00 
  80dfcf:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  80dfd6:	00 
  80dfd7:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80dfde:	e8 9d 0e 00 00       	call   80ee80 <_panic>
      --pcb->snd_queuelen;
  80dfe3:	48                   	dec    %eax
  80dfe4:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80dfe8:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80dfeb:	8b 10                	mov    (%eax),%edx
  80dfed:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80dff0:	85 d2                	test   %edx,%edx
  80dff2:	75 08                	jne    80dffc <tcp_input+0x747>
        pcb->rtime = -1;
  80dff4:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80dffa:	eb 0a                	jmp    80e006 <tcp_input+0x751>
      else {
        pcb->rtime = 0;
  80dffc:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80e002:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80e006:	89 04 24             	mov    %eax,(%esp)
  80e009:	e8 b7 7c ff ff       	call   805cc5 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80e00e:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80e014:	85 c0                	test   %eax,%eax
  80e016:	74 14                	je     80e02c <tcp_input+0x777>
  80e018:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e01f:	00 
  80e020:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e024:	8b 53 18             	mov    0x18(%ebx),%edx
  80e027:	89 14 24             	mov    %edx,(%esp)
  80e02a:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  80e02c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e030:	89 1c 24             	mov    %ebx,(%esp)
  80e033:	e8 06 a6 ff ff       	call   80863e <tcp_output>
  80e038:	e9 8e 05 00 00       	jmp    80e5cb <tcp_input+0xd16>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80e03d:	f6 05 ec c1 b3 00 10 	testb  $0x10,0xb3c1ec
  80e044:	0f 84 81 05 00 00    	je     80e5cb <tcp_input+0xd16>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e04a:	8b 15 e0 c1 b3 00    	mov    0xb3c1e0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e050:	a1 dc c1 b3 00       	mov    0xb3c1dc,%eax
  80e055:	0f b7 0a             	movzwl (%edx),%ecx
  80e058:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e05c:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e060:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e064:	8d 50 0c             	lea    0xc(%eax),%edx
  80e067:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e06b:	83 c0 10             	add    $0x10,%eax
  80e06e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e072:	0f b7 05 ee c1 b3 00 	movzwl 0xb3c1ee,%eax
  80e079:	03 05 e4 c1 b3 00    	add    0xb3c1e4,%eax
  80e07f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e083:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80e088:	89 04 24             	mov    %eax,(%esp)
  80e08b:	e8 38 aa ff ff       	call   808ac8 <tcp_rst>
  80e090:	e9 36 05 00 00       	jmp    80e5cb <tcp_input+0xd16>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80e095:	83 e0 14             	and    $0x14,%eax
  80e098:	83 f8 10             	cmp    $0x10,%eax
  80e09b:	0f 85 2a 05 00 00    	jne    80e5cb <tcp_input+0xd16>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80e0a1:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80e0a6:	8b 53 48             	mov    0x48(%ebx),%edx
  80e0a9:	f7 d2                	not    %edx
  80e0ab:	01 c2                	add    %eax,%edx
  80e0ad:	0f 88 b5 00 00 00    	js     80e168 <tcp_input+0x8b3>
  80e0b3:	89 c2                	mov    %eax,%edx
  80e0b5:	2b 53 54             	sub    0x54(%ebx),%edx
  80e0b8:	85 d2                	test   %edx,%edx
  80e0ba:	0f 8f a8 00 00 00    	jg     80e168 <tcp_input+0x8b3>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80e0c0:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80e0c7:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80e0cd:	85 c0                	test   %eax,%eax
  80e0cf:	75 1c                	jne    80e0ed <tcp_input+0x838>
  80e0d1:	c7 44 24 08 8f 3d 81 	movl   $0x813d8f,0x8(%esp)
  80e0d8:	00 
  80e0d9:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  80e0e0:	00 
  80e0e1:	c7 04 24 20 3d 81 00 	movl   $0x813d20,(%esp)
  80e0e8:	e8 93 0d 00 00       	call   80ee80 <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80e0ed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e0f4:	00 
  80e0f5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e0f9:	8b 53 18             	mov    0x18(%ebx),%edx
  80e0fc:	89 14 24             	mov    %edx,(%esp)
  80e0ff:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80e101:	84 c0                	test   %al,%al
  80e103:	74 17                	je     80e11c <tcp_input+0x867>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80e105:	89 1c 24             	mov    %ebx,(%esp)
  80e108:	e8 55 7e ff ff       	call   805f62 <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e10d:	c7 05 98 c2 b3 00 00 	movl   $0x0,0xb3c298
  80e114:	00 00 00 
  80e117:	e9 21 04 00 00       	jmp    80e53d <tcp_input+0xc88>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80e11c:	66 8b 73 4e          	mov    0x4e(%ebx),%si
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80e120:	89 d8                	mov    %ebx,%eax
  80e122:	e8 90 eb ff ff       	call   80ccb7 <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80e127:	66 83 fe 01          	cmp    $0x1,%si
  80e12b:	75 07                	jne    80e134 <tcp_input+0x87f>
  80e12d:	8b 53 34             	mov    0x34(%ebx),%edx
  80e130:	d1 e2                	shl    %edx
  80e132:	eb 03                	jmp    80e137 <tcp_input+0x882>
  80e134:	8b 53 34             	mov    0x34(%ebx),%edx
  80e137:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80e13b:	f6 05 ec c1 b3 00 01 	testb  $0x1,0xb3c1ec
  80e142:	0f 84 83 04 00 00    	je     80e5cb <tcp_input+0xd16>
  80e148:	84 c0                	test   %al,%al
  80e14a:	0f 84 7b 04 00 00    	je     80e5cb <tcp_input+0xd16>
          tcp_ack_now(pcb);
  80e150:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e154:	89 1c 24             	mov    %ebx,(%esp)
  80e157:	e8 e2 a4 ff ff       	call   80863e <tcp_output>
          pcb->state = CLOSE_WAIT;
  80e15c:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e163:	e9 63 04 00 00       	jmp    80e5cb <tcp_input+0xd16>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80e168:	8b 0d e0 c1 b3 00    	mov    0xb3c1e0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e16e:	8b 15 dc c1 b3 00    	mov    0xb3c1dc,%edx
  80e174:	0f b7 31             	movzwl (%ecx),%esi
  80e177:	89 74 24 14          	mov    %esi,0x14(%esp)
  80e17b:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80e17f:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  80e183:	8d 4a 0c             	lea    0xc(%edx),%ecx
  80e186:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80e18a:	83 c2 10             	add    $0x10,%edx
  80e18d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e191:	0f b7 15 ee c1 b3 00 	movzwl 0xb3c1ee,%edx
  80e198:	03 15 e4 c1 b3 00    	add    0xb3c1e4,%edx
  80e19e:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e1a2:	89 04 24             	mov    %eax,(%esp)
  80e1a5:	e8 1e a9 ff ff       	call   808ac8 <tcp_rst>
  80e1aa:	e9 1c 04 00 00       	jmp    80e5cb <tcp_input+0xd16>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80e1af:	89 d8                	mov    %ebx,%eax
  80e1b1:	e8 01 eb ff ff       	call   80ccb7 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80e1b6:	f6 05 ec c1 b3 00 01 	testb  $0x1,0xb3c1ec
  80e1bd:	0f 84 08 04 00 00    	je     80e5cb <tcp_input+0xd16>
  80e1c3:	84 c0                	test   %al,%al
  80e1c5:	0f 84 00 04 00 00    	je     80e5cb <tcp_input+0xd16>
      tcp_ack_now(pcb);
  80e1cb:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e1cf:	89 1c 24             	mov    %ebx,(%esp)
  80e1d2:	e8 67 a4 ff ff       	call   80863e <tcp_output>
      pcb->state = CLOSE_WAIT;
  80e1d7:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e1de:	e9 e8 03 00 00       	jmp    80e5cb <tcp_input+0xd16>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80e1e3:	89 d8                	mov    %ebx,%eax
  80e1e5:	e8 cd ea ff ff       	call   80ccb7 <tcp_receive>
    if (flags & TCP_FIN) {
  80e1ea:	a0 ec c1 b3 00       	mov    0xb3c1ec,%al
  80e1ef:	a8 01                	test   $0x1,%al
  80e1f1:	0f 84 9a 00 00 00    	je     80e291 <tcp_input+0x9dc>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e1f7:	a8 10                	test   $0x10,%al
  80e1f9:	74 7e                	je     80e279 <tcp_input+0x9c4>
  80e1fb:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80e200:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e203:	75 74                	jne    80e279 <tcp_input+0x9c4>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80e205:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e209:	89 1c 24             	mov    %ebx,(%esp)
  80e20c:	e8 2d a4 ff ff       	call   80863e <tcp_output>
        tcp_pcb_purge(pcb);
  80e211:	89 1c 24             	mov    %ebx,(%esp)
  80e214:	e8 d7 7b ff ff       	call   805df0 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80e219:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  80e21e:	39 c3                	cmp    %eax,%ebx
  80e220:	75 0a                	jne    80e22c <tcp_input+0x977>
  80e222:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e225:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c
  80e22a:	eb 2e                	jmp    80e25a <tcp_input+0x9a5>
  80e22c:	a3 88 c2 b3 00       	mov    %eax,0xb3c288
  80e231:	eb 1e                	jmp    80e251 <tcp_input+0x99c>
  80e233:	8b 50 0c             	mov    0xc(%eax),%edx
  80e236:	85 d2                	test   %edx,%edx
  80e238:	74 11                	je     80e24b <tcp_input+0x996>
  80e23a:	39 d3                	cmp    %edx,%ebx
  80e23c:	75 11                	jne    80e24f <tcp_input+0x99a>
  80e23e:	a3 88 c2 b3 00       	mov    %eax,0xb3c288
  80e243:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e246:	89 50 0c             	mov    %edx,0xc(%eax)
  80e249:	eb 0f                	jmp    80e25a <tcp_input+0x9a5>
  80e24b:	89 d0                	mov    %edx,%eax
  80e24d:	eb 02                	jmp    80e251 <tcp_input+0x99c>
  80e24f:	89 d0                	mov    %edx,%eax
  80e251:	85 c0                	test   %eax,%eax
  80e253:	75 de                	jne    80e233 <tcp_input+0x97e>
  80e255:	a3 88 c2 b3 00       	mov    %eax,0xb3c288
        pcb->state = TIME_WAIT;
  80e25a:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80e261:	a1 90 c2 b3 00       	mov    0xb3c290,%eax
  80e266:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e269:	89 1d 90 c2 b3 00    	mov    %ebx,0xb3c290
  80e26f:	e8 ba 42 ff ff       	call   80252e <tcp_timer_needed>
  80e274:	e9 52 03 00 00       	jmp    80e5cb <tcp_input+0xd16>
      } else {
        tcp_ack_now(pcb);
  80e279:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e27d:	89 1c 24             	mov    %ebx,(%esp)
  80e280:	e8 b9 a3 ff ff       	call   80863e <tcp_output>
        pcb->state = CLOSING;
  80e285:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80e28c:	e9 3a 03 00 00       	jmp    80e5cb <tcp_input+0xd16>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e291:	a8 10                	test   $0x10,%al
  80e293:	0f 84 32 03 00 00    	je     80e5cb <tcp_input+0xd16>
  80e299:	8b 15 e8 c1 b3 00    	mov    0xb3c1e8,%edx
  80e29f:	39 53 54             	cmp    %edx,0x54(%ebx)
  80e2a2:	0f 85 23 03 00 00    	jne    80e5cb <tcp_input+0xd16>
      pcb->state = FIN_WAIT_2;
  80e2a8:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80e2af:	e9 17 03 00 00       	jmp    80e5cb <tcp_input+0xd16>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80e2b4:	89 d8                	mov    %ebx,%eax
  80e2b6:	e8 fc e9 ff ff       	call   80ccb7 <tcp_receive>
    if (flags & TCP_FIN) {
  80e2bb:	f6 05 ec c1 b3 00 01 	testb  $0x1,0xb3c1ec
  80e2c2:	0f 84 03 03 00 00    	je     80e5cb <tcp_input+0xd16>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e2c8:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e2cc:	89 1c 24             	mov    %ebx,(%esp)
  80e2cf:	e8 6a a3 ff ff       	call   80863e <tcp_output>
      tcp_pcb_purge(pcb);
  80e2d4:	89 1c 24             	mov    %ebx,(%esp)
  80e2d7:	e8 14 7b ff ff       	call   805df0 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e2dc:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  80e2e1:	39 c3                	cmp    %eax,%ebx
  80e2e3:	75 0a                	jne    80e2ef <tcp_input+0xa3a>
  80e2e5:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e2e8:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c
  80e2ed:	eb 2e                	jmp    80e31d <tcp_input+0xa68>
  80e2ef:	a3 88 c2 b3 00       	mov    %eax,0xb3c288
  80e2f4:	eb 1e                	jmp    80e314 <tcp_input+0xa5f>
  80e2f6:	8b 50 0c             	mov    0xc(%eax),%edx
  80e2f9:	85 d2                	test   %edx,%edx
  80e2fb:	74 11                	je     80e30e <tcp_input+0xa59>
  80e2fd:	39 d3                	cmp    %edx,%ebx
  80e2ff:	75 11                	jne    80e312 <tcp_input+0xa5d>
  80e301:	a3 88 c2 b3 00       	mov    %eax,0xb3c288
  80e306:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e309:	89 50 0c             	mov    %edx,0xc(%eax)
  80e30c:	eb 0f                	jmp    80e31d <tcp_input+0xa68>
  80e30e:	89 d0                	mov    %edx,%eax
  80e310:	eb 02                	jmp    80e314 <tcp_input+0xa5f>
  80e312:	89 d0                	mov    %edx,%eax
  80e314:	85 c0                	test   %eax,%eax
  80e316:	75 de                	jne    80e2f6 <tcp_input+0xa41>
  80e318:	a3 88 c2 b3 00       	mov    %eax,0xb3c288
      pcb->state = TIME_WAIT;
  80e31d:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e324:	a1 90 c2 b3 00       	mov    0xb3c290,%eax
  80e329:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e32c:	89 1d 90 c2 b3 00    	mov    %ebx,0xb3c290
  80e332:	e8 f7 41 ff ff       	call   80252e <tcp_timer_needed>
  80e337:	e9 8f 02 00 00       	jmp    80e5cb <tcp_input+0xd16>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80e33c:	89 d8                	mov    %ebx,%eax
  80e33e:	e8 74 e9 ff ff       	call   80ccb7 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e343:	f6 05 ec c1 b3 00 10 	testb  $0x10,0xb3c1ec
  80e34a:	0f 84 7b 02 00 00    	je     80e5cb <tcp_input+0xd16>
  80e350:	8b 0d e8 c1 b3 00    	mov    0xb3c1e8,%ecx
  80e356:	39 4b 54             	cmp    %ecx,0x54(%ebx)
  80e359:	0f 85 6c 02 00 00    	jne    80e5cb <tcp_input+0xd16>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e35f:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e363:	89 1c 24             	mov    %ebx,(%esp)
  80e366:	e8 d3 a2 ff ff       	call   80863e <tcp_output>
      tcp_pcb_purge(pcb);
  80e36b:	89 1c 24             	mov    %ebx,(%esp)
  80e36e:	e8 7d 7a ff ff       	call   805df0 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e373:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  80e378:	39 c3                	cmp    %eax,%ebx
  80e37a:	75 0a                	jne    80e386 <tcp_input+0xad1>
  80e37c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e37f:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c
  80e384:	eb 2e                	jmp    80e3b4 <tcp_input+0xaff>
  80e386:	a3 88 c2 b3 00       	mov    %eax,0xb3c288
  80e38b:	eb 1e                	jmp    80e3ab <tcp_input+0xaf6>
  80e38d:	8b 50 0c             	mov    0xc(%eax),%edx
  80e390:	85 d2                	test   %edx,%edx
  80e392:	74 11                	je     80e3a5 <tcp_input+0xaf0>
  80e394:	39 d3                	cmp    %edx,%ebx
  80e396:	75 11                	jne    80e3a9 <tcp_input+0xaf4>
  80e398:	a3 88 c2 b3 00       	mov    %eax,0xb3c288
  80e39d:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e3a0:	89 50 0c             	mov    %edx,0xc(%eax)
  80e3a3:	eb 0f                	jmp    80e3b4 <tcp_input+0xaff>
  80e3a5:	89 d0                	mov    %edx,%eax
  80e3a7:	eb 02                	jmp    80e3ab <tcp_input+0xaf6>
  80e3a9:	89 d0                	mov    %edx,%eax
  80e3ab:	85 c0                	test   %eax,%eax
  80e3ad:	75 de                	jne    80e38d <tcp_input+0xad8>
  80e3af:	a3 88 c2 b3 00       	mov    %eax,0xb3c288
      pcb->state = TIME_WAIT;
  80e3b4:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e3bb:	a1 90 c2 b3 00       	mov    0xb3c290,%eax
  80e3c0:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e3c3:	89 1d 90 c2 b3 00    	mov    %ebx,0xb3c290
  80e3c9:	e8 60 41 ff ff       	call   80252e <tcp_timer_needed>
  80e3ce:	e9 f8 01 00 00       	jmp    80e5cb <tcp_input+0xd16>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80e3d3:	89 d8                	mov    %ebx,%eax
  80e3d5:	e8 dd e8 ff ff       	call   80ccb7 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e3da:	f6 05 ec c1 b3 00 10 	testb  $0x10,0xb3c1ec
  80e3e1:	0f 84 e4 01 00 00    	je     80e5cb <tcp_input+0xd16>
  80e3e7:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80e3ec:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e3ef:	0f 85 d6 01 00 00    	jne    80e5cb <tcp_input+0xd16>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80e3f5:	c6 05 08 c2 b3 00 10 	movb   $0x10,0xb3c208
  80e3fc:	e9 ca 01 00 00       	jmp    80e5cb <tcp_input+0xd16>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e401:	c7 05 98 c2 b3 00 00 	movl   $0x0,0xb3c298
  80e408:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80e40b:	0f b6 05 08 c2 b3 00 	movzbl 0xb3c208,%eax
  80e412:	a8 08                	test   $0x8,%al
  80e414:	74 3f                	je     80e455 <tcp_input+0xba0>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80e416:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80e41c:	85 c0                	test   %eax,%eax
  80e41e:	74 10                	je     80e430 <tcp_input+0xb7b>
  80e420:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  80e427:	ff 
  80e428:	8b 53 18             	mov    0x18(%ebx),%edx
  80e42b:	89 14 24             	mov    %edx,(%esp)
  80e42e:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e430:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e434:	c7 04 24 7c c2 b3 00 	movl   $0xb3c27c,(%esp)
  80e43b:	e8 29 7a ff ff       	call   805e69 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e440:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e444:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e44b:	e8 76 65 ff ff       	call   8049c6 <memp_free>
  80e450:	e9 e8 00 00 00       	jmp    80e53d <tcp_input+0xc88>
      } else if (recv_flags & TF_CLOSED) {
  80e455:	a8 10                	test   $0x10,%al
  80e457:	74 25                	je     80e47e <tcp_input+0xbc9>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e459:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e45d:	c7 04 24 7c c2 b3 00 	movl   $0xb3c27c,(%esp)
  80e464:	e8 00 7a ff ff       	call   805e69 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e469:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e46d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e474:	e8 4d 65 ff ff       	call   8049c6 <memp_free>
  80e479:	e9 bf 00 00 00       	jmp    80e53d <tcp_input+0xc88>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80e47e:	8b 43 6c             	mov    0x6c(%ebx),%eax
  80e481:	66 85 c0             	test   %ax,%ax
  80e484:	74 1f                	je     80e4a5 <tcp_input+0xbf0>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80e486:	8b 93 84 00 00 00    	mov    0x84(%ebx),%edx
  80e48c:	85 d2                	test   %edx,%edx
  80e48e:	74 19                	je     80e4a9 <tcp_input+0xbf4>
  80e490:	0f b7 c0             	movzwl %ax,%eax
  80e493:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e497:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e49b:	8b 43 18             	mov    0x18(%ebx),%eax
  80e49e:	89 04 24             	mov    %eax,(%esp)
  80e4a1:	ff d2                	call   *%edx
  80e4a3:	eb 06                	jmp    80e4ab <tcp_input+0xbf6>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  80e4a5:	b0 00                	mov    $0x0,%al
  80e4a7:	eb 02                	jmp    80e4ab <tcp_input+0xbf6>
  80e4a9:	b0 00                	mov    $0x0,%al
           now. */
        if (pcb->acked > 0) {
          TCP_EVENT_SENT(pcb, pcb->acked, err);
        }
      
        if (recv_data != NULL) {
  80e4ab:	8b 15 04 c2 b3 00    	mov    0xb3c204,%edx
  80e4b1:	85 d2                	test   %edx,%edx
  80e4b3:	74 4d                	je     80e502 <tcp_input+0xc4d>
          if(flags & TCP_PSH) {
  80e4b5:	f6 05 ec c1 b3 00 08 	testb  $0x8,0xb3c1ec
  80e4bc:	74 04                	je     80e4c2 <tcp_input+0xc0d>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80e4be:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e4c2:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e4c8:	85 c0                	test   %eax,%eax
  80e4ca:	74 1e                	je     80e4ea <tcp_input+0xc35>
  80e4cc:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e4d3:	00 
  80e4d4:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e4d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e4dc:	8b 53 18             	mov    0x18(%ebx),%edx
  80e4df:	89 14 24             	mov    %edx,(%esp)
  80e4e2:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80e4e4:	84 c0                	test   %al,%al
  80e4e6:	75 0e                	jne    80e4f6 <tcp_input+0xc41>
  80e4e8:	eb 18                	jmp    80e502 <tcp_input+0xc4d>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e4ea:	89 14 24             	mov    %edx,(%esp)
  80e4ed:	e8 5f 68 ff ff       	call   804d51 <pbuf_free>
  80e4f2:	b0 00                	mov    $0x0,%al
  80e4f4:	eb 0c                	jmp    80e502 <tcp_input+0xc4d>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80e4f6:	8b 15 04 c2 b3 00    	mov    0xb3c204,%edx
  80e4fc:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80e502:	f6 05 08 c2 b3 00 20 	testb  $0x20,0xb3c208
  80e509:	74 26                	je     80e531 <tcp_input+0xc7c>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80e50b:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e511:	85 c0                	test   %eax,%eax
  80e513:	74 20                	je     80e535 <tcp_input+0xc80>
  80e515:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e51c:	00 
  80e51d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e524:	00 
  80e525:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e529:	8b 53 18             	mov    0x18(%ebx),%edx
  80e52c:	89 14 24             	mov    %edx,(%esp)
  80e52f:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80e531:	84 c0                	test   %al,%al
  80e533:	75 08                	jne    80e53d <tcp_input+0xc88>
          tcp_output(pcb);
  80e535:	89 1c 24             	mov    %ebx,(%esp)
  80e538:	e8 01 a1 ff ff       	call   80863e <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80e53d:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  80e542:	85 c0                	test   %eax,%eax
  80e544:	0f 84 90 00 00 00    	je     80e5da <tcp_input+0xd25>
    {
      pbuf_free(inseg.p);
  80e54a:	89 04 24             	mov    %eax,(%esp)
  80e54d:	e8 ff 67 ff ff       	call   804d51 <pbuf_free>
      inseg.p = NULL;
  80e552:	c7 05 f4 c1 b3 00 00 	movl   $0x0,0xb3c1f4
  80e559:	00 00 00 
  80e55c:	eb 7c                	jmp    80e5da <tcp_input+0xd25>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e55e:	8b 15 e0 c1 b3 00    	mov    0xb3c1e0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80e564:	a1 dc c1 b3 00       	mov    0xb3c1dc,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80e569:	0f b7 0a             	movzwl (%edx),%ecx
  80e56c:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e570:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e574:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e578:	8d 50 0c             	lea    0xc(%eax),%edx
  80e57b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e57f:	83 c0 10             	add    $0x10,%eax
  80e582:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e586:	0f b7 05 ee c1 b3 00 	movzwl 0xb3c1ee,%eax
  80e58d:	03 05 e4 c1 b3 00    	add    0xb3c1e4,%eax
  80e593:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e597:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80e59c:	89 04 24             	mov    %eax,(%esp)
  80e59f:	e8 24 a5 ff ff       	call   808ac8 <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80e5a4:	89 34 24             	mov    %esi,(%esp)
  80e5a7:	e8 a5 67 ff ff       	call   804d51 <pbuf_free>
  80e5ac:	eb 2c                	jmp    80e5da <tcp_input+0xd25>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80e5ae:	8b 1d 90 c2 b3 00    	mov    0xb3c290,%ebx
  80e5b4:	e9 c0 f6 ff ff       	jmp    80dc79 <tcp_input+0x3c4>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80e5b9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80e5bd:	89 04 24             	mov    %eax,(%esp)
  80e5c0:	e8 a0 96 ff ff       	call   807c65 <ntohs>
  80e5c5:	a8 04                	test   $0x4,%al
  80e5c7:	75 db                	jne    80e5a4 <tcp_input+0xcef>
  80e5c9:	eb 93                	jmp    80e55e <tcp_input+0xca9>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e5cb:	c7 05 98 c2 b3 00 00 	movl   $0x0,0xb3c298
  80e5d2:	00 00 00 
  80e5d5:	e9 31 fe ff ff       	jmp    80e40b <tcp_input+0xb56>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80e5da:	83 c4 4c             	add    $0x4c,%esp
  80e5dd:	5b                   	pop    %ebx
  80e5de:	5e                   	pop    %esi
  80e5df:	5f                   	pop    %edi
  80e5e0:	5d                   	pop    %ebp
  80e5e1:	c3                   	ret    
	...

0080e5e4 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80e5e4:	55                   	push   %ebp
  80e5e5:	89 e5                	mov    %esp,%ebp
  80e5e7:	57                   	push   %edi
  80e5e8:	56                   	push   %esi
  80e5e9:	53                   	push   %ebx
  80e5ea:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80e5ed:	8b 45 08             	mov    0x8(%ebp),%eax
  80e5f0:	8b 40 04             	mov    0x4(%eax),%eax
  80e5f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  proto = IPH_PROTO(iphdr);
  80e5f6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e5fa:	89 04 24             	mov    %eax,(%esp)
  80e5fd:	e8 63 96 ff ff       	call   807c65 <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80e602:	8b 1d 0c c2 b3 00    	mov    0xb3c20c,%ebx
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80e608:	be 00 00 00 00       	mov    $0x0,%esi
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80e60d:	0f b6 f8             	movzbl %al,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e610:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e613:	83 c2 0c             	add    $0xc,%edx
  80e616:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80e619:	eb 4c                	jmp    80e667 <raw_input+0x83>
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80e61b:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e61f:	39 f8                	cmp    %edi,%eax
  80e621:	75 3f                	jne    80e662 <raw_input+0x7e>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80e623:	8b 43 14             	mov    0x14(%ebx),%eax
  80e626:	85 c0                	test   %eax,%eax
  80e628:	74 38                	je     80e662 <raw_input+0x7e>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e62a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e62d:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e631:	8b 55 08             	mov    0x8(%ebp),%edx
  80e634:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e638:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e63c:	8b 53 18             	mov    0x18(%ebx),%edx
  80e63f:	89 14 24             	mov    %edx,(%esp)
  80e642:	ff d0                	call   *%eax
  80e644:	84 c0                	test   %al,%al
  80e646:	74 1a                	je     80e662 <raw_input+0x7e>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80e648:	85 f6                	test   %esi,%esi
  80e64a:	74 29                	je     80e675 <raw_input+0x91>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80e64c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e64f:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  80e652:	a1 0c c2 b3 00       	mov    0xb3c20c,%eax
  80e657:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80e65a:	89 1d 0c c2 b3 00    	mov    %ebx,0xb3c20c
  80e660:	eb 13                	jmp    80e675 <raw_input+0x91>
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  80e662:	89 de                	mov    %ebx,%esi
  80e664:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e667:	85 db                	test   %ebx,%ebx
  80e669:	75 b0                	jne    80e61b <raw_input+0x37>
  80e66b:	b0 00                	mov    $0x0,%al
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80e66d:	83 c4 2c             	add    $0x2c,%esp
  80e670:	5b                   	pop    %ebx
  80e671:	5e                   	pop    %esi
  80e672:	5f                   	pop    %edi
  80e673:	5d                   	pop    %ebp
  80e674:	c3                   	ret    
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80e675:	b0 01                	mov    $0x1,%al
  80e677:	eb f4                	jmp    80e66d <raw_input+0x89>

0080e679 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e679:	55                   	push   %ebp
  80e67a:	89 e5                	mov    %esp,%ebp
  80e67c:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  80e67f:	85 c0                	test   %eax,%eax
  80e681:	74 04                	je     80e687 <raw_bind+0xe>
  80e683:	8b 10                	mov    (%eax),%edx
  80e685:	eb 05                	jmp    80e68c <raw_bind+0x13>
  80e687:	ba 00 00 00 00       	mov    $0x0,%edx
  80e68c:	8b 45 08             	mov    0x8(%ebp),%eax
  80e68f:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  80e691:	b0 00                	mov    $0x0,%al
  80e693:	5d                   	pop    %ebp
  80e694:	c3                   	ret    

0080e695 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e695:	55                   	push   %ebp
  80e696:	89 e5                	mov    %esp,%ebp
  80e698:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80e69b:	85 c0                	test   %eax,%eax
  80e69d:	74 04                	je     80e6a3 <raw_connect+0xe>
  80e69f:	8b 10                	mov    (%eax),%edx
  80e6a1:	eb 05                	jmp    80e6a8 <raw_connect+0x13>
  80e6a3:	ba 00 00 00 00       	mov    $0x0,%edx
  80e6a8:	8b 45 08             	mov    0x8(%ebp),%eax
  80e6ab:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  80e6ae:	b0 00                	mov    $0x0,%al
  80e6b0:	5d                   	pop    %ebp
  80e6b1:	c3                   	ret    

0080e6b2 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80e6b2:	55                   	push   %ebp
  80e6b3:	89 e5                	mov    %esp,%ebp
  80e6b5:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80e6b8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e6bb:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80e6be:	8b 55 10             	mov    0x10(%ebp),%edx
  80e6c1:	89 50 18             	mov    %edx,0x18(%eax)
}
  80e6c4:	5d                   	pop    %ebp
  80e6c5:	c3                   	ret    

0080e6c6 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80e6c6:	55                   	push   %ebp
  80e6c7:	89 e5                	mov    %esp,%ebp
  80e6c9:	57                   	push   %edi
  80e6ca:	56                   	push   %esi
  80e6cb:	53                   	push   %ebx
  80e6cc:	83 ec 2c             	sub    $0x2c,%esp
  80e6cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e6d2:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80e6d5:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80e6dc:	00 
  80e6dd:	89 3c 24             	mov    %edi,(%esp)
  80e6e0:	e8 87 65 ff ff       	call   804c6c <pbuf_header>
  80e6e5:	84 c0                	test   %al,%al
  80e6e7:	74 34                	je     80e71d <raw_sendto+0x57>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80e6e9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e6f0:	00 
  80e6f1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e6f8:	00 
  80e6f9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80e700:	e8 4d 68 ff ff       	call   804f52 <pbuf_alloc>
  80e705:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80e707:	85 c0                	test   %eax,%eax
  80e709:	0f 84 ac 00 00 00    	je     80e7bb <raw_sendto+0xf5>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80e70f:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80e713:	89 04 24             	mov    %eax,(%esp)
  80e716:	e8 54 6b ff ff       	call   80526f <pbuf_chain>
  80e71b:	eb 32                	jmp    80e74f <raw_sendto+0x89>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80e71d:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80e724:	ff 
  80e725:	89 3c 24             	mov    %edi,(%esp)
  80e728:	e8 3f 65 ff ff       	call   804c6c <pbuf_header>
  80e72d:	84 c0                	test   %al,%al
  80e72f:	74 1c                	je     80e74d <raw_sendto+0x87>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e731:	c7 44 24 08 cc 3d 81 	movl   $0x813dcc,0x8(%esp)
  80e738:	00 
  80e739:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80e740:	00 
  80e741:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80e748:	e8 33 07 00 00       	call   80ee80 <_panic>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  80e74d:	89 fe                	mov    %edi,%esi
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e74f:	8b 45 10             	mov    0x10(%ebp),%eax
  80e752:	89 04 24             	mov    %eax,(%esp)
  80e755:	e8 86 82 ff ff       	call   8069e0 <ip_route>
  80e75a:	85 c0                	test   %eax,%eax
  80e75c:	75 10                	jne    80e76e <raw_sendto+0xa8>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80e75e:	39 fe                	cmp    %edi,%esi
  80e760:	74 5d                	je     80e7bf <raw_sendto+0xf9>
      pbuf_free(q);
  80e762:	89 34 24             	mov    %esi,(%esp)
  80e765:	e8 e7 65 ff ff       	call   804d51 <pbuf_free>
    }
    return ERR_RTE;
  80e76a:	b3 fc                	mov    $0xfc,%bl
  80e76c:	eb 53                	jmp    80e7c1 <raw_sendto+0xfb>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80e76e:	89 da                	mov    %ebx,%edx
  80e770:	85 db                	test   %ebx,%ebx
  80e772:	74 05                	je     80e779 <raw_sendto+0xb3>
  80e774:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e777:	75 03                	jne    80e77c <raw_sendto+0xb6>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e779:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e77c:	89 44 24 18          	mov    %eax,0x18(%esp)
  80e780:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e784:	89 44 24 14          	mov    %eax,0x14(%esp)
  80e788:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e78c:	89 44 24 10          	mov    %eax,0x10(%esp)
  80e790:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e794:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80e798:	8b 45 10             	mov    0x10(%ebp),%eax
  80e79b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e79f:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e7a3:	89 34 24             	mov    %esi,(%esp)
  80e7a6:	e8 35 85 ff ff       	call   806ce0 <ip_output_if>
  80e7ab:	88 c3                	mov    %al,%bl
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e7ad:	39 fe                	cmp    %edi,%esi
  80e7af:	74 10                	je     80e7c1 <raw_sendto+0xfb>
    /* free the header */
    pbuf_free(q);
  80e7b1:	89 34 24             	mov    %esi,(%esp)
  80e7b4:	e8 98 65 ff ff       	call   804d51 <pbuf_free>
  80e7b9:	eb 06                	jmp    80e7c1 <raw_sendto+0xfb>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  80e7bb:	b3 ff                	mov    $0xff,%bl
  80e7bd:	eb 02                	jmp    80e7c1 <raw_sendto+0xfb>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80e7bf:	b3 fc                	mov    $0xfc,%bl
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
  80e7c1:	88 d8                	mov    %bl,%al
  80e7c3:	83 c4 2c             	add    $0x2c,%esp
  80e7c6:	5b                   	pop    %ebx
  80e7c7:	5e                   	pop    %esi
  80e7c8:	5f                   	pop    %edi
  80e7c9:	5d                   	pop    %ebp
  80e7ca:	c3                   	ret    

0080e7cb <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e7cb:	55                   	push   %ebp
  80e7cc:	89 e5                	mov    %esp,%ebp
  80e7ce:	83 ec 18             	sub    $0x18,%esp
  80e7d1:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e7d4:	8d 50 04             	lea    0x4(%eax),%edx
  80e7d7:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e7db:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e7de:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e7e2:	89 04 24             	mov    %eax,(%esp)
  80e7e5:	e8 dc fe ff ff       	call   80e6c6 <raw_sendto>
}
  80e7ea:	c9                   	leave  
  80e7eb:	c3                   	ret    

0080e7ec <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e7ec:	55                   	push   %ebp
  80e7ed:	89 e5                	mov    %esp,%ebp
  80e7ef:	83 ec 18             	sub    $0x18,%esp
  80e7f2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e7f5:	a1 0c c2 b3 00       	mov    0xb3c20c,%eax
  80e7fa:	39 c8                	cmp    %ecx,%eax
  80e7fc:	75 1e                	jne    80e81c <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e7fe:	8b 40 0c             	mov    0xc(%eax),%eax
  80e801:	a3 0c c2 b3 00       	mov    %eax,0xb3c20c
  80e806:	eb 18                	jmp    80e820 <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80e808:	8b 50 0c             	mov    0xc(%eax),%edx
  80e80b:	85 d2                	test   %edx,%edx
  80e80d:	74 0a                	je     80e819 <raw_remove+0x2d>
  80e80f:	39 d1                	cmp    %edx,%ecx
  80e811:	75 06                	jne    80e819 <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80e813:	8b 51 0c             	mov    0xc(%ecx),%edx
  80e816:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80e819:	8b 40 0c             	mov    0xc(%eax),%eax
  80e81c:	85 c0                	test   %eax,%eax
  80e81e:	75 e8                	jne    80e808 <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80e820:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80e824:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e82b:	e8 96 61 ff ff       	call   8049c6 <memp_free>
}
  80e830:	c9                   	leave  
  80e831:	c3                   	ret    

0080e832 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80e832:	55                   	push   %ebp
  80e833:	89 e5                	mov    %esp,%ebp
  80e835:	53                   	push   %ebx
  80e836:	83 ec 24             	sub    $0x24,%esp
  80e839:	8a 45 08             	mov    0x8(%ebp),%al
  80e83c:	88 45 f7             	mov    %al,-0x9(%ebp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80e83f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e846:	e8 1b 61 ff ff       	call   804966 <memp_malloc>
  80e84b:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80e84d:	85 c0                	test   %eax,%eax
  80e84f:	74 30                	je     80e881 <raw_new+0x4f>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e851:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80e858:	00 
  80e859:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e860:	00 
  80e861:	89 04 24             	mov    %eax,(%esp)
  80e864:	e8 e9 0d 00 00       	call   80f652 <memset>
    pcb->protocol = proto;
  80e869:	8a 45 f7             	mov    -0x9(%ebp),%al
  80e86c:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e86f:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e873:	a1 0c c2 b3 00       	mov    0xb3c20c,%eax
  80e878:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e87b:	89 1d 0c c2 b3 00    	mov    %ebx,0xb3c20c
  }
  return pcb;
}
  80e881:	89 d8                	mov    %ebx,%eax
  80e883:	83 c4 24             	add    $0x24,%esp
  80e886:	5b                   	pop    %ebx
  80e887:	5d                   	pop    %ebp
  80e888:	c3                   	ret    
  80e889:	00 00                	add    %al,(%eax)
	...

0080e88c <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e88c:	55                   	push   %ebp
  80e88d:	89 e5                	mov    %esp,%ebp
  80e88f:	57                   	push   %edi
  80e890:	56                   	push   %esi
  80e891:	53                   	push   %ebx
  80e892:	83 ec 3c             	sub    $0x3c,%esp
  80e895:	8b 75 08             	mov    0x8(%ebp),%esi

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e898:	8b 46 04             	mov    0x4(%esi),%eax
  80e89b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  hlen = IPH_HL(iphdr) * 4;
  80e89e:	0f b7 00             	movzwl (%eax),%eax
  80e8a1:	89 04 24             	mov    %eax,(%esp)
  80e8a4:	e8 bc 93 ff ff       	call   807c65 <ntohs>
  80e8a9:	66 c1 e8 06          	shr    $0x6,%ax
  80e8ad:	89 c7                	mov    %eax,%edi
  80e8af:	83 e7 3c             	and    $0x3c,%edi
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e8b2:	89 fb                	mov    %edi,%ebx
  80e8b4:	f7 db                	neg    %ebx
  80e8b6:	0f bf db             	movswl %bx,%ebx
  80e8b9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e8bd:	89 34 24             	mov    %esi,(%esp)
  80e8c0:	e8 a7 63 ff ff       	call   804c6c <pbuf_header>
  80e8c5:	84 c0                	test   %al,%al
  80e8c7:	0f 85 04 03 00 00    	jne    80ebd1 <icmp_input+0x345>
  80e8cd:	66 83 7e 08 03       	cmpw   $0x3,0x8(%esi)
  80e8d2:	0f 86 f9 02 00 00    	jbe    80ebd1 <icmp_input+0x345>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e8d8:	8b 46 04             	mov    0x4(%esi),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e8db:	80 38 08             	cmpb   $0x8,(%eax)
  80e8de:	0f 85 e3 02 00 00    	jne    80ebc7 <icmp_input+0x33b>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e8e4:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e8e7:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e8eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e8ee:	83 c0 10             	add    $0x10,%eax
  80e8f1:	89 04 24             	mov    %eax,(%esp)
  80e8f4:	e8 a3 80 ff ff       	call   80699c <ip_addr_isbroadcast>
  80e8f9:	84 c0                	test   %al,%al
  80e8fb:	75 2c                	jne    80e929 <icmp_input+0x9d>
  80e8fd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e900:	8b 49 10             	mov    0x10(%ecx),%ecx
  80e903:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80e906:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80e90d:	e8 bd 95 ff ff       	call   807ecf <ntohl>
  80e912:	23 45 e0             	and    -0x20(%ebp),%eax
  80e915:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e918:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e91f:	e8 ab 95 ff ff       	call   807ecf <ntohl>
  80e924:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e927:	75 0d                	jne    80e936 <icmp_input+0xaa>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80e929:	89 34 24             	mov    %esi,(%esp)
  80e92c:	e8 20 64 ff ff       	call   804d51 <pbuf_free>
      return;
  80e931:	e9 ad 02 00 00       	jmp    80ebe3 <icmp_input+0x357>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e936:	66 83 7e 08 07       	cmpw   $0x7,0x8(%esi)
  80e93b:	0f 86 90 02 00 00    	jbe    80ebd1 <icmp_input+0x345>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80e941:	89 34 24             	mov    %esi,(%esp)
  80e944:	e8 f0 91 ff ff       	call   807b39 <inet_chksum_pbuf>
  80e949:	66 85 c0             	test   %ax,%ax
  80e94c:	74 0d                	je     80e95b <icmp_input+0xcf>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80e94e:	89 34 24             	mov    %esi,(%esp)
  80e951:	e8 fb 63 ff ff       	call   804d51 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80e956:	e9 88 02 00 00       	jmp    80ebe3 <icmp_input+0x357>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e95b:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  80e962:	00 
  80e963:	89 34 24             	mov    %esi,(%esp)
  80e966:	e8 01 63 ff ff       	call   804c6c <pbuf_header>
  80e96b:	84 c0                	test   %al,%al
  80e96d:	0f 84 f4 00 00 00    	je     80ea67 <icmp_input+0x1db>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80e973:	0f bf c7             	movswl %di,%eax
  80e976:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e97a:	89 34 24             	mov    %esi,(%esp)
  80e97d:	e8 ea 62 ff ff       	call   804c6c <pbuf_header>
  80e982:	84 c0                	test   %al,%al
  80e984:	74 1c                	je     80e9a2 <icmp_input+0x116>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e986:	c7 44 24 08 08 3e 81 	movl   $0x813e08,0x8(%esp)
  80e98d:	00 
  80e98e:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  80e995:	00 
  80e996:	c7 04 24 fc 3e 81 00 	movl   $0x813efc,(%esp)
  80e99d:	e8 de 04 00 00       	call   80ee80 <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e9a2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e9a9:	00 
  80e9aa:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80e9ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e9b2:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e9b9:	e8 94 65 ff ff       	call   804f52 <pbuf_alloc>
  80e9be:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e9c1:	85 c0                	test   %eax,%eax
  80e9c3:	0f 84 12 02 00 00    	je     80ebdb <icmp_input+0x34f>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e9c9:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e9cd:	0f bf c7             	movswl %di,%eax
  80e9d0:	83 c0 08             	add    $0x8,%eax
  80e9d3:	39 c2                	cmp    %eax,%edx
  80e9d5:	73 1c                	jae    80e9f3 <icmp_input+0x167>
  80e9d7:	c7 44 24 08 3c 3e 81 	movl   $0x813e3c,0x8(%esp)
  80e9de:	00 
  80e9df:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  80e9e6:	00 
  80e9e7:	c7 04 24 fc 3e 81 00 	movl   $0x813efc,(%esp)
  80e9ee:	e8 8d 04 00 00       	call   80ee80 <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80e9f3:	89 74 24 04          	mov    %esi,0x4(%esp)
  80e9f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e9fa:	89 04 24             	mov    %eax,(%esp)
  80e9fd:	e8 37 69 ff ff       	call   805339 <pbuf_copy>
  80ea02:	84 c0                	test   %al,%al
  80ea04:	74 1c                	je     80ea22 <icmp_input+0x196>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80ea06:	c7 44 24 08 74 3e 81 	movl   $0x813e74,0x8(%esp)
  80ea0d:	00 
  80ea0e:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  80ea15:	00 
  80ea16:	c7 04 24 fc 3e 81 00 	movl   $0x813efc,(%esp)
  80ea1d:	e8 5e 04 00 00       	call   80ee80 <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80ea22:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea25:	8b 40 04             	mov    0x4(%eax),%eax
  80ea28:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80ea2b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ea2f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea32:	89 04 24             	mov    %eax,(%esp)
  80ea35:	e8 32 62 ff ff       	call   804c6c <pbuf_header>
  80ea3a:	84 c0                	test   %al,%al
  80ea3c:	74 1c                	je     80ea5a <icmp_input+0x1ce>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80ea3e:	c7 44 24 08 9c 3e 81 	movl   $0x813e9c,0x8(%esp)
  80ea45:	00 
  80ea46:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80ea4d:	00 
  80ea4e:	c7 04 24 fc 3e 81 00 	movl   $0x813efc,(%esp)
  80ea55:	e8 26 04 00 00       	call   80ee80 <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80ea5a:	89 34 24             	mov    %esi,(%esp)
  80ea5d:	e8 ef 62 ff ff       	call   804d51 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  80ea62:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80ea65:	eb 30                	jmp    80ea97 <icmp_input+0x20b>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80ea67:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  80ea6e:	ff 
  80ea6f:	89 34 24             	mov    %esi,(%esp)
  80ea72:	e8 f5 61 ff ff       	call   804c6c <pbuf_header>
  80ea77:	84 c0                	test   %al,%al
  80ea79:	74 1c                	je     80ea97 <icmp_input+0x20b>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80ea7b:	c7 44 24 08 9c 3e 81 	movl   $0x813e9c,0x8(%esp)
  80ea82:	00 
  80ea83:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80ea8a:	00 
  80ea8b:	c7 04 24 fc 3e 81 00 	movl   $0x813efc,(%esp)
  80ea92:	e8 e9 03 00 00       	call   80ee80 <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80ea97:	8b 56 04             	mov    0x4(%esi),%edx
  80ea9a:	89 55 e0             	mov    %edx,-0x20(%ebp)
    tmpaddr.addr = iphdr->src.addr;
  80ea9d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80eaa0:	8b 41 0c             	mov    0xc(%ecx),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80eaa3:	8b 51 10             	mov    0x10(%ecx),%edx
  80eaa6:	89 51 0c             	mov    %edx,0xc(%ecx)
    iphdr->dest.addr = tmpaddr.addr;
  80eaa9:	89 41 10             	mov    %eax,0x10(%ecx)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80eaac:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eaaf:	0f b7 02             	movzwl (%edx),%eax
  80eab2:	89 04 24             	mov    %eax,(%esp)
  80eab5:	e8 ab 91 ff ff       	call   807c65 <ntohs>
  80eaba:	0f b6 c0             	movzbl %al,%eax
  80eabd:	89 04 24             	mov    %eax,(%esp)
  80eac0:	e8 94 91 ff ff       	call   807c59 <htons>
  80eac5:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80eac8:	66 89 01             	mov    %ax,(%ecx)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80eacb:	66 8b 59 02          	mov    0x2(%ecx),%bx
  80eacf:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80ead6:	e8 7e 91 ff ff       	call   807c59 <htons>
  80eadb:	66 39 c3             	cmp    %ax,%bx
  80eade:	72 20                	jb     80eb00 <icmp_input+0x274>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80eae0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eae3:	66 8b 58 02          	mov    0x2(%eax),%bx
  80eae7:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80eaee:	e8 66 91 ff ff       	call   807c59 <htons>
  80eaf3:	8d 44 03 01          	lea    0x1(%ebx,%eax,1),%eax
  80eaf7:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eafa:	66 89 42 02          	mov    %ax,0x2(%edx)
  80eafe:	eb 1c                	jmp    80eb1c <icmp_input+0x290>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80eb00:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80eb03:	66 8b 59 02          	mov    0x2(%ecx),%bx
  80eb07:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80eb0e:	e8 46 91 ff ff       	call   807c59 <htons>
  80eb13:	01 d8                	add    %ebx,%eax
  80eb15:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eb18:	66 89 42 02          	mov    %ax,0x2(%edx)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80eb1c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80eb1f:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
  80eb23:	89 04 24             	mov    %eax,(%esp)
  80eb26:	e8 3a 91 ff ff       	call   807c65 <ntohs>
  80eb2b:	0d 00 ff ff ff       	or     $0xffffff00,%eax
  80eb30:	0f b7 c0             	movzwl %ax,%eax
  80eb33:	89 04 24             	mov    %eax,(%esp)
  80eb36:	e8 1e 91 ff ff       	call   807c59 <htons>
  80eb3b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80eb3e:	66 89 42 08          	mov    %ax,0x8(%edx)
    IPH_CHKSUM_SET(iphdr, 0);
  80eb42:	66 c7 42 0a 00 00    	movw   $0x0,0xa(%edx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80eb48:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80eb4f:	00 
  80eb50:	89 14 24             	mov    %edx,(%esp)
  80eb53:	e8 cb 8f ff ff       	call   807b23 <inet_chksum>
  80eb58:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80eb5b:	66 89 41 0a          	mov    %ax,0xa(%ecx)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80eb5f:	0f bf ff             	movswl %di,%edi
  80eb62:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80eb66:	89 34 24             	mov    %esi,(%esp)
  80eb69:	e8 fe 60 ff ff       	call   804c6c <pbuf_header>
  80eb6e:	84 c0                	test   %al,%al
  80eb70:	74 1c                	je     80eb8e <icmp_input+0x302>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80eb72:	c7 44 24 08 f4 2e 81 	movl   $0x812ef4,0x8(%esp)
  80eb79:	00 
  80eb7a:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  80eb81:	00 
  80eb82:	c7 04 24 fc 3e 81 00 	movl   $0x813efc,(%esp)
  80eb89:	e8 f2 02 00 00       	call   80ee80 <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80eb8e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80eb91:	89 44 24 18          	mov    %eax,0x18(%esp)
  80eb95:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80eb9c:	00 
  80eb9d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80eba4:	00 
  80eba5:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80ebac:	00 
  80ebad:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ebb4:	00 
  80ebb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ebb8:	83 c0 0c             	add    $0xc,%eax
  80ebbb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ebbf:	89 34 24             	mov    %esi,(%esp)
  80ebc2:	e8 19 81 ff ff       	call   806ce0 <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80ebc7:	89 34 24             	mov    %esi,(%esp)
  80ebca:	e8 82 61 ff ff       	call   804d51 <pbuf_free>
  return;
  80ebcf:	eb 12                	jmp    80ebe3 <icmp_input+0x357>
lenerr:
  pbuf_free(p);
  80ebd1:	89 34 24             	mov    %esi,(%esp)
  80ebd4:	e8 78 61 ff ff       	call   804d51 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80ebd9:	eb 08                	jmp    80ebe3 <icmp_input+0x357>
memerr:
  pbuf_free(p);
  80ebdb:	89 34 24             	mov    %esi,(%esp)
  80ebde:	e8 6e 61 ff ff       	call   804d51 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80ebe3:	83 c4 3c             	add    $0x3c,%esp
  80ebe6:	5b                   	pop    %ebx
  80ebe7:	5e                   	pop    %esi
  80ebe8:	5f                   	pop    %edi
  80ebe9:	5d                   	pop    %ebp
  80ebea:	c3                   	ret    

0080ebeb <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80ebeb:	55                   	push   %ebp
  80ebec:	89 e5                	mov    %esp,%ebp
  80ebee:	57                   	push   %edi
  80ebef:	56                   	push   %esi
  80ebf0:	53                   	push   %ebx
  80ebf1:	83 ec 3c             	sub    $0x3c,%esp
  80ebf4:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80ebf7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ebfe:	00 
  80ebff:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ec06:	00 
  80ec07:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ec0e:	e8 3f 63 ff ff       	call   804f52 <pbuf_alloc>
  80ec13:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80ec15:	85 c0                	test   %eax,%eax
  80ec17:	0f 84 d7 00 00 00    	je     80ecf4 <icmp_dest_unreach+0x109>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ec1d:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80ec22:	77 1c                	ja     80ec40 <icmp_dest_unreach+0x55>
  80ec24:	c7 44 24 08 d0 3e 81 	movl   $0x813ed0,0x8(%esp)
  80ec2b:	00 
  80ec2c:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  80ec33:	00 
  80ec34:	c7 04 24 fc 3e 81 00 	movl   $0x813efc,(%esp)
  80ec3b:	e8 40 02 00 00       	call   80ee80 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ec40:	8b 47 04             	mov    0x4(%edi),%eax
  80ec43:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  80ec46:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80ec49:	0f b7 06             	movzwl (%esi),%eax
  80ec4c:	89 04 24             	mov    %eax,(%esp)
  80ec4f:	e8 11 90 ff ff       	call   807c65 <ntohs>
  80ec54:	0f b6 c0             	movzbl %al,%eax
  80ec57:	80 cc 03             	or     $0x3,%ah
  80ec5a:	89 04 24             	mov    %eax,(%esp)
  80ec5d:	e8 f7 8f ff ff       	call   807c59 <htons>
  80ec62:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80ec65:	0f b7 c0             	movzwl %ax,%eax
  80ec68:	89 04 24             	mov    %eax,(%esp)
  80ec6b:	e8 f5 8f ff ff       	call   807c65 <ntohs>
  80ec70:	b0 00                	mov    $0x0,%al
  80ec72:	0b 45 0c             	or     0xc(%ebp),%eax
  80ec75:	0f b7 c0             	movzwl %ax,%eax
  80ec78:	89 04 24             	mov    %eax,(%esp)
  80ec7b:	e8 d9 8f ff ff       	call   807c59 <htons>
  80ec80:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80ec83:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80ec8a:	00 
  80ec8b:	8b 47 04             	mov    0x4(%edi),%eax
  80ec8e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ec92:	8b 43 04             	mov    0x4(%ebx),%eax
  80ec95:	83 c0 08             	add    $0x8,%eax
  80ec98:	89 04 24             	mov    %eax,(%esp)
  80ec9b:	e8 66 0a 00 00       	call   80f706 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80eca0:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80eca6:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ecaa:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ecae:	89 34 24             	mov    %esi,(%esp)
  80ecb1:	e8 6d 8e ff ff       	call   807b23 <inet_chksum>
  80ecb6:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80ecba:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80ecc1:	00 
  80ecc2:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ecc9:	00 
  80ecca:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80ecd1:	00 
  80ecd2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ecd5:	83 c0 0c             	add    $0xc,%eax
  80ecd8:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ecdc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ece3:	00 
  80ece4:	89 1c 24             	mov    %ebx,(%esp)
  80ece7:	e8 7b 81 ff ff       	call   806e67 <ip_output>
  pbuf_free(q);
  80ecec:	89 1c 24             	mov    %ebx,(%esp)
  80ecef:	e8 5d 60 ff ff       	call   804d51 <pbuf_free>
}
  80ecf4:	83 c4 3c             	add    $0x3c,%esp
  80ecf7:	5b                   	pop    %ebx
  80ecf8:	5e                   	pop    %esi
  80ecf9:	5f                   	pop    %edi
  80ecfa:	5d                   	pop    %ebp
  80ecfb:	c3                   	ret    

0080ecfc <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80ecfc:	55                   	push   %ebp
  80ecfd:	89 e5                	mov    %esp,%ebp
  80ecff:	57                   	push   %edi
  80ed00:	56                   	push   %esi
  80ed01:	53                   	push   %ebx
  80ed02:	83 ec 3c             	sub    $0x3c,%esp
  80ed05:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80ed08:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ed0f:	00 
  80ed10:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ed17:	00 
  80ed18:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ed1f:	e8 2e 62 ff ff       	call   804f52 <pbuf_alloc>
  80ed24:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80ed26:	85 c0                	test   %eax,%eax
  80ed28:	0f 84 d7 00 00 00    	je     80ee05 <icmp_time_exceeded+0x109>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ed2e:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80ed33:	77 1c                	ja     80ed51 <icmp_time_exceeded+0x55>
  80ed35:	c7 44 24 08 d0 3e 81 	movl   $0x813ed0,0x8(%esp)
  80ed3c:	00 
  80ed3d:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  80ed44:	00 
  80ed45:	c7 04 24 fc 3e 81 00 	movl   $0x813efc,(%esp)
  80ed4c:	e8 2f 01 00 00       	call   80ee80 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ed51:	8b 47 04             	mov    0x4(%edi),%eax
  80ed54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80ed57:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80ed5a:	0f b7 06             	movzwl (%esi),%eax
  80ed5d:	89 04 24             	mov    %eax,(%esp)
  80ed60:	e8 00 8f ff ff       	call   807c65 <ntohs>
  80ed65:	0f b6 c0             	movzbl %al,%eax
  80ed68:	80 cc 0b             	or     $0xb,%ah
  80ed6b:	89 04 24             	mov    %eax,(%esp)
  80ed6e:	e8 e6 8e ff ff       	call   807c59 <htons>
  80ed73:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80ed76:	0f b7 c0             	movzwl %ax,%eax
  80ed79:	89 04 24             	mov    %eax,(%esp)
  80ed7c:	e8 e4 8e ff ff       	call   807c65 <ntohs>
  80ed81:	b0 00                	mov    $0x0,%al
  80ed83:	0b 45 0c             	or     0xc(%ebp),%eax
  80ed86:	0f b7 c0             	movzwl %ax,%eax
  80ed89:	89 04 24             	mov    %eax,(%esp)
  80ed8c:	e8 c8 8e ff ff       	call   807c59 <htons>
  80ed91:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80ed94:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80ed9b:	00 
  80ed9c:	8b 47 04             	mov    0x4(%edi),%eax
  80ed9f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eda3:	8b 43 04             	mov    0x4(%ebx),%eax
  80eda6:	83 c0 08             	add    $0x8,%eax
  80eda9:	89 04 24             	mov    %eax,(%esp)
  80edac:	e8 55 09 00 00       	call   80f706 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80edb1:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80edb7:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80edbb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80edbf:	89 34 24             	mov    %esi,(%esp)
  80edc2:	e8 5c 8d ff ff       	call   807b23 <inet_chksum>
  80edc7:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80edcb:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80edd2:	00 
  80edd3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80edda:	00 
  80eddb:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80ede2:	00 
  80ede3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ede6:	83 c0 0c             	add    $0xc,%eax
  80ede9:	89 44 24 08          	mov    %eax,0x8(%esp)
  80eded:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80edf4:	00 
  80edf5:	89 1c 24             	mov    %ebx,(%esp)
  80edf8:	e8 6a 80 ff ff       	call   806e67 <ip_output>
  pbuf_free(q);
  80edfd:	89 1c 24             	mov    %ebx,(%esp)
  80ee00:	e8 4c 5f ff ff       	call   804d51 <pbuf_free>
}
  80ee05:	83 c4 3c             	add    $0x3c,%esp
  80ee08:	5b                   	pop    %ebx
  80ee09:	5e                   	pop    %esi
  80ee0a:	5f                   	pop    %edi
  80ee0b:	5d                   	pop    %ebp
  80ee0c:	c3                   	ret    
  80ee0d:	00 00                	add    %al,(%eax)
	...

0080ee10 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80ee10:	55                   	push   %ebp
  80ee11:	89 e5                	mov    %esp,%ebp
  80ee13:	56                   	push   %esi
  80ee14:	53                   	push   %ebx
  80ee15:	83 ec 10             	sub    $0x10,%esp
  80ee18:	8b 75 08             	mov    0x8(%ebp),%esi
  80ee1b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  80ee1e:	e8 b4 0a 00 00       	call   80f8d7 <sys_getenvid>
  80ee23:	25 ff 03 00 00       	and    $0x3ff,%eax
  80ee28:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80ee2f:	c1 e0 07             	shl    $0x7,%eax
  80ee32:	29 d0                	sub    %edx,%eax
  80ee34:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80ee39:	a3 9c c2 b3 00       	mov    %eax,0xb3c29c


	// save the name of the program so that panic() can use it
	if (argc > 0)
  80ee3e:	85 f6                	test   %esi,%esi
  80ee40:	7e 07                	jle    80ee49 <libmain+0x39>
		binaryname = argv[0];
  80ee42:	8b 03                	mov    (%ebx),%eax
  80ee44:	a3 e8 52 81 00       	mov    %eax,0x8152e8

	// call user main routine
	umain(argc, argv);
  80ee49:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ee4d:	89 34 24             	mov    %esi,(%esp)
  80ee50:	e8 ed 17 ff ff       	call   800642 <umain>

	// exit gracefully
	exit();
  80ee55:	e8 0a 00 00 00       	call   80ee64 <exit>
}
  80ee5a:	83 c4 10             	add    $0x10,%esp
  80ee5d:	5b                   	pop    %ebx
  80ee5e:	5e                   	pop    %esi
  80ee5f:	5d                   	pop    %ebp
  80ee60:	c3                   	ret    
  80ee61:	00 00                	add    %al,(%eax)
	...

0080ee64 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80ee64:	55                   	push   %ebp
  80ee65:	89 e5                	mov    %esp,%ebp
  80ee67:	83 ec 18             	sub    $0x18,%esp
	close_all();
  80ee6a:	e8 4c 14 00 00       	call   8102bb <close_all>
	sys_env_destroy(0);
  80ee6f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ee76:	e8 0a 0a 00 00       	call   80f885 <sys_env_destroy>
}
  80ee7b:	c9                   	leave  
  80ee7c:	c3                   	ret    
  80ee7d:	00 00                	add    %al,(%eax)
	...

0080ee80 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80ee80:	55                   	push   %ebp
  80ee81:	89 e5                	mov    %esp,%ebp
  80ee83:	56                   	push   %esi
  80ee84:	53                   	push   %ebx
  80ee85:	83 ec 20             	sub    $0x20,%esp
	va_list ap;

	va_start(ap, fmt);
  80ee88:	8d 75 14             	lea    0x14(%ebp),%esi

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80ee8b:	8b 1d e8 52 81 00    	mov    0x8152e8,%ebx
  80ee91:	e8 41 0a 00 00       	call   80f8d7 <sys_getenvid>
  80ee96:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ee99:	89 54 24 10          	mov    %edx,0x10(%esp)
  80ee9d:	8b 55 08             	mov    0x8(%ebp),%edx
  80eea0:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80eea4:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80eea8:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eeac:	c7 04 24 20 3f 81 00 	movl   $0x813f20,(%esp)
  80eeb3:	e8 c0 00 00 00       	call   80ef78 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80eeb8:	89 74 24 04          	mov    %esi,0x4(%esp)
  80eebc:	8b 45 10             	mov    0x10(%ebp),%eax
  80eebf:	89 04 24             	mov    %eax,(%esp)
  80eec2:	e8 50 00 00 00       	call   80ef17 <vcprintf>
	cprintf("\n");
  80eec7:	c7 04 24 88 1a 81 00 	movl   $0x811a88,(%esp)
  80eece:	e8 a5 00 00 00       	call   80ef78 <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80eed3:	cc                   	int3   
  80eed4:	eb fd                	jmp    80eed3 <_panic+0x53>
	...

0080eed8 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80eed8:	55                   	push   %ebp
  80eed9:	89 e5                	mov    %esp,%ebp
  80eedb:	53                   	push   %ebx
  80eedc:	83 ec 14             	sub    $0x14,%esp
  80eedf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80eee2:	8b 03                	mov    (%ebx),%eax
  80eee4:	8b 55 08             	mov    0x8(%ebp),%edx
  80eee7:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
  80eeeb:	40                   	inc    %eax
  80eeec:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  80eeee:	3d ff 00 00 00       	cmp    $0xff,%eax
  80eef3:	75 19                	jne    80ef0e <putch+0x36>
		sys_cputs(b->buf, b->idx);
  80eef5:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80eefc:	00 
  80eefd:	8d 43 08             	lea    0x8(%ebx),%eax
  80ef00:	89 04 24             	mov    %eax,(%esp)
  80ef03:	e8 40 09 00 00       	call   80f848 <sys_cputs>
		b->idx = 0;
  80ef08:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  80ef0e:	ff 43 04             	incl   0x4(%ebx)
}
  80ef11:	83 c4 14             	add    $0x14,%esp
  80ef14:	5b                   	pop    %ebx
  80ef15:	5d                   	pop    %ebp
  80ef16:	c3                   	ret    

0080ef17 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80ef17:	55                   	push   %ebp
  80ef18:	89 e5                	mov    %esp,%ebp
  80ef1a:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  80ef20:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80ef27:	00 00 00 
	b.cnt = 0;
  80ef2a:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80ef31:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80ef34:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ef37:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ef3b:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef3e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ef42:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80ef48:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ef4c:	c7 04 24 d8 ee 80 00 	movl   $0x80eed8,(%esp)
  80ef53:	e8 82 01 00 00       	call   80f0da <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80ef58:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  80ef5e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ef62:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80ef68:	89 04 24             	mov    %eax,(%esp)
  80ef6b:	e8 d8 08 00 00       	call   80f848 <sys_cputs>

	return b.cnt;
}
  80ef70:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80ef76:	c9                   	leave  
  80ef77:	c3                   	ret    

0080ef78 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80ef78:	55                   	push   %ebp
  80ef79:	89 e5                	mov    %esp,%ebp
  80ef7b:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80ef7e:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80ef81:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ef85:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef88:	89 04 24             	mov    %eax,(%esp)
  80ef8b:	e8 87 ff ff ff       	call   80ef17 <vcprintf>
	va_end(ap);

	return cnt;
}
  80ef90:	c9                   	leave  
  80ef91:	c3                   	ret    
	...

0080ef94 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80ef94:	55                   	push   %ebp
  80ef95:	89 e5                	mov    %esp,%ebp
  80ef97:	57                   	push   %edi
  80ef98:	56                   	push   %esi
  80ef99:	53                   	push   %ebx
  80ef9a:	83 ec 3c             	sub    $0x3c,%esp
  80ef9d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80efa0:	89 d7                	mov    %edx,%edi
  80efa2:	8b 45 08             	mov    0x8(%ebp),%eax
  80efa5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80efa8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80efab:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80efae:	8b 5d 14             	mov    0x14(%ebp),%ebx
  80efb1:	8b 75 18             	mov    0x18(%ebp),%esi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80efb4:	85 c0                	test   %eax,%eax
  80efb6:	75 08                	jne    80efc0 <printnum+0x2c>
  80efb8:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80efbb:	39 45 10             	cmp    %eax,0x10(%ebp)
  80efbe:	77 57                	ja     80f017 <printnum+0x83>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80efc0:	89 74 24 10          	mov    %esi,0x10(%esp)
  80efc4:	4b                   	dec    %ebx
  80efc5:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80efc9:	8b 45 10             	mov    0x10(%ebp),%eax
  80efcc:	89 44 24 08          	mov    %eax,0x8(%esp)
  80efd0:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  80efd4:	8b 74 24 0c          	mov    0xc(%esp),%esi
  80efd8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80efdf:	00 
  80efe0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80efe3:	89 04 24             	mov    %eax,(%esp)
  80efe6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80efe9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80efed:	e8 ba 26 00 00       	call   8116ac <__udivdi3>
  80eff2:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80eff6:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80effa:	89 04 24             	mov    %eax,(%esp)
  80effd:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f001:	89 fa                	mov    %edi,%edx
  80f003:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f006:	e8 89 ff ff ff       	call   80ef94 <printnum>
  80f00b:	eb 0f                	jmp    80f01c <printnum+0x88>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80f00d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f011:	89 34 24             	mov    %esi,(%esp)
  80f014:	ff 55 e4             	call   *-0x1c(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80f017:	4b                   	dec    %ebx
  80f018:	85 db                	test   %ebx,%ebx
  80f01a:	7f f1                	jg     80f00d <printnum+0x79>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80f01c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f020:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80f024:	8b 45 10             	mov    0x10(%ebp),%eax
  80f027:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f02b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80f032:	00 
  80f033:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80f036:	89 04 24             	mov    %eax,(%esp)
  80f039:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f03c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f040:	e8 87 27 00 00       	call   8117cc <__umoddi3>
  80f045:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f049:	0f be 80 43 3f 81 00 	movsbl 0x813f43(%eax),%eax
  80f050:	89 04 24             	mov    %eax,(%esp)
  80f053:	ff 55 e4             	call   *-0x1c(%ebp)
}
  80f056:	83 c4 3c             	add    $0x3c,%esp
  80f059:	5b                   	pop    %ebx
  80f05a:	5e                   	pop    %esi
  80f05b:	5f                   	pop    %edi
  80f05c:	5d                   	pop    %ebp
  80f05d:	c3                   	ret    

0080f05e <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80f05e:	55                   	push   %ebp
  80f05f:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  80f061:	83 fa 01             	cmp    $0x1,%edx
  80f064:	7e 0e                	jle    80f074 <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  80f066:	8b 10                	mov    (%eax),%edx
  80f068:	8d 4a 08             	lea    0x8(%edx),%ecx
  80f06b:	89 08                	mov    %ecx,(%eax)
  80f06d:	8b 02                	mov    (%edx),%eax
  80f06f:	8b 52 04             	mov    0x4(%edx),%edx
  80f072:	eb 22                	jmp    80f096 <getuint+0x38>
	else if (lflag)
  80f074:	85 d2                	test   %edx,%edx
  80f076:	74 10                	je     80f088 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  80f078:	8b 10                	mov    (%eax),%edx
  80f07a:	8d 4a 04             	lea    0x4(%edx),%ecx
  80f07d:	89 08                	mov    %ecx,(%eax)
  80f07f:	8b 02                	mov    (%edx),%eax
  80f081:	ba 00 00 00 00       	mov    $0x0,%edx
  80f086:	eb 0e                	jmp    80f096 <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  80f088:	8b 10                	mov    (%eax),%edx
  80f08a:	8d 4a 04             	lea    0x4(%edx),%ecx
  80f08d:	89 08                	mov    %ecx,(%eax)
  80f08f:	8b 02                	mov    (%edx),%eax
  80f091:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80f096:	5d                   	pop    %ebp
  80f097:	c3                   	ret    

0080f098 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80f098:	55                   	push   %ebp
  80f099:	89 e5                	mov    %esp,%ebp
  80f09b:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80f09e:	ff 40 08             	incl   0x8(%eax)
	if (b->buf < b->ebuf)
  80f0a1:	8b 10                	mov    (%eax),%edx
  80f0a3:	3b 50 04             	cmp    0x4(%eax),%edx
  80f0a6:	73 08                	jae    80f0b0 <sprintputch+0x18>
		*b->buf++ = ch;
  80f0a8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f0ab:	88 0a                	mov    %cl,(%edx)
  80f0ad:	42                   	inc    %edx
  80f0ae:	89 10                	mov    %edx,(%eax)
}
  80f0b0:	5d                   	pop    %ebp
  80f0b1:	c3                   	ret    

0080f0b2 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80f0b2:	55                   	push   %ebp
  80f0b3:	89 e5                	mov    %esp,%ebp
  80f0b5:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
  80f0b8:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80f0bb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f0bf:	8b 45 10             	mov    0x10(%ebp),%eax
  80f0c2:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f0c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f0c9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f0cd:	8b 45 08             	mov    0x8(%ebp),%eax
  80f0d0:	89 04 24             	mov    %eax,(%esp)
  80f0d3:	e8 02 00 00 00       	call   80f0da <vprintfmt>
	va_end(ap);
}
  80f0d8:	c9                   	leave  
  80f0d9:	c3                   	ret    

0080f0da <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80f0da:	55                   	push   %ebp
  80f0db:	89 e5                	mov    %esp,%ebp
  80f0dd:	57                   	push   %edi
  80f0de:	56                   	push   %esi
  80f0df:	53                   	push   %ebx
  80f0e0:	83 ec 4c             	sub    $0x4c,%esp
  80f0e3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80f0e6:	8b 75 10             	mov    0x10(%ebp),%esi
  80f0e9:	eb 12                	jmp    80f0fd <vprintfmt+0x23>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  80f0eb:	85 c0                	test   %eax,%eax
  80f0ed:	0f 84 6b 03 00 00    	je     80f45e <vprintfmt+0x384>
				return;
			putch(ch, putdat);
  80f0f3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f0f7:	89 04 24             	mov    %eax,(%esp)
  80f0fa:	ff 55 08             	call   *0x8(%ebp)
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80f0fd:	0f b6 06             	movzbl (%esi),%eax
  80f100:	46                   	inc    %esi
  80f101:	83 f8 25             	cmp    $0x25,%eax
  80f104:	75 e5                	jne    80f0eb <vprintfmt+0x11>
  80f106:	c6 45 d8 20          	movb   $0x20,-0x28(%ebp)
  80f10a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80f111:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80f116:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
  80f11d:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f122:	eb 26                	jmp    80f14a <vprintfmt+0x70>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f124:	8b 75 e0             	mov    -0x20(%ebp),%esi

		// flag to pad on the right
		case '-':
			padc = '-';
  80f127:	c6 45 d8 2d          	movb   $0x2d,-0x28(%ebp)
  80f12b:	eb 1d                	jmp    80f14a <vprintfmt+0x70>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f12d:	8b 75 e0             	mov    -0x20(%ebp),%esi
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80f130:	c6 45 d8 30          	movb   $0x30,-0x28(%ebp)
  80f134:	eb 14                	jmp    80f14a <vprintfmt+0x70>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f136:	8b 75 e0             	mov    -0x20(%ebp),%esi
			precision = va_arg(ap, int);
			goto process_precision;

		case '.':
			if (width < 0)
				width = 0;
  80f139:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80f140:	eb 08                	jmp    80f14a <vprintfmt+0x70>
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
				width = precision, precision = -1;
  80f142:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80f145:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f14a:	0f b6 06             	movzbl (%esi),%eax
  80f14d:	8d 56 01             	lea    0x1(%esi),%edx
  80f150:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80f153:	8a 16                	mov    (%esi),%dl
  80f155:	83 ea 23             	sub    $0x23,%edx
  80f158:	80 fa 55             	cmp    $0x55,%dl
  80f15b:	0f 87 e1 02 00 00    	ja     80f442 <vprintfmt+0x368>
  80f161:	0f b6 d2             	movzbl %dl,%edx
  80f164:	ff 24 95 80 40 81 00 	jmp    *0x814080(,%edx,4)
  80f16b:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f16e:	bf 00 00 00 00       	mov    $0x0,%edi
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80f173:	8d 14 bf             	lea    (%edi,%edi,4),%edx
  80f176:	8d 7c 50 d0          	lea    -0x30(%eax,%edx,2),%edi
				ch = *fmt;
  80f17a:	0f be 06             	movsbl (%esi),%eax
				if (ch < '0' || ch > '9')
  80f17d:	8d 50 d0             	lea    -0x30(%eax),%edx
  80f180:	83 fa 09             	cmp    $0x9,%edx
  80f183:	77 2a                	ja     80f1af <vprintfmt+0xd5>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80f185:	46                   	inc    %esi
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80f186:	eb eb                	jmp    80f173 <vprintfmt+0x99>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80f188:	8b 45 14             	mov    0x14(%ebp),%eax
  80f18b:	8d 50 04             	lea    0x4(%eax),%edx
  80f18e:	89 55 14             	mov    %edx,0x14(%ebp)
  80f191:	8b 38                	mov    (%eax),%edi
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f193:	8b 75 e0             	mov    -0x20(%ebp),%esi
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  80f196:	eb 17                	jmp    80f1af <vprintfmt+0xd5>

		case '.':
			if (width < 0)
  80f198:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f19c:	78 98                	js     80f136 <vprintfmt+0x5c>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f19e:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f1a1:	eb a7                	jmp    80f14a <vprintfmt+0x70>
  80f1a3:	8b 75 e0             	mov    -0x20(%ebp),%esi
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  80f1a6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
  80f1ad:	eb 9b                	jmp    80f14a <vprintfmt+0x70>

		process_precision:
			if (width < 0)
  80f1af:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f1b3:	79 95                	jns    80f14a <vprintfmt+0x70>
  80f1b5:	eb 8b                	jmp    80f142 <vprintfmt+0x68>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80f1b7:	41                   	inc    %ecx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f1b8:	8b 75 e0             	mov    -0x20(%ebp),%esi
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
			goto reswitch;
  80f1bb:	eb 8d                	jmp    80f14a <vprintfmt+0x70>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80f1bd:	8b 45 14             	mov    0x14(%ebp),%eax
  80f1c0:	8d 50 04             	lea    0x4(%eax),%edx
  80f1c3:	89 55 14             	mov    %edx,0x14(%ebp)
  80f1c6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f1ca:	8b 00                	mov    (%eax),%eax
  80f1cc:	89 04 24             	mov    %eax,(%esp)
  80f1cf:	ff 55 08             	call   *0x8(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f1d2:	8b 75 e0             	mov    -0x20(%ebp),%esi
			goto reswitch;

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
			break;
  80f1d5:	e9 23 ff ff ff       	jmp    80f0fd <vprintfmt+0x23>

		// error message
		case 'e':
			err = va_arg(ap, int);
  80f1da:	8b 45 14             	mov    0x14(%ebp),%eax
  80f1dd:	8d 50 04             	lea    0x4(%eax),%edx
  80f1e0:	89 55 14             	mov    %edx,0x14(%ebp)
  80f1e3:	8b 00                	mov    (%eax),%eax
  80f1e5:	85 c0                	test   %eax,%eax
  80f1e7:	79 02                	jns    80f1eb <vprintfmt+0x111>
  80f1e9:	f7 d8                	neg    %eax
  80f1eb:	89 c2                	mov    %eax,%edx
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80f1ed:	83 f8 10             	cmp    $0x10,%eax
  80f1f0:	7f 0b                	jg     80f1fd <vprintfmt+0x123>
  80f1f2:	8b 04 85 e0 41 81 00 	mov    0x8141e0(,%eax,4),%eax
  80f1f9:	85 c0                	test   %eax,%eax
  80f1fb:	75 23                	jne    80f220 <vprintfmt+0x146>
				printfmt(putch, putdat, "error %d", err);
  80f1fd:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f201:	c7 44 24 08 5b 3f 81 	movl   $0x813f5b,0x8(%esp)
  80f208:	00 
  80f209:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f20d:	8b 45 08             	mov    0x8(%ebp),%eax
  80f210:	89 04 24             	mov    %eax,(%esp)
  80f213:	e8 9a fe ff ff       	call   80f0b2 <printfmt>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f218:	8b 75 e0             	mov    -0x20(%ebp),%esi
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
  80f21b:	e9 dd fe ff ff       	jmp    80f0fd <vprintfmt+0x23>
			else
				printfmt(putch, putdat, "%s", p);
  80f220:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f224:	c7 44 24 08 29 31 81 	movl   $0x813129,0x8(%esp)
  80f22b:	00 
  80f22c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f230:	8b 55 08             	mov    0x8(%ebp),%edx
  80f233:	89 14 24             	mov    %edx,(%esp)
  80f236:	e8 77 fe ff ff       	call   80f0b2 <printfmt>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f23b:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f23e:	e9 ba fe ff ff       	jmp    80f0fd <vprintfmt+0x23>
  80f243:	89 f9                	mov    %edi,%ecx
  80f245:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f248:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80f24b:	8b 45 14             	mov    0x14(%ebp),%eax
  80f24e:	8d 50 04             	lea    0x4(%eax),%edx
  80f251:	89 55 14             	mov    %edx,0x14(%ebp)
  80f254:	8b 30                	mov    (%eax),%esi
  80f256:	85 f6                	test   %esi,%esi
  80f258:	75 05                	jne    80f25f <vprintfmt+0x185>
				p = "(null)";
  80f25a:	be 54 3f 81 00       	mov    $0x813f54,%esi
			if (width > 0 && padc != '-')
  80f25f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80f263:	0f 8e 84 00 00 00    	jle    80f2ed <vprintfmt+0x213>
  80f269:	80 7d d8 2d          	cmpb   $0x2d,-0x28(%ebp)
  80f26d:	74 7e                	je     80f2ed <vprintfmt+0x213>
				for (width -= strnlen(p, precision); width > 0; width--)
  80f26f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80f273:	89 34 24             	mov    %esi,(%esp)
  80f276:	e8 8b 02 00 00       	call   80f506 <strnlen>
  80f27b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80f27e:	29 c2                	sub    %eax,%edx
  80f280:	89 55 e4             	mov    %edx,-0x1c(%ebp)
					putch(padc, putdat);
  80f283:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
  80f287:	89 75 d0             	mov    %esi,-0x30(%ebp)
  80f28a:	89 7d cc             	mov    %edi,-0x34(%ebp)
  80f28d:	89 de                	mov    %ebx,%esi
  80f28f:	89 d3                	mov    %edx,%ebx
  80f291:	89 c7                	mov    %eax,%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f293:	eb 0b                	jmp    80f2a0 <vprintfmt+0x1c6>
					putch(padc, putdat);
  80f295:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f299:	89 3c 24             	mov    %edi,(%esp)
  80f29c:	ff 55 08             	call   *0x8(%ebp)
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f29f:	4b                   	dec    %ebx
  80f2a0:	85 db                	test   %ebx,%ebx
  80f2a2:	7f f1                	jg     80f295 <vprintfmt+0x1bb>
  80f2a4:	8b 7d cc             	mov    -0x34(%ebp),%edi
  80f2a7:	89 f3                	mov    %esi,%ebx
  80f2a9:	8b 75 d0             	mov    -0x30(%ebp),%esi

// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
  80f2ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f2af:	85 c0                	test   %eax,%eax
  80f2b1:	79 05                	jns    80f2b8 <vprintfmt+0x1de>
  80f2b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80f2b8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f2bb:	29 c2                	sub    %eax,%edx
  80f2bd:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80f2c0:	eb 2b                	jmp    80f2ed <vprintfmt+0x213>
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80f2c2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80f2c6:	74 18                	je     80f2e0 <vprintfmt+0x206>
  80f2c8:	8d 50 e0             	lea    -0x20(%eax),%edx
  80f2cb:	83 fa 5e             	cmp    $0x5e,%edx
  80f2ce:	76 10                	jbe    80f2e0 <vprintfmt+0x206>
					putch('?', putdat);
  80f2d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f2d4:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  80f2db:	ff 55 08             	call   *0x8(%ebp)
  80f2de:	eb 0a                	jmp    80f2ea <vprintfmt+0x210>
				else
					putch(ch, putdat);
  80f2e0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f2e4:	89 04 24             	mov    %eax,(%esp)
  80f2e7:	ff 55 08             	call   *0x8(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80f2ea:	ff 4d e4             	decl   -0x1c(%ebp)
  80f2ed:	0f be 06             	movsbl (%esi),%eax
  80f2f0:	46                   	inc    %esi
  80f2f1:	85 c0                	test   %eax,%eax
  80f2f3:	74 21                	je     80f316 <vprintfmt+0x23c>
  80f2f5:	85 ff                	test   %edi,%edi
  80f2f7:	78 c9                	js     80f2c2 <vprintfmt+0x1e8>
  80f2f9:	4f                   	dec    %edi
  80f2fa:	79 c6                	jns    80f2c2 <vprintfmt+0x1e8>
  80f2fc:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f2ff:	89 de                	mov    %ebx,%esi
  80f301:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80f304:	eb 18                	jmp    80f31e <vprintfmt+0x244>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80f306:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f30a:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80f311:	ff d7                	call   *%edi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80f313:	4b                   	dec    %ebx
  80f314:	eb 08                	jmp    80f31e <vprintfmt+0x244>
  80f316:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f319:	89 de                	mov    %ebx,%esi
  80f31b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80f31e:	85 db                	test   %ebx,%ebx
  80f320:	7f e4                	jg     80f306 <vprintfmt+0x22c>
  80f322:	89 7d 08             	mov    %edi,0x8(%ebp)
  80f325:	89 f3                	mov    %esi,%ebx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f327:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f32a:	e9 ce fd ff ff       	jmp    80f0fd <vprintfmt+0x23>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80f32f:	83 f9 01             	cmp    $0x1,%ecx
  80f332:	7e 10                	jle    80f344 <vprintfmt+0x26a>
		return va_arg(*ap, long long);
  80f334:	8b 45 14             	mov    0x14(%ebp),%eax
  80f337:	8d 50 08             	lea    0x8(%eax),%edx
  80f33a:	89 55 14             	mov    %edx,0x14(%ebp)
  80f33d:	8b 30                	mov    (%eax),%esi
  80f33f:	8b 78 04             	mov    0x4(%eax),%edi
  80f342:	eb 26                	jmp    80f36a <vprintfmt+0x290>
	else if (lflag)
  80f344:	85 c9                	test   %ecx,%ecx
  80f346:	74 12                	je     80f35a <vprintfmt+0x280>
		return va_arg(*ap, long);
  80f348:	8b 45 14             	mov    0x14(%ebp),%eax
  80f34b:	8d 50 04             	lea    0x4(%eax),%edx
  80f34e:	89 55 14             	mov    %edx,0x14(%ebp)
  80f351:	8b 30                	mov    (%eax),%esi
  80f353:	89 f7                	mov    %esi,%edi
  80f355:	c1 ff 1f             	sar    $0x1f,%edi
  80f358:	eb 10                	jmp    80f36a <vprintfmt+0x290>
	else
		return va_arg(*ap, int);
  80f35a:	8b 45 14             	mov    0x14(%ebp),%eax
  80f35d:	8d 50 04             	lea    0x4(%eax),%edx
  80f360:	89 55 14             	mov    %edx,0x14(%ebp)
  80f363:	8b 30                	mov    (%eax),%esi
  80f365:	89 f7                	mov    %esi,%edi
  80f367:	c1 ff 1f             	sar    $0x1f,%edi
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  80f36a:	85 ff                	test   %edi,%edi
  80f36c:	78 0a                	js     80f378 <vprintfmt+0x29e>
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  80f36e:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f373:	e9 8c 00 00 00       	jmp    80f404 <vprintfmt+0x32a>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
				putch('-', putdat);
  80f378:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f37c:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  80f383:	ff 55 08             	call   *0x8(%ebp)
				num = -(long long) num;
  80f386:	f7 de                	neg    %esi
  80f388:	83 d7 00             	adc    $0x0,%edi
  80f38b:	f7 df                	neg    %edi
			}
			base = 10;
  80f38d:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f392:	eb 70                	jmp    80f404 <vprintfmt+0x32a>
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  80f394:	89 ca                	mov    %ecx,%edx
  80f396:	8d 45 14             	lea    0x14(%ebp),%eax
  80f399:	e8 c0 fc ff ff       	call   80f05e <getuint>
  80f39e:	89 c6                	mov    %eax,%esi
  80f3a0:	89 d7                	mov    %edx,%edi
			base = 10;
  80f3a2:	b8 0a 00 00 00       	mov    $0xa,%eax
			goto number;
  80f3a7:	eb 5b                	jmp    80f404 <vprintfmt+0x32a>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			// putch('0', putdat);
			num = getuint(&ap,lflag);
  80f3a9:	89 ca                	mov    %ecx,%edx
  80f3ab:	8d 45 14             	lea    0x14(%ebp),%eax
  80f3ae:	e8 ab fc ff ff       	call   80f05e <getuint>
  80f3b3:	89 c6                	mov    %eax,%esi
  80f3b5:	89 d7                	mov    %edx,%edi
			base = 8;
  80f3b7:	b8 08 00 00 00       	mov    $0x8,%eax
			goto number;
  80f3bc:	eb 46                	jmp    80f404 <vprintfmt+0x32a>

		// pointer
		case 'p':
			putch('0', putdat);
  80f3be:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f3c2:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  80f3c9:	ff 55 08             	call   *0x8(%ebp)
			putch('x', putdat);
  80f3cc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f3d0:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  80f3d7:	ff 55 08             	call   *0x8(%ebp)
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  80f3da:	8b 45 14             	mov    0x14(%ebp),%eax
  80f3dd:	8d 50 04             	lea    0x4(%eax),%edx
  80f3e0:	89 55 14             	mov    %edx,0x14(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80f3e3:	8b 30                	mov    (%eax),%esi
  80f3e5:	bf 00 00 00 00       	mov    $0x0,%edi
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  80f3ea:	b8 10 00 00 00       	mov    $0x10,%eax
			goto number;
  80f3ef:	eb 13                	jmp    80f404 <vprintfmt+0x32a>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  80f3f1:	89 ca                	mov    %ecx,%edx
  80f3f3:	8d 45 14             	lea    0x14(%ebp),%eax
  80f3f6:	e8 63 fc ff ff       	call   80f05e <getuint>
  80f3fb:	89 c6                	mov    %eax,%esi
  80f3fd:	89 d7                	mov    %edx,%edi
			base = 16;
  80f3ff:	b8 10 00 00 00       	mov    $0x10,%eax
		number:
			printnum(putch, putdat, num, base, width, padc);
  80f404:	0f be 55 d8          	movsbl -0x28(%ebp),%edx
  80f408:	89 54 24 10          	mov    %edx,0x10(%esp)
  80f40c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f40f:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f413:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f417:	89 34 24             	mov    %esi,(%esp)
  80f41a:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f41e:	89 da                	mov    %ebx,%edx
  80f420:	8b 45 08             	mov    0x8(%ebp),%eax
  80f423:	e8 6c fb ff ff       	call   80ef94 <printnum>
			break;
  80f428:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f42b:	e9 cd fc ff ff       	jmp    80f0fd <vprintfmt+0x23>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80f430:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f434:	89 04 24             	mov    %eax,(%esp)
  80f437:	ff 55 08             	call   *0x8(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f43a:	8b 75 e0             	mov    -0x20(%ebp),%esi
			break;

		// escaped '%' character
		case '%':
			putch(ch, putdat);
			break;
  80f43d:	e9 bb fc ff ff       	jmp    80f0fd <vprintfmt+0x23>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80f442:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f446:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  80f44d:	ff 55 08             	call   *0x8(%ebp)
			for (fmt--; fmt[-1] != '%'; fmt--)
  80f450:	eb 01                	jmp    80f453 <vprintfmt+0x379>
  80f452:	4e                   	dec    %esi
  80f453:	80 7e ff 25          	cmpb   $0x25,-0x1(%esi)
  80f457:	75 f9                	jne    80f452 <vprintfmt+0x378>
  80f459:	e9 9f fc ff ff       	jmp    80f0fd <vprintfmt+0x23>
				/* do nothing */;
			break;
		}
	}
}
  80f45e:	83 c4 4c             	add    $0x4c,%esp
  80f461:	5b                   	pop    %ebx
  80f462:	5e                   	pop    %esi
  80f463:	5f                   	pop    %edi
  80f464:	5d                   	pop    %ebp
  80f465:	c3                   	ret    

0080f466 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80f466:	55                   	push   %ebp
  80f467:	89 e5                	mov    %esp,%ebp
  80f469:	83 ec 28             	sub    $0x28,%esp
  80f46c:	8b 45 08             	mov    0x8(%ebp),%eax
  80f46f:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80f472:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80f475:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80f479:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80f47c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80f483:	85 c0                	test   %eax,%eax
  80f485:	74 30                	je     80f4b7 <vsnprintf+0x51>
  80f487:	85 d2                	test   %edx,%edx
  80f489:	7e 33                	jle    80f4be <vsnprintf+0x58>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80f48b:	8b 45 14             	mov    0x14(%ebp),%eax
  80f48e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f492:	8b 45 10             	mov    0x10(%ebp),%eax
  80f495:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f499:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80f49c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f4a0:	c7 04 24 98 f0 80 00 	movl   $0x80f098,(%esp)
  80f4a7:	e8 2e fc ff ff       	call   80f0da <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80f4ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80f4af:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80f4b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f4b5:	eb 0c                	jmp    80f4c3 <vsnprintf+0x5d>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80f4b7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f4bc:	eb 05                	jmp    80f4c3 <vsnprintf+0x5d>
  80f4be:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80f4c3:	c9                   	leave  
  80f4c4:	c3                   	ret    

0080f4c5 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80f4c5:	55                   	push   %ebp
  80f4c6:	89 e5                	mov    %esp,%ebp
  80f4c8:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80f4cb:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80f4ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f4d2:	8b 45 10             	mov    0x10(%ebp),%eax
  80f4d5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f4d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f4dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f4e0:	8b 45 08             	mov    0x8(%ebp),%eax
  80f4e3:	89 04 24             	mov    %eax,(%esp)
  80f4e6:	e8 7b ff ff ff       	call   80f466 <vsnprintf>
	va_end(ap);

	return rc;
}
  80f4eb:	c9                   	leave  
  80f4ec:	c3                   	ret    
  80f4ed:	00 00                	add    %al,(%eax)
	...

0080f4f0 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80f4f0:	55                   	push   %ebp
  80f4f1:	89 e5                	mov    %esp,%ebp
  80f4f3:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80f4f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80f4fb:	eb 01                	jmp    80f4fe <strlen+0xe>
		n++;
  80f4fd:	40                   	inc    %eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80f4fe:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80f502:	75 f9                	jne    80f4fd <strlen+0xd>
		n++;
	return n;
}
  80f504:	5d                   	pop    %ebp
  80f505:	c3                   	ret    

0080f506 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80f506:	55                   	push   %ebp
  80f507:	89 e5                	mov    %esp,%ebp
  80f509:	8b 4d 08             	mov    0x8(%ebp),%ecx
		n++;
	return n;
}

int
strnlen(const char *s, size_t size)
  80f50c:	8b 55 0c             	mov    0xc(%ebp),%edx
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f50f:	b8 00 00 00 00       	mov    $0x0,%eax
  80f514:	eb 01                	jmp    80f517 <strnlen+0x11>
		n++;
  80f516:	40                   	inc    %eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f517:	39 d0                	cmp    %edx,%eax
  80f519:	74 06                	je     80f521 <strnlen+0x1b>
  80f51b:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  80f51f:	75 f5                	jne    80f516 <strnlen+0x10>
		n++;
	return n;
}
  80f521:	5d                   	pop    %ebp
  80f522:	c3                   	ret    

0080f523 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80f523:	55                   	push   %ebp
  80f524:	89 e5                	mov    %esp,%ebp
  80f526:	53                   	push   %ebx
  80f527:	8b 45 08             	mov    0x8(%ebp),%eax
  80f52a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80f52d:	ba 00 00 00 00       	mov    $0x0,%edx
  80f532:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
  80f535:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  80f538:	42                   	inc    %edx
  80f539:	84 c9                	test   %cl,%cl
  80f53b:	75 f5                	jne    80f532 <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  80f53d:	5b                   	pop    %ebx
  80f53e:	5d                   	pop    %ebp
  80f53f:	c3                   	ret    

0080f540 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80f540:	55                   	push   %ebp
  80f541:	89 e5                	mov    %esp,%ebp
  80f543:	53                   	push   %ebx
  80f544:	83 ec 08             	sub    $0x8,%esp
  80f547:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80f54a:	89 1c 24             	mov    %ebx,(%esp)
  80f54d:	e8 9e ff ff ff       	call   80f4f0 <strlen>
	strcpy(dst + len, src);
  80f552:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f555:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f559:	01 d8                	add    %ebx,%eax
  80f55b:	89 04 24             	mov    %eax,(%esp)
  80f55e:	e8 c0 ff ff ff       	call   80f523 <strcpy>
	return dst;
}
  80f563:	89 d8                	mov    %ebx,%eax
  80f565:	83 c4 08             	add    $0x8,%esp
  80f568:	5b                   	pop    %ebx
  80f569:	5d                   	pop    %ebp
  80f56a:	c3                   	ret    

0080f56b <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80f56b:	55                   	push   %ebp
  80f56c:	89 e5                	mov    %esp,%ebp
  80f56e:	56                   	push   %esi
  80f56f:	53                   	push   %ebx
  80f570:	8b 45 08             	mov    0x8(%ebp),%eax
  80f573:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f576:	8b 75 10             	mov    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f579:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f57e:	eb 0c                	jmp    80f58c <strncpy+0x21>
		*dst++ = *src;
  80f580:	8a 1a                	mov    (%edx),%bl
  80f582:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80f585:	80 3a 01             	cmpb   $0x1,(%edx)
  80f588:	83 da ff             	sbb    $0xffffffff,%edx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f58b:	41                   	inc    %ecx
  80f58c:	39 f1                	cmp    %esi,%ecx
  80f58e:	75 f0                	jne    80f580 <strncpy+0x15>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80f590:	5b                   	pop    %ebx
  80f591:	5e                   	pop    %esi
  80f592:	5d                   	pop    %ebp
  80f593:	c3                   	ret    

0080f594 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80f594:	55                   	push   %ebp
  80f595:	89 e5                	mov    %esp,%ebp
  80f597:	56                   	push   %esi
  80f598:	53                   	push   %ebx
  80f599:	8b 75 08             	mov    0x8(%ebp),%esi
  80f59c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f59f:	8b 55 10             	mov    0x10(%ebp),%edx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f5a2:	85 d2                	test   %edx,%edx
  80f5a4:	75 0a                	jne    80f5b0 <strlcpy+0x1c>
  80f5a6:	89 f0                	mov    %esi,%eax
  80f5a8:	eb 1a                	jmp    80f5c4 <strlcpy+0x30>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80f5aa:	88 18                	mov    %bl,(%eax)
  80f5ac:	40                   	inc    %eax
  80f5ad:	41                   	inc    %ecx
  80f5ae:	eb 02                	jmp    80f5b2 <strlcpy+0x1e>
strlcpy(char *dst, const char *src, size_t size)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f5b0:	89 f0                	mov    %esi,%eax
		while (--size > 0 && *src != '\0')
  80f5b2:	4a                   	dec    %edx
  80f5b3:	74 0a                	je     80f5bf <strlcpy+0x2b>
  80f5b5:	8a 19                	mov    (%ecx),%bl
  80f5b7:	84 db                	test   %bl,%bl
  80f5b9:	75 ef                	jne    80f5aa <strlcpy+0x16>
  80f5bb:	89 c2                	mov    %eax,%edx
  80f5bd:	eb 02                	jmp    80f5c1 <strlcpy+0x2d>
  80f5bf:	89 c2                	mov    %eax,%edx
			*dst++ = *src++;
		*dst = '\0';
  80f5c1:	c6 02 00             	movb   $0x0,(%edx)
	}
	return dst - dst_in;
  80f5c4:	29 f0                	sub    %esi,%eax
}
  80f5c6:	5b                   	pop    %ebx
  80f5c7:	5e                   	pop    %esi
  80f5c8:	5d                   	pop    %ebp
  80f5c9:	c3                   	ret    

0080f5ca <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80f5ca:	55                   	push   %ebp
  80f5cb:	89 e5                	mov    %esp,%ebp
  80f5cd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f5d0:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f5d3:	eb 02                	jmp    80f5d7 <strcmp+0xd>
		p++, q++;
  80f5d5:	41                   	inc    %ecx
  80f5d6:	42                   	inc    %edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80f5d7:	8a 01                	mov    (%ecx),%al
  80f5d9:	84 c0                	test   %al,%al
  80f5db:	74 04                	je     80f5e1 <strcmp+0x17>
  80f5dd:	3a 02                	cmp    (%edx),%al
  80f5df:	74 f4                	je     80f5d5 <strcmp+0xb>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80f5e1:	0f b6 c0             	movzbl %al,%eax
  80f5e4:	0f b6 12             	movzbl (%edx),%edx
  80f5e7:	29 d0                	sub    %edx,%eax
}
  80f5e9:	5d                   	pop    %ebp
  80f5ea:	c3                   	ret    

0080f5eb <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f5eb:	55                   	push   %ebp
  80f5ec:	89 e5                	mov    %esp,%ebp
  80f5ee:	53                   	push   %ebx
  80f5ef:	8b 45 08             	mov    0x8(%ebp),%eax
  80f5f2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f5f5:	8b 55 10             	mov    0x10(%ebp),%edx
	while (n > 0 && *p && *p == *q)
  80f5f8:	eb 03                	jmp    80f5fd <strncmp+0x12>
		n--, p++, q++;
  80f5fa:	4a                   	dec    %edx
  80f5fb:	40                   	inc    %eax
  80f5fc:	41                   	inc    %ecx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80f5fd:	85 d2                	test   %edx,%edx
  80f5ff:	74 14                	je     80f615 <strncmp+0x2a>
  80f601:	8a 18                	mov    (%eax),%bl
  80f603:	84 db                	test   %bl,%bl
  80f605:	74 04                	je     80f60b <strncmp+0x20>
  80f607:	3a 19                	cmp    (%ecx),%bl
  80f609:	74 ef                	je     80f5fa <strncmp+0xf>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80f60b:	0f b6 00             	movzbl (%eax),%eax
  80f60e:	0f b6 11             	movzbl (%ecx),%edx
  80f611:	29 d0                	sub    %edx,%eax
  80f613:	eb 05                	jmp    80f61a <strncmp+0x2f>
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
  80f615:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80f61a:	5b                   	pop    %ebx
  80f61b:	5d                   	pop    %ebp
  80f61c:	c3                   	ret    

0080f61d <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80f61d:	55                   	push   %ebp
  80f61e:	89 e5                	mov    %esp,%ebp
  80f620:	8b 45 08             	mov    0x8(%ebp),%eax
  80f623:	8a 4d 0c             	mov    0xc(%ebp),%cl
	for (; *s; s++)
  80f626:	eb 05                	jmp    80f62d <strchr+0x10>
		if (*s == c)
  80f628:	38 ca                	cmp    %cl,%dl
  80f62a:	74 0c                	je     80f638 <strchr+0x1b>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80f62c:	40                   	inc    %eax
  80f62d:	8a 10                	mov    (%eax),%dl
  80f62f:	84 d2                	test   %dl,%dl
  80f631:	75 f5                	jne    80f628 <strchr+0xb>
		if (*s == c)
			return (char *) s;
	return 0;
  80f633:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f638:	5d                   	pop    %ebp
  80f639:	c3                   	ret    

0080f63a <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f63a:	55                   	push   %ebp
  80f63b:	89 e5                	mov    %esp,%ebp
  80f63d:	8b 45 08             	mov    0x8(%ebp),%eax
  80f640:	8a 4d 0c             	mov    0xc(%ebp),%cl
	for (; *s; s++)
  80f643:	eb 05                	jmp    80f64a <strfind+0x10>
		if (*s == c)
  80f645:	38 ca                	cmp    %cl,%dl
  80f647:	74 07                	je     80f650 <strfind+0x16>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80f649:	40                   	inc    %eax
  80f64a:	8a 10                	mov    (%eax),%dl
  80f64c:	84 d2                	test   %dl,%dl
  80f64e:	75 f5                	jne    80f645 <strfind+0xb>
		if (*s == c)
			break;
	return (char *) s;
}
  80f650:	5d                   	pop    %ebp
  80f651:	c3                   	ret    

0080f652 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f652:	55                   	push   %ebp
  80f653:	89 e5                	mov    %esp,%ebp
  80f655:	57                   	push   %edi
  80f656:	56                   	push   %esi
  80f657:	53                   	push   %ebx
  80f658:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f65b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f65e:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f661:	85 c9                	test   %ecx,%ecx
  80f663:	74 30                	je     80f695 <memset+0x43>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f665:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80f66b:	75 25                	jne    80f692 <memset+0x40>
  80f66d:	f6 c1 03             	test   $0x3,%cl
  80f670:	75 20                	jne    80f692 <memset+0x40>
		c &= 0xFF;
  80f672:	0f b6 d0             	movzbl %al,%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f675:	89 d3                	mov    %edx,%ebx
  80f677:	c1 e3 08             	shl    $0x8,%ebx
  80f67a:	89 d6                	mov    %edx,%esi
  80f67c:	c1 e6 18             	shl    $0x18,%esi
  80f67f:	89 d0                	mov    %edx,%eax
  80f681:	c1 e0 10             	shl    $0x10,%eax
  80f684:	09 f0                	or     %esi,%eax
  80f686:	09 d0                	or     %edx,%eax
  80f688:	09 d8                	or     %ebx,%eax
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f68a:	c1 e9 02             	shr    $0x2,%ecx
	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  80f68d:	fc                   	cld    
  80f68e:	f3 ab                	rep stos %eax,%es:(%edi)
  80f690:	eb 03                	jmp    80f695 <memset+0x43>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f692:	fc                   	cld    
  80f693:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f695:	89 f8                	mov    %edi,%eax
  80f697:	5b                   	pop    %ebx
  80f698:	5e                   	pop    %esi
  80f699:	5f                   	pop    %edi
  80f69a:	5d                   	pop    %ebp
  80f69b:	c3                   	ret    

0080f69c <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f69c:	55                   	push   %ebp
  80f69d:	89 e5                	mov    %esp,%ebp
  80f69f:	57                   	push   %edi
  80f6a0:	56                   	push   %esi
  80f6a1:	8b 45 08             	mov    0x8(%ebp),%eax
  80f6a4:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f6a7:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f6aa:	39 c6                	cmp    %eax,%esi
  80f6ac:	73 34                	jae    80f6e2 <memmove+0x46>
  80f6ae:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f6b1:	39 d0                	cmp    %edx,%eax
  80f6b3:	73 2d                	jae    80f6e2 <memmove+0x46>
		s += n;
		d += n;
  80f6b5:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f6b8:	f6 c2 03             	test   $0x3,%dl
  80f6bb:	75 1b                	jne    80f6d8 <memmove+0x3c>
  80f6bd:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80f6c3:	75 13                	jne    80f6d8 <memmove+0x3c>
  80f6c5:	f6 c1 03             	test   $0x3,%cl
  80f6c8:	75 0e                	jne    80f6d8 <memmove+0x3c>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f6ca:	83 ef 04             	sub    $0x4,%edi
  80f6cd:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f6d0:	c1 e9 02             	shr    $0x2,%ecx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  80f6d3:	fd                   	std    
  80f6d4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f6d6:	eb 07                	jmp    80f6df <memmove+0x43>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f6d8:	4f                   	dec    %edi
  80f6d9:	8d 72 ff             	lea    -0x1(%edx),%esi
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80f6dc:	fd                   	std    
  80f6dd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f6df:	fc                   	cld    
  80f6e0:	eb 20                	jmp    80f702 <memmove+0x66>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f6e2:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f6e8:	75 13                	jne    80f6fd <memmove+0x61>
  80f6ea:	a8 03                	test   $0x3,%al
  80f6ec:	75 0f                	jne    80f6fd <memmove+0x61>
  80f6ee:	f6 c1 03             	test   $0x3,%cl
  80f6f1:	75 0a                	jne    80f6fd <memmove+0x61>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f6f3:	c1 e9 02             	shr    $0x2,%ecx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  80f6f6:	89 c7                	mov    %eax,%edi
  80f6f8:	fc                   	cld    
  80f6f9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f6fb:	eb 05                	jmp    80f702 <memmove+0x66>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80f6fd:	89 c7                	mov    %eax,%edi
  80f6ff:	fc                   	cld    
  80f700:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f702:	5e                   	pop    %esi
  80f703:	5f                   	pop    %edi
  80f704:	5d                   	pop    %ebp
  80f705:	c3                   	ret    

0080f706 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f706:	55                   	push   %ebp
  80f707:	89 e5                	mov    %esp,%ebp
  80f709:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f70c:	8b 45 10             	mov    0x10(%ebp),%eax
  80f70f:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f713:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f716:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f71a:	8b 45 08             	mov    0x8(%ebp),%eax
  80f71d:	89 04 24             	mov    %eax,(%esp)
  80f720:	e8 77 ff ff ff       	call   80f69c <memmove>
}
  80f725:	c9                   	leave  
  80f726:	c3                   	ret    

0080f727 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f727:	55                   	push   %ebp
  80f728:	89 e5                	mov    %esp,%ebp
  80f72a:	57                   	push   %edi
  80f72b:	56                   	push   %esi
  80f72c:	53                   	push   %ebx
  80f72d:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f730:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f733:	8b 5d 10             	mov    0x10(%ebp),%ebx
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f736:	ba 00 00 00 00       	mov    $0x0,%edx
  80f73b:	eb 16                	jmp    80f753 <memcmp+0x2c>
		if (*s1 != *s2)
  80f73d:	8a 04 17             	mov    (%edi,%edx,1),%al
  80f740:	42                   	inc    %edx
  80f741:	8a 4c 16 ff          	mov    -0x1(%esi,%edx,1),%cl
  80f745:	38 c8                	cmp    %cl,%al
  80f747:	74 0a                	je     80f753 <memcmp+0x2c>
			return (int) *s1 - (int) *s2;
  80f749:	0f b6 c0             	movzbl %al,%eax
  80f74c:	0f b6 c9             	movzbl %cl,%ecx
  80f74f:	29 c8                	sub    %ecx,%eax
  80f751:	eb 09                	jmp    80f75c <memcmp+0x35>
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f753:	39 da                	cmp    %ebx,%edx
  80f755:	75 e6                	jne    80f73d <memcmp+0x16>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80f757:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f75c:	5b                   	pop    %ebx
  80f75d:	5e                   	pop    %esi
  80f75e:	5f                   	pop    %edi
  80f75f:	5d                   	pop    %ebp
  80f760:	c3                   	ret    

0080f761 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f761:	55                   	push   %ebp
  80f762:	89 e5                	mov    %esp,%ebp
  80f764:	8b 45 08             	mov    0x8(%ebp),%eax
  80f767:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f76a:	89 c2                	mov    %eax,%edx
  80f76c:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80f76f:	eb 05                	jmp    80f776 <memfind+0x15>
		if (*(const unsigned char *) s == (unsigned char) c)
  80f771:	38 08                	cmp    %cl,(%eax)
  80f773:	74 05                	je     80f77a <memfind+0x19>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80f775:	40                   	inc    %eax
  80f776:	39 d0                	cmp    %edx,%eax
  80f778:	72 f7                	jb     80f771 <memfind+0x10>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80f77a:	5d                   	pop    %ebp
  80f77b:	c3                   	ret    

0080f77c <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80f77c:	55                   	push   %ebp
  80f77d:	89 e5                	mov    %esp,%ebp
  80f77f:	57                   	push   %edi
  80f780:	56                   	push   %esi
  80f781:	53                   	push   %ebx
  80f782:	8b 55 08             	mov    0x8(%ebp),%edx
  80f785:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f788:	eb 01                	jmp    80f78b <strtol+0xf>
		s++;
  80f78a:	42                   	inc    %edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f78b:	8a 02                	mov    (%edx),%al
  80f78d:	3c 20                	cmp    $0x20,%al
  80f78f:	74 f9                	je     80f78a <strtol+0xe>
  80f791:	3c 09                	cmp    $0x9,%al
  80f793:	74 f5                	je     80f78a <strtol+0xe>
		s++;

	// plus/minus sign
	if (*s == '+')
  80f795:	3c 2b                	cmp    $0x2b,%al
  80f797:	75 08                	jne    80f7a1 <strtol+0x25>
		s++;
  80f799:	42                   	inc    %edx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80f79a:	bf 00 00 00 00       	mov    $0x0,%edi
  80f79f:	eb 13                	jmp    80f7b4 <strtol+0x38>
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  80f7a1:	3c 2d                	cmp    $0x2d,%al
  80f7a3:	75 0a                	jne    80f7af <strtol+0x33>
		s++, neg = 1;
  80f7a5:	8d 52 01             	lea    0x1(%edx),%edx
  80f7a8:	bf 01 00 00 00       	mov    $0x1,%edi
  80f7ad:	eb 05                	jmp    80f7b4 <strtol+0x38>
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80f7af:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f7b4:	85 db                	test   %ebx,%ebx
  80f7b6:	74 05                	je     80f7bd <strtol+0x41>
  80f7b8:	83 fb 10             	cmp    $0x10,%ebx
  80f7bb:	75 28                	jne    80f7e5 <strtol+0x69>
  80f7bd:	8a 02                	mov    (%edx),%al
  80f7bf:	3c 30                	cmp    $0x30,%al
  80f7c1:	75 10                	jne    80f7d3 <strtol+0x57>
  80f7c3:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80f7c7:	75 0a                	jne    80f7d3 <strtol+0x57>
		s += 2, base = 16;
  80f7c9:	83 c2 02             	add    $0x2,%edx
  80f7cc:	bb 10 00 00 00       	mov    $0x10,%ebx
  80f7d1:	eb 12                	jmp    80f7e5 <strtol+0x69>
	else if (base == 0 && s[0] == '0')
  80f7d3:	85 db                	test   %ebx,%ebx
  80f7d5:	75 0e                	jne    80f7e5 <strtol+0x69>
  80f7d7:	3c 30                	cmp    $0x30,%al
  80f7d9:	75 05                	jne    80f7e0 <strtol+0x64>
		s++, base = 8;
  80f7db:	42                   	inc    %edx
  80f7dc:	b3 08                	mov    $0x8,%bl
  80f7de:	eb 05                	jmp    80f7e5 <strtol+0x69>
	else if (base == 0)
		base = 10;
  80f7e0:	bb 0a 00 00 00       	mov    $0xa,%ebx
  80f7e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80f7ea:	89 de                	mov    %ebx,%esi

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80f7ec:	8a 0a                	mov    (%edx),%cl
  80f7ee:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  80f7f1:	80 fb 09             	cmp    $0x9,%bl
  80f7f4:	77 08                	ja     80f7fe <strtol+0x82>
			dig = *s - '0';
  80f7f6:	0f be c9             	movsbl %cl,%ecx
  80f7f9:	83 e9 30             	sub    $0x30,%ecx
  80f7fc:	eb 1e                	jmp    80f81c <strtol+0xa0>
		else if (*s >= 'a' && *s <= 'z')
  80f7fe:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  80f801:	80 fb 19             	cmp    $0x19,%bl
  80f804:	77 08                	ja     80f80e <strtol+0x92>
			dig = *s - 'a' + 10;
  80f806:	0f be c9             	movsbl %cl,%ecx
  80f809:	83 e9 57             	sub    $0x57,%ecx
  80f80c:	eb 0e                	jmp    80f81c <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
  80f80e:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  80f811:	80 fb 19             	cmp    $0x19,%bl
  80f814:	77 12                	ja     80f828 <strtol+0xac>
			dig = *s - 'A' + 10;
  80f816:	0f be c9             	movsbl %cl,%ecx
  80f819:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  80f81c:	39 f1                	cmp    %esi,%ecx
  80f81e:	7d 0c                	jge    80f82c <strtol+0xb0>
			break;
		s++, val = (val * base) + dig;
  80f820:	42                   	inc    %edx
  80f821:	0f af c6             	imul   %esi,%eax
  80f824:	01 c8                	add    %ecx,%eax
		// we don't properly detect overflow!
	}
  80f826:	eb c4                	jmp    80f7ec <strtol+0x70>

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
		else if (*s >= 'a' && *s <= 'z')
			dig = *s - 'a' + 10;
		else if (*s >= 'A' && *s <= 'Z')
  80f828:	89 c1                	mov    %eax,%ecx
  80f82a:	eb 02                	jmp    80f82e <strtol+0xb2>
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80f82c:	89 c1                	mov    %eax,%ecx
			break;
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  80f82e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f832:	74 05                	je     80f839 <strtol+0xbd>
		*endptr = (char *) s;
  80f834:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80f837:	89 13                	mov    %edx,(%ebx)
	return (neg ? -val : val);
  80f839:	85 ff                	test   %edi,%edi
  80f83b:	74 04                	je     80f841 <strtol+0xc5>
  80f83d:	89 c8                	mov    %ecx,%eax
  80f83f:	f7 d8                	neg    %eax
}
  80f841:	5b                   	pop    %ebx
  80f842:	5e                   	pop    %esi
  80f843:	5f                   	pop    %edi
  80f844:	5d                   	pop    %ebp
  80f845:	c3                   	ret    
	...

0080f848 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80f848:	55                   	push   %ebp
  80f849:	89 e5                	mov    %esp,%ebp
  80f84b:	57                   	push   %edi
  80f84c:	56                   	push   %esi
  80f84d:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f84e:	b8 00 00 00 00       	mov    $0x0,%eax
  80f853:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f856:	8b 55 08             	mov    0x8(%ebp),%edx
  80f859:	89 c3                	mov    %eax,%ebx
  80f85b:	89 c7                	mov    %eax,%edi
  80f85d:	89 c6                	mov    %eax,%esi
  80f85f:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80f861:	5b                   	pop    %ebx
  80f862:	5e                   	pop    %esi
  80f863:	5f                   	pop    %edi
  80f864:	5d                   	pop    %ebp
  80f865:	c3                   	ret    

0080f866 <sys_cgetc>:

int
sys_cgetc(void)
{
  80f866:	55                   	push   %ebp
  80f867:	89 e5                	mov    %esp,%ebp
  80f869:	57                   	push   %edi
  80f86a:	56                   	push   %esi
  80f86b:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f86c:	ba 00 00 00 00       	mov    $0x0,%edx
  80f871:	b8 01 00 00 00       	mov    $0x1,%eax
  80f876:	89 d1                	mov    %edx,%ecx
  80f878:	89 d3                	mov    %edx,%ebx
  80f87a:	89 d7                	mov    %edx,%edi
  80f87c:	89 d6                	mov    %edx,%esi
  80f87e:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80f880:	5b                   	pop    %ebx
  80f881:	5e                   	pop    %esi
  80f882:	5f                   	pop    %edi
  80f883:	5d                   	pop    %ebp
  80f884:	c3                   	ret    

0080f885 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80f885:	55                   	push   %ebp
  80f886:	89 e5                	mov    %esp,%ebp
  80f888:	57                   	push   %edi
  80f889:	56                   	push   %esi
  80f88a:	53                   	push   %ebx
  80f88b:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f88e:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f893:	b8 03 00 00 00       	mov    $0x3,%eax
  80f898:	8b 55 08             	mov    0x8(%ebp),%edx
  80f89b:	89 cb                	mov    %ecx,%ebx
  80f89d:	89 cf                	mov    %ecx,%edi
  80f89f:	89 ce                	mov    %ecx,%esi
  80f8a1:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80f8a3:	85 c0                	test   %eax,%eax
  80f8a5:	7e 28                	jle    80f8cf <sys_env_destroy+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f8a7:	89 44 24 10          	mov    %eax,0x10(%esp)
  80f8ab:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  80f8b2:	00 
  80f8b3:	c7 44 24 08 43 42 81 	movl   $0x814243,0x8(%esp)
  80f8ba:	00 
  80f8bb:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80f8c2:	00 
  80f8c3:	c7 04 24 60 42 81 00 	movl   $0x814260,(%esp)
  80f8ca:	e8 b1 f5 ff ff       	call   80ee80 <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80f8cf:	83 c4 2c             	add    $0x2c,%esp
  80f8d2:	5b                   	pop    %ebx
  80f8d3:	5e                   	pop    %esi
  80f8d4:	5f                   	pop    %edi
  80f8d5:	5d                   	pop    %ebp
  80f8d6:	c3                   	ret    

0080f8d7 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80f8d7:	55                   	push   %ebp
  80f8d8:	89 e5                	mov    %esp,%ebp
  80f8da:	57                   	push   %edi
  80f8db:	56                   	push   %esi
  80f8dc:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f8dd:	ba 00 00 00 00       	mov    $0x0,%edx
  80f8e2:	b8 02 00 00 00       	mov    $0x2,%eax
  80f8e7:	89 d1                	mov    %edx,%ecx
  80f8e9:	89 d3                	mov    %edx,%ebx
  80f8eb:	89 d7                	mov    %edx,%edi
  80f8ed:	89 d6                	mov    %edx,%esi
  80f8ef:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80f8f1:	5b                   	pop    %ebx
  80f8f2:	5e                   	pop    %esi
  80f8f3:	5f                   	pop    %edi
  80f8f4:	5d                   	pop    %ebp
  80f8f5:	c3                   	ret    

0080f8f6 <sys_yield>:

void
sys_yield(void)
{
  80f8f6:	55                   	push   %ebp
  80f8f7:	89 e5                	mov    %esp,%ebp
  80f8f9:	57                   	push   %edi
  80f8fa:	56                   	push   %esi
  80f8fb:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f8fc:	ba 00 00 00 00       	mov    $0x0,%edx
  80f901:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f906:	89 d1                	mov    %edx,%ecx
  80f908:	89 d3                	mov    %edx,%ebx
  80f90a:	89 d7                	mov    %edx,%edi
  80f90c:	89 d6                	mov    %edx,%esi
  80f90e:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f910:	5b                   	pop    %ebx
  80f911:	5e                   	pop    %esi
  80f912:	5f                   	pop    %edi
  80f913:	5d                   	pop    %ebp
  80f914:	c3                   	ret    

0080f915 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f915:	55                   	push   %ebp
  80f916:	89 e5                	mov    %esp,%ebp
  80f918:	57                   	push   %edi
  80f919:	56                   	push   %esi
  80f91a:	53                   	push   %ebx
  80f91b:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f91e:	be 00 00 00 00       	mov    $0x0,%esi
  80f923:	b8 04 00 00 00       	mov    $0x4,%eax
  80f928:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f92b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f92e:	8b 55 08             	mov    0x8(%ebp),%edx
  80f931:	89 f7                	mov    %esi,%edi
  80f933:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80f935:	85 c0                	test   %eax,%eax
  80f937:	7e 28                	jle    80f961 <sys_page_alloc+0x4c>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f939:	89 44 24 10          	mov    %eax,0x10(%esp)
  80f93d:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  80f944:	00 
  80f945:	c7 44 24 08 43 42 81 	movl   $0x814243,0x8(%esp)
  80f94c:	00 
  80f94d:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80f954:	00 
  80f955:	c7 04 24 60 42 81 00 	movl   $0x814260,(%esp)
  80f95c:	e8 1f f5 ff ff       	call   80ee80 <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f961:	83 c4 2c             	add    $0x2c,%esp
  80f964:	5b                   	pop    %ebx
  80f965:	5e                   	pop    %esi
  80f966:	5f                   	pop    %edi
  80f967:	5d                   	pop    %ebp
  80f968:	c3                   	ret    

0080f969 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f969:	55                   	push   %ebp
  80f96a:	89 e5                	mov    %esp,%ebp
  80f96c:	57                   	push   %edi
  80f96d:	56                   	push   %esi
  80f96e:	53                   	push   %ebx
  80f96f:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f972:	b8 05 00 00 00       	mov    $0x5,%eax
  80f977:	8b 75 18             	mov    0x18(%ebp),%esi
  80f97a:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f97d:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f980:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f983:	8b 55 08             	mov    0x8(%ebp),%edx
  80f986:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80f988:	85 c0                	test   %eax,%eax
  80f98a:	7e 28                	jle    80f9b4 <sys_page_map+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f98c:	89 44 24 10          	mov    %eax,0x10(%esp)
  80f990:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  80f997:	00 
  80f998:	c7 44 24 08 43 42 81 	movl   $0x814243,0x8(%esp)
  80f99f:	00 
  80f9a0:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80f9a7:	00 
  80f9a8:	c7 04 24 60 42 81 00 	movl   $0x814260,(%esp)
  80f9af:	e8 cc f4 ff ff       	call   80ee80 <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f9b4:	83 c4 2c             	add    $0x2c,%esp
  80f9b7:	5b                   	pop    %ebx
  80f9b8:	5e                   	pop    %esi
  80f9b9:	5f                   	pop    %edi
  80f9ba:	5d                   	pop    %ebp
  80f9bb:	c3                   	ret    

0080f9bc <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f9bc:	55                   	push   %ebp
  80f9bd:	89 e5                	mov    %esp,%ebp
  80f9bf:	57                   	push   %edi
  80f9c0:	56                   	push   %esi
  80f9c1:	53                   	push   %ebx
  80f9c2:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f9c5:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f9ca:	b8 06 00 00 00       	mov    $0x6,%eax
  80f9cf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f9d2:	8b 55 08             	mov    0x8(%ebp),%edx
  80f9d5:	89 df                	mov    %ebx,%edi
  80f9d7:	89 de                	mov    %ebx,%esi
  80f9d9:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80f9db:	85 c0                	test   %eax,%eax
  80f9dd:	7e 28                	jle    80fa07 <sys_page_unmap+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f9df:	89 44 24 10          	mov    %eax,0x10(%esp)
  80f9e3:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80f9ea:	00 
  80f9eb:	c7 44 24 08 43 42 81 	movl   $0x814243,0x8(%esp)
  80f9f2:	00 
  80f9f3:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80f9fa:	00 
  80f9fb:	c7 04 24 60 42 81 00 	movl   $0x814260,(%esp)
  80fa02:	e8 79 f4 ff ff       	call   80ee80 <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80fa07:	83 c4 2c             	add    $0x2c,%esp
  80fa0a:	5b                   	pop    %ebx
  80fa0b:	5e                   	pop    %esi
  80fa0c:	5f                   	pop    %edi
  80fa0d:	5d                   	pop    %ebp
  80fa0e:	c3                   	ret    

0080fa0f <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80fa0f:	55                   	push   %ebp
  80fa10:	89 e5                	mov    %esp,%ebp
  80fa12:	57                   	push   %edi
  80fa13:	56                   	push   %esi
  80fa14:	53                   	push   %ebx
  80fa15:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fa18:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fa1d:	b8 08 00 00 00       	mov    $0x8,%eax
  80fa22:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fa25:	8b 55 08             	mov    0x8(%ebp),%edx
  80fa28:	89 df                	mov    %ebx,%edi
  80fa2a:	89 de                	mov    %ebx,%esi
  80fa2c:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fa2e:	85 c0                	test   %eax,%eax
  80fa30:	7e 28                	jle    80fa5a <sys_env_set_status+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fa32:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fa36:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
  80fa3d:	00 
  80fa3e:	c7 44 24 08 43 42 81 	movl   $0x814243,0x8(%esp)
  80fa45:	00 
  80fa46:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fa4d:	00 
  80fa4e:	c7 04 24 60 42 81 00 	movl   $0x814260,(%esp)
  80fa55:	e8 26 f4 ff ff       	call   80ee80 <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80fa5a:	83 c4 2c             	add    $0x2c,%esp
  80fa5d:	5b                   	pop    %ebx
  80fa5e:	5e                   	pop    %esi
  80fa5f:	5f                   	pop    %edi
  80fa60:	5d                   	pop    %ebp
  80fa61:	c3                   	ret    

0080fa62 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80fa62:	55                   	push   %ebp
  80fa63:	89 e5                	mov    %esp,%ebp
  80fa65:	57                   	push   %edi
  80fa66:	56                   	push   %esi
  80fa67:	53                   	push   %ebx
  80fa68:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fa6b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fa70:	b8 09 00 00 00       	mov    $0x9,%eax
  80fa75:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fa78:	8b 55 08             	mov    0x8(%ebp),%edx
  80fa7b:	89 df                	mov    %ebx,%edi
  80fa7d:	89 de                	mov    %ebx,%esi
  80fa7f:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fa81:	85 c0                	test   %eax,%eax
  80fa83:	7e 28                	jle    80faad <sys_env_set_trapframe+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fa85:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fa89:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  80fa90:	00 
  80fa91:	c7 44 24 08 43 42 81 	movl   $0x814243,0x8(%esp)
  80fa98:	00 
  80fa99:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80faa0:	00 
  80faa1:	c7 04 24 60 42 81 00 	movl   $0x814260,(%esp)
  80faa8:	e8 d3 f3 ff ff       	call   80ee80 <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80faad:	83 c4 2c             	add    $0x2c,%esp
  80fab0:	5b                   	pop    %ebx
  80fab1:	5e                   	pop    %esi
  80fab2:	5f                   	pop    %edi
  80fab3:	5d                   	pop    %ebp
  80fab4:	c3                   	ret    

0080fab5 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80fab5:	55                   	push   %ebp
  80fab6:	89 e5                	mov    %esp,%ebp
  80fab8:	57                   	push   %edi
  80fab9:	56                   	push   %esi
  80faba:	53                   	push   %ebx
  80fabb:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fabe:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fac3:	b8 0a 00 00 00       	mov    $0xa,%eax
  80fac8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80facb:	8b 55 08             	mov    0x8(%ebp),%edx
  80face:	89 df                	mov    %ebx,%edi
  80fad0:	89 de                	mov    %ebx,%esi
  80fad2:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fad4:	85 c0                	test   %eax,%eax
  80fad6:	7e 28                	jle    80fb00 <sys_env_set_pgfault_upcall+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fad8:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fadc:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  80fae3:	00 
  80fae4:	c7 44 24 08 43 42 81 	movl   $0x814243,0x8(%esp)
  80faeb:	00 
  80faec:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80faf3:	00 
  80faf4:	c7 04 24 60 42 81 00 	movl   $0x814260,(%esp)
  80fafb:	e8 80 f3 ff ff       	call   80ee80 <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80fb00:	83 c4 2c             	add    $0x2c,%esp
  80fb03:	5b                   	pop    %ebx
  80fb04:	5e                   	pop    %esi
  80fb05:	5f                   	pop    %edi
  80fb06:	5d                   	pop    %ebp
  80fb07:	c3                   	ret    

0080fb08 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80fb08:	55                   	push   %ebp
  80fb09:	89 e5                	mov    %esp,%ebp
  80fb0b:	57                   	push   %edi
  80fb0c:	56                   	push   %esi
  80fb0d:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb0e:	be 00 00 00 00       	mov    $0x0,%esi
  80fb13:	b8 0c 00 00 00       	mov    $0xc,%eax
  80fb18:	8b 7d 14             	mov    0x14(%ebp),%edi
  80fb1b:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fb1e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fb21:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb24:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80fb26:	5b                   	pop    %ebx
  80fb27:	5e                   	pop    %esi
  80fb28:	5f                   	pop    %edi
  80fb29:	5d                   	pop    %ebp
  80fb2a:	c3                   	ret    

0080fb2b <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80fb2b:	55                   	push   %ebp
  80fb2c:	89 e5                	mov    %esp,%ebp
  80fb2e:	57                   	push   %edi
  80fb2f:	56                   	push   %esi
  80fb30:	53                   	push   %ebx
  80fb31:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb34:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fb39:	b8 0d 00 00 00       	mov    $0xd,%eax
  80fb3e:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb41:	89 cb                	mov    %ecx,%ebx
  80fb43:	89 cf                	mov    %ecx,%edi
  80fb45:	89 ce                	mov    %ecx,%esi
  80fb47:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fb49:	85 c0                	test   %eax,%eax
  80fb4b:	7e 28                	jle    80fb75 <sys_ipc_recv+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fb4d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fb51:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
  80fb58:	00 
  80fb59:	c7 44 24 08 43 42 81 	movl   $0x814243,0x8(%esp)
  80fb60:	00 
  80fb61:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fb68:	00 
  80fb69:	c7 04 24 60 42 81 00 	movl   $0x814260,(%esp)
  80fb70:	e8 0b f3 ff ff       	call   80ee80 <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80fb75:	83 c4 2c             	add    $0x2c,%esp
  80fb78:	5b                   	pop    %ebx
  80fb79:	5e                   	pop    %esi
  80fb7a:	5f                   	pop    %edi
  80fb7b:	5d                   	pop    %ebp
  80fb7c:	c3                   	ret    

0080fb7d <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80fb7d:	55                   	push   %ebp
  80fb7e:	89 e5                	mov    %esp,%ebp
  80fb80:	57                   	push   %edi
  80fb81:	56                   	push   %esi
  80fb82:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb83:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb88:	b8 0e 00 00 00       	mov    $0xe,%eax
  80fb8d:	89 d1                	mov    %edx,%ecx
  80fb8f:	89 d3                	mov    %edx,%ebx
  80fb91:	89 d7                	mov    %edx,%edi
  80fb93:	89 d6                	mov    %edx,%esi
  80fb95:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80fb97:	5b                   	pop    %ebx
  80fb98:	5e                   	pop    %esi
  80fb99:	5f                   	pop    %edi
  80fb9a:	5d                   	pop    %ebp
  80fb9b:	c3                   	ret    

0080fb9c <sys_e1000_transmit>:

int 
sys_e1000_transmit(char *packet, uint32_t len)
{
  80fb9c:	55                   	push   %ebp
  80fb9d:	89 e5                	mov    %esp,%ebp
  80fb9f:	57                   	push   %edi
  80fba0:	56                   	push   %esi
  80fba1:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fba2:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fba7:	b8 0f 00 00 00       	mov    $0xf,%eax
  80fbac:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fbaf:	8b 55 08             	mov    0x8(%ebp),%edx
  80fbb2:	89 df                	mov    %ebx,%edi
  80fbb4:	89 de                	mov    %ebx,%esi
  80fbb6:	cd 30                	int    $0x30

int 
sys_e1000_transmit(char *packet, uint32_t len)
{
	return syscall(SYS_e1000_transmit, 0, (uint32_t)packet, (uint32_t)len, 0, 0, 0);
}
  80fbb8:	5b                   	pop    %ebx
  80fbb9:	5e                   	pop    %esi
  80fbba:	5f                   	pop    %edi
  80fbbb:	5d                   	pop    %ebp
  80fbbc:	c3                   	ret    

0080fbbd <sys_e1000_receive>:

int 
sys_e1000_receive(char *packet, uint32_t *len)
{
  80fbbd:	55                   	push   %ebp
  80fbbe:	89 e5                	mov    %esp,%ebp
  80fbc0:	57                   	push   %edi
  80fbc1:	56                   	push   %esi
  80fbc2:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fbc3:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fbc8:	b8 10 00 00 00       	mov    $0x10,%eax
  80fbcd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fbd0:	8b 55 08             	mov    0x8(%ebp),%edx
  80fbd3:	89 df                	mov    %ebx,%edi
  80fbd5:	89 de                	mov    %ebx,%esi
  80fbd7:	cd 30                	int    $0x30

int 
sys_e1000_receive(char *packet, uint32_t *len)
{
	return syscall(SYS_e1000_receive, 0, (uint32_t)packet, (uint32_t)len, 0, 0, 0);
}
  80fbd9:	5b                   	pop    %ebx
  80fbda:	5e                   	pop    %esi
  80fbdb:	5f                   	pop    %edi
  80fbdc:	5d                   	pop    %ebp
  80fbdd:	c3                   	ret    
	...

0080fbe0 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80fbe0:	55                   	push   %ebp
  80fbe1:	89 e5                	mov    %esp,%ebp
  80fbe3:	53                   	push   %ebx
  80fbe4:	83 ec 24             	sub    $0x24,%esp
  80fbe7:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80fbea:	8b 18                	mov    (%eax),%ebx
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	if (!(err & FEC_WR) || !(uvpd[PDX(addr)] & PTE_P) || !(uvpt[PGNUM(addr)] & PTE_P) || !(uvpt[PGNUM(addr)] & PTE_COW))
  80fbec:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80fbf0:	74 2d                	je     80fc1f <pgfault+0x3f>
  80fbf2:	89 d8                	mov    %ebx,%eax
  80fbf4:	c1 e8 16             	shr    $0x16,%eax
  80fbf7:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fbfe:	a8 01                	test   $0x1,%al
  80fc00:	74 1d                	je     80fc1f <pgfault+0x3f>
  80fc02:	89 d8                	mov    %ebx,%eax
  80fc04:	c1 e8 0c             	shr    $0xc,%eax
  80fc07:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fc0e:	f6 c2 01             	test   $0x1,%dl
  80fc11:	74 0c                	je     80fc1f <pgfault+0x3f>
  80fc13:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fc1a:	f6 c4 08             	test   $0x8,%ah
  80fc1d:	75 1c                	jne    80fc3b <pgfault+0x5b>
	{
		panic("pgfault error, not copy on write\n");
  80fc1f:	c7 44 24 08 70 42 81 	movl   $0x814270,0x8(%esp)
  80fc26:	00 
  80fc27:	c7 44 24 04 1e 00 00 	movl   $0x1e,0x4(%esp)
  80fc2e:	00 
  80fc2f:	c7 04 24 b3 42 81 00 	movl   $0x8142b3,(%esp)
  80fc36:	e8 45 f2 ff ff       	call   80ee80 <_panic>
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.

	// LAB 4: Your code here.
	void *va = (void *)ROUNDDOWN(addr, PGSIZE);
  80fc3b:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	sys_page_alloc(0, (void *)PFTEMP, PTE_W | PTE_U | PTE_P);
  80fc41:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80fc48:	00 
  80fc49:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80fc50:	00 
  80fc51:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fc58:	e8 b8 fc ff ff       	call   80f915 <sys_page_alloc>
	memcpy((void *)PFTEMP, va, PGSIZE);
  80fc5d:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  80fc64:	00 
  80fc65:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80fc69:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  80fc70:	e8 91 fa ff ff       	call   80f706 <memcpy>
	sys_page_map(0, (void *)PFTEMP, 0, va, PTE_W | PTE_P | PTE_U);
  80fc75:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  80fc7c:	00 
  80fc7d:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80fc81:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80fc88:	00 
  80fc89:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80fc90:	00 
  80fc91:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fc98:	e8 cc fc ff ff       	call   80f969 <sys_page_map>
	sys_page_unmap(0, (void *)PFTEMP);
  80fc9d:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80fca4:	00 
  80fca5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fcac:	e8 0b fd ff ff       	call   80f9bc <sys_page_unmap>

	// panic("pgfault not implemented");
}
  80fcb1:	83 c4 24             	add    $0x24,%esp
  80fcb4:	5b                   	pop    %ebx
  80fcb5:	5d                   	pop    %ebp
  80fcb6:	c3                   	ret    

0080fcb7 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80fcb7:	55                   	push   %ebp
  80fcb8:	89 e5                	mov    %esp,%ebp
  80fcba:	57                   	push   %edi
  80fcbb:	56                   	push   %esi
  80fcbc:	53                   	push   %ebx
  80fcbd:	83 ec 3c             	sub    $0x3c,%esp
	// LAB 4: Your code here.
	set_pgfault_handler(pgfault);
  80fcc0:	c7 04 24 e0 fb 80 00 	movl   $0x80fbe0,(%esp)
  80fcc7:	e8 28 19 00 00       	call   8115f4 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80fccc:	ba 07 00 00 00       	mov    $0x7,%edx
  80fcd1:	89 d0                	mov    %edx,%eax
  80fcd3:	cd 30                	int    $0x30
  80fcd5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80fcd8:	89 c7                	mov    %eax,%edi
	// The kernel will initialize it with a copy of our register state,
	// so that the child will appear to have called sys_exofork() too -
	// except that in the child, this "fake" call to sys_exofork()
	// will return 0 instead of the envid of the child.
	envid = sys_exofork();
	if (envid < 0)
  80fcda:	85 c0                	test   %eax,%eax
  80fcdc:	79 20                	jns    80fcfe <fork+0x47>
		panic("sys_exofork: %e", envid);
  80fcde:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fce2:	c7 44 24 08 be 42 81 	movl   $0x8142be,0x8(%esp)
  80fce9:	00 
  80fcea:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80fcf1:	00 
  80fcf2:	c7 04 24 b3 42 81 00 	movl   $0x8142b3,(%esp)
  80fcf9:	e8 82 f1 ff ff       	call   80ee80 <_panic>
	if (envid == 0)
  80fcfe:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80fd02:	75 25                	jne    80fd29 <fork+0x72>
	{
		// We're the child.
		// The copied value of the global variable 'thisenv'
		// is no longer valid (it refers to the parent!).
		// Fix it and return 0.
		thisenv = &envs[ENVX(sys_getenvid())];
  80fd04:	e8 ce fb ff ff       	call   80f8d7 <sys_getenvid>
  80fd09:	25 ff 03 00 00       	and    $0x3ff,%eax
  80fd0e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80fd15:	c1 e0 07             	shl    $0x7,%eax
  80fd18:	29 d0                	sub    %edx,%eax
  80fd1a:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80fd1f:	a3 9c c2 b3 00       	mov    %eax,0xb3c29c
		return 0;
  80fd24:	e9 43 02 00 00       	jmp    80ff6c <fork+0x2b5>
	// except that in the child, this "fake" call to sys_exofork()
	// will return 0 instead of the envid of the child.
	envid = sys_exofork();
	if (envid < 0)
		panic("sys_exofork: %e", envid);
	if (envid == 0)
  80fd29:	bb 00 00 00 00       	mov    $0x0,%ebx
	// Eagerly copy our entire address space into the child.
	// This is NOT what you should do in your fork implementation.
	for (uint32_t pn = 0; pn < UTOP / PGSIZE; ++pn)
	{
		addr = (uint8_t *)(pn * PGSIZE);
		if (((uintptr_t)addr == UXSTACKTOP - PGSIZE) || !(uvpd[PDX(addr)] & PTE_P) || !(uvpt[PGNUM(addr)] & PTE_P))
  80fd2e:	81 fb 00 f0 bf ee    	cmp    $0xeebff000,%ebx
  80fd34:	0f 84 85 01 00 00    	je     80febf <fork+0x208>
  80fd3a:	89 d8                	mov    %ebx,%eax
  80fd3c:	c1 e8 16             	shr    $0x16,%eax
  80fd3f:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fd46:	a8 01                	test   $0x1,%al
  80fd48:	0f 84 5f 01 00 00    	je     80fead <fork+0x1f6>
  80fd4e:	89 d8                	mov    %ebx,%eax
  80fd50:	c1 e8 0c             	shr    $0xc,%eax
  80fd53:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fd5a:	f6 c2 01             	test   $0x1,%dl
  80fd5d:	0f 84 4a 01 00 00    	je     80fead <fork+0x1f6>
	// We're the parent.
	// Eagerly copy our entire address space into the child.
	// This is NOT what you should do in your fork implementation.
	for (uint32_t pn = 0; pn < UTOP / PGSIZE; ++pn)
	{
		addr = (uint8_t *)(pn * PGSIZE);
  80fd63:	89 de                	mov    %ebx,%esi

	// LAB 4: Your code here.
	r = pn * PGSIZE;
	// int perm = uvpt[PGNUM(r)] & PTE_SYSCALL & ~PTE_W;
	int perm = PTE_U | PTE_P;
	if ((uvpt[PGNUM(r)] & PTE_SHARE))
  80fd65:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fd6c:	f6 c6 04             	test   $0x4,%dh
  80fd6f:	74 50                	je     80fdc1 <fork+0x10a>
	{
		if ((e = sys_page_map(0, (void *)r, envid, (void *)r, uvpt[PGNUM(r)] & PTE_SYSCALL)) < 0)
  80fd71:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fd78:	25 07 0e 00 00       	and    $0xe07,%eax
  80fd7d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fd81:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80fd85:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80fd89:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80fd8d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fd94:	e8 d0 fb ff ff       	call   80f969 <sys_page_map>
  80fd99:	85 c0                	test   %eax,%eax
  80fd9b:	0f 89 0c 01 00 00    	jns    80fead <fork+0x1f6>
		{
			panic("duppage error: %e", e);
  80fda1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fda5:	c7 44 24 08 ce 42 81 	movl   $0x8142ce,0x8(%esp)
  80fdac:	00 
  80fdad:	c7 44 24 04 4a 00 00 	movl   $0x4a,0x4(%esp)
  80fdb4:	00 
  80fdb5:	c7 04 24 b3 42 81 00 	movl   $0x8142b3,(%esp)
  80fdbc:	e8 bf f0 ff ff       	call   80ee80 <_panic>
		}
		return 0;
	}
	if ((uvpt[PGNUM(r)] & PTE_W) || (uvpt[PGNUM(r)] & PTE_COW))
  80fdc1:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fdc8:	f6 c2 02             	test   $0x2,%dl
  80fdcb:	75 10                	jne    80fddd <fork+0x126>
  80fdcd:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fdd4:	f6 c4 08             	test   $0x8,%ah
  80fdd7:	0f 84 8c 00 00 00    	je     80fe69 <fork+0x1b2>
	{
		if ((e = sys_page_map(0, (void *)r, envid, (void *)r, perm | PTE_COW)) < 0)
  80fddd:	c7 44 24 10 05 08 00 	movl   $0x805,0x10(%esp)
  80fde4:	00 
  80fde5:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80fde9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80fded:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fdf1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fdf8:	e8 6c fb ff ff       	call   80f969 <sys_page_map>
  80fdfd:	85 c0                	test   %eax,%eax
  80fdff:	79 20                	jns    80fe21 <fork+0x16a>
		{
			panic("duppage error: %e",e);
  80fe01:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fe05:	c7 44 24 08 ce 42 81 	movl   $0x8142ce,0x8(%esp)
  80fe0c:	00 
  80fe0d:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80fe14:	00 
  80fe15:	c7 04 24 b3 42 81 00 	movl   $0x8142b3,(%esp)
  80fe1c:	e8 5f f0 ff ff       	call   80ee80 <_panic>
		}
		if ((e = sys_page_map(0, (void *)r, 0, (void *)r, perm | PTE_COW)) < 0)
  80fe21:	c7 44 24 10 05 08 00 	movl   $0x805,0x10(%esp)
  80fe28:	00 
  80fe29:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80fe2d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80fe34:	00 
  80fe35:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fe39:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fe40:	e8 24 fb ff ff       	call   80f969 <sys_page_map>
  80fe45:	85 c0                	test   %eax,%eax
  80fe47:	79 64                	jns    80fead <fork+0x1f6>
		{
			panic("duppage error: %e",e);
  80fe49:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fe4d:	c7 44 24 08 ce 42 81 	movl   $0x8142ce,0x8(%esp)
  80fe54:	00 
  80fe55:	c7 44 24 04 56 00 00 	movl   $0x56,0x4(%esp)
  80fe5c:	00 
  80fe5d:	c7 04 24 b3 42 81 00 	movl   $0x8142b3,(%esp)
  80fe64:	e8 17 f0 ff ff       	call   80ee80 <_panic>
		}
	}
	else
	{
		if ((e = sys_page_map(0, (void *)r, envid, (void *)r, perm)) < 0)
  80fe69:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)
  80fe70:	00 
  80fe71:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80fe75:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80fe79:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80fe7d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fe84:	e8 e0 fa ff ff       	call   80f969 <sys_page_map>
  80fe89:	85 c0                	test   %eax,%eax
  80fe8b:	79 20                	jns    80fead <fork+0x1f6>
		{
			panic("duppage error: %e",e);
  80fe8d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fe91:	c7 44 24 08 ce 42 81 	movl   $0x8142ce,0x8(%esp)
  80fe98:	00 
  80fe99:	c7 44 24 04 5d 00 00 	movl   $0x5d,0x4(%esp)
  80fea0:	00 
  80fea1:	c7 04 24 b3 42 81 00 	movl   $0x8142b3,(%esp)
  80fea8:	e8 d3 ef ff ff       	call   80ee80 <_panic>
  80fead:	81 c3 00 10 00 00    	add    $0x1000,%ebx
	}

	// We're the parent.
	// Eagerly copy our entire address space into the child.
	// This is NOT what you should do in your fork implementation.
	for (uint32_t pn = 0; pn < UTOP / PGSIZE; ++pn)
  80feb3:	81 fb 00 00 c0 ee    	cmp    $0xeec00000,%ebx
  80feb9:	0f 85 6f fe ff ff    	jne    80fd2e <fork+0x77>
			continue;
		}
		duppage(envid, pn);
	}

	if ((r = sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE), PTE_W | PTE_U | PTE_P)) < 0)
  80febf:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80fec6:	00 
  80fec7:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  80fece:	ee 
  80fecf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80fed2:	89 04 24             	mov    %eax,(%esp)
  80fed5:	e8 3b fa ff ff       	call   80f915 <sys_page_alloc>
  80feda:	85 c0                	test   %eax,%eax
  80fedc:	79 20                	jns    80fefe <fork+0x247>
	{
		panic("sys_page_alloc: %e", r);
  80fede:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fee2:	c7 44 24 08 78 1b 81 	movl   $0x811b78,0x8(%esp)
  80fee9:	00 
  80feea:	c7 44 24 04 9e 00 00 	movl   $0x9e,0x4(%esp)
  80fef1:	00 
  80fef2:	c7 04 24 b3 42 81 00 	movl   $0x8142b3,(%esp)
  80fef9:	e8 82 ef ff ff       	call   80ee80 <_panic>
	}
	extern void _pgfault_upcall(void);
	if ((r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall)) < 0)
  80fefe:	c7 44 24 04 40 16 81 	movl   $0x811640,0x4(%esp)
  80ff05:	00 
  80ff06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ff09:	89 04 24             	mov    %eax,(%esp)
  80ff0c:	e8 a4 fb ff ff       	call   80fab5 <sys_env_set_pgfault_upcall>
  80ff11:	85 c0                	test   %eax,%eax
  80ff13:	79 20                	jns    80ff35 <fork+0x27e>
	{
		panic("sys_env_set_pgfault_upcall: %e", r);
  80ff15:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ff19:	c7 44 24 08 94 42 81 	movl   $0x814294,0x8(%esp)
  80ff20:	00 
  80ff21:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  80ff28:	00 
  80ff29:	c7 04 24 b3 42 81 00 	movl   $0x8142b3,(%esp)
  80ff30:	e8 4b ef ff ff       	call   80ee80 <_panic>
	}
	// Start the child environment running
	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  80ff35:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80ff3c:	00 
  80ff3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ff40:	89 04 24             	mov    %eax,(%esp)
  80ff43:	e8 c7 fa ff ff       	call   80fa0f <sys_env_set_status>
  80ff48:	85 c0                	test   %eax,%eax
  80ff4a:	79 20                	jns    80ff6c <fork+0x2b5>
		panic("sys_env_set_status: %e", r);
  80ff4c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ff50:	c7 44 24 08 e0 42 81 	movl   $0x8142e0,0x8(%esp)
  80ff57:	00 
  80ff58:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  80ff5f:	00 
  80ff60:	c7 04 24 b3 42 81 00 	movl   $0x8142b3,(%esp)
  80ff67:	e8 14 ef ff ff       	call   80ee80 <_panic>

	return envid;
	// panic("fork not implemented");
}
  80ff6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ff6f:	83 c4 3c             	add    $0x3c,%esp
  80ff72:	5b                   	pop    %ebx
  80ff73:	5e                   	pop    %esi
  80ff74:	5f                   	pop    %edi
  80ff75:	5d                   	pop    %ebp
  80ff76:	c3                   	ret    

0080ff77 <sfork>:

// Challenge!
int
sfork(void)
{
  80ff77:	55                   	push   %ebp
  80ff78:	89 e5                	mov    %esp,%ebp
  80ff7a:	83 ec 18             	sub    $0x18,%esp
	panic("sfork not implemented");
  80ff7d:	c7 44 24 08 f7 42 81 	movl   $0x8142f7,0x8(%esp)
  80ff84:	00 
  80ff85:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  80ff8c:	00 
  80ff8d:	c7 04 24 b3 42 81 00 	movl   $0x8142b3,(%esp)
  80ff94:	e8 e7 ee ff ff       	call   80ee80 <_panic>
  80ff99:	00 00                	add    %al,(%eax)
	...

0080ff9c <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80ff9c:	55                   	push   %ebp
  80ff9d:	89 e5                	mov    %esp,%ebp
  80ff9f:	56                   	push   %esi
  80ffa0:	53                   	push   %ebx
  80ffa1:	83 ec 10             	sub    $0x10,%esp
  80ffa4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ffa7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ffaa:	8b 75 10             	mov    0x10(%ebp),%esi
	// LAB 4: Your code here.
	int r;
	if (pg)
  80ffad:	85 c0                	test   %eax,%eax
  80ffaf:	74 0a                	je     80ffbb <ipc_recv+0x1f>
	{
		r = sys_ipc_recv(pg);
  80ffb1:	89 04 24             	mov    %eax,(%esp)
  80ffb4:	e8 72 fb ff ff       	call   80fb2b <sys_ipc_recv>
  80ffb9:	eb 0c                	jmp    80ffc7 <ipc_recv+0x2b>
	}
	else
	{
		r = sys_ipc_recv((void *)UTOP);
  80ffbb:	c7 04 24 00 00 c0 ee 	movl   $0xeec00000,(%esp)
  80ffc2:	e8 64 fb ff ff       	call   80fb2b <sys_ipc_recv>
	}
	if (r < 0)
  80ffc7:	85 c0                	test   %eax,%eax
  80ffc9:	79 16                	jns    80ffe1 <ipc_recv+0x45>
	{
		if(from_env_store) *from_env_store = 0;
  80ffcb:	85 db                	test   %ebx,%ebx
  80ffcd:	74 06                	je     80ffd5 <ipc_recv+0x39>
  80ffcf:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		if(perm_store) *perm_store = 0;
  80ffd5:	85 f6                	test   %esi,%esi
  80ffd7:	74 2c                	je     810005 <ipc_recv+0x69>
  80ffd9:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  80ffdf:	eb 24                	jmp    810005 <ipc_recv+0x69>
		return r;
	}
	if (from_env_store)
  80ffe1:	85 db                	test   %ebx,%ebx
  80ffe3:	74 0a                	je     80ffef <ipc_recv+0x53>
	{
		*from_env_store = thisenv->env_ipc_from;
  80ffe5:	a1 9c c2 b3 00       	mov    0xb3c29c,%eax
  80ffea:	8b 40 74             	mov    0x74(%eax),%eax
  80ffed:	89 03                	mov    %eax,(%ebx)
	}
	if (perm_store)
  80ffef:	85 f6                	test   %esi,%esi
  80fff1:	74 0a                	je     80fffd <ipc_recv+0x61>
	{
		*perm_store = thisenv->env_ipc_perm;
  80fff3:	a1 9c c2 b3 00       	mov    0xb3c29c,%eax
  80fff8:	8b 40 78             	mov    0x78(%eax),%eax
  80fffb:	89 06                	mov    %eax,(%esi)
	}
	return thisenv->env_ipc_value;
  80fffd:	a1 9c c2 b3 00       	mov    0xb3c29c,%eax
  810002:	8b 40 70             	mov    0x70(%eax),%eax
	//panic("ipc_recv not implemented");
	//return 0;
}
  810005:	83 c4 10             	add    $0x10,%esp
  810008:	5b                   	pop    %ebx
  810009:	5e                   	pop    %esi
  81000a:	5d                   	pop    %ebp
  81000b:	c3                   	ret    

0081000c <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  81000c:	55                   	push   %ebp
  81000d:	89 e5                	mov    %esp,%ebp
  81000f:	57                   	push   %edi
  810010:	56                   	push   %esi
  810011:	53                   	push   %ebx
  810012:	83 ec 1c             	sub    $0x1c,%esp
  810015:	8b 75 08             	mov    0x8(%ebp),%esi
  810018:	8b 7d 0c             	mov    0xc(%ebp),%edi
  81001b:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	int r;
	while (1)
	{
		if (pg)
  81001e:	85 db                	test   %ebx,%ebx
  810020:	74 19                	je     81003b <ipc_send+0x2f>
		{
			r = sys_ipc_try_send(to_env, val, pg, perm);
  810022:	8b 45 14             	mov    0x14(%ebp),%eax
  810025:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810029:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81002d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  810031:	89 34 24             	mov    %esi,(%esp)
  810034:	e8 cf fa ff ff       	call   80fb08 <sys_ipc_try_send>
  810039:	eb 1c                	jmp    810057 <ipc_send+0x4b>
		}
		else
		{
			r = sys_ipc_try_send(to_env, val, (void *)UTOP, 0);
  81003b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  810042:	00 
  810043:	c7 44 24 08 00 00 c0 	movl   $0xeec00000,0x8(%esp)
  81004a:	ee 
  81004b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  81004f:	89 34 24             	mov    %esi,(%esp)
  810052:	e8 b1 fa ff ff       	call   80fb08 <sys_ipc_try_send>
		}
		if (r == 0)
  810057:	85 c0                	test   %eax,%eax
  810059:	74 2c                	je     810087 <ipc_send+0x7b>
		{
			break;
		}
		if (r != -E_IPC_NOT_RECV)
  81005b:	83 f8 f9             	cmp    $0xfffffff9,%eax
  81005e:	74 20                	je     810080 <ipc_send+0x74>
		{
			panic("ipc send error: %e", r);
  810060:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810064:	c7 44 24 08 0d 43 81 	movl   $0x81430d,0x8(%esp)
  81006b:	00 
  81006c:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  810073:	00 
  810074:	c7 04 24 20 43 81 00 	movl   $0x814320,(%esp)
  81007b:	e8 00 ee ff ff       	call   80ee80 <_panic>
		}
		sys_yield();
  810080:	e8 71 f8 ff ff       	call   80f8f6 <sys_yield>
	}
  810085:	eb 97                	jmp    81001e <ipc_send+0x12>
	//panic("ipc_send not implemented");
}
  810087:	83 c4 1c             	add    $0x1c,%esp
  81008a:	5b                   	pop    %ebx
  81008b:	5e                   	pop    %esi
  81008c:	5f                   	pop    %edi
  81008d:	5d                   	pop    %ebp
  81008e:	c3                   	ret    

0081008f <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  81008f:	55                   	push   %ebp
  810090:	89 e5                	mov    %esp,%ebp
  810092:	53                   	push   %ebx
  810093:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int i;
	for (i = 0; i < NENV; i++)
  810096:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  81009b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  8100a2:	89 c2                	mov    %eax,%edx
  8100a4:	c1 e2 07             	shl    $0x7,%edx
  8100a7:	29 ca                	sub    %ecx,%edx
  8100a9:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  8100af:	8b 52 50             	mov    0x50(%edx),%edx
  8100b2:	39 da                	cmp    %ebx,%edx
  8100b4:	75 0f                	jne    8100c5 <ipc_find_env+0x36>
			return envs[i].env_id;
  8100b6:	c1 e0 07             	shl    $0x7,%eax
  8100b9:	29 c8                	sub    %ecx,%eax
  8100bb:	05 08 00 c0 ee       	add    $0xeec00008,%eax
  8100c0:	8b 40 40             	mov    0x40(%eax),%eax
  8100c3:	eb 0c                	jmp    8100d1 <ipc_find_env+0x42>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  8100c5:	40                   	inc    %eax
  8100c6:	3d 00 04 00 00       	cmp    $0x400,%eax
  8100cb:	75 ce                	jne    81009b <ipc_find_env+0xc>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  8100cd:	66 b8 00 00          	mov    $0x0,%ax
}
  8100d1:	5b                   	pop    %ebx
  8100d2:	5d                   	pop    %ebp
  8100d3:	c3                   	ret    

008100d4 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  8100d4:	55                   	push   %ebp
  8100d5:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  8100d7:	8b 45 08             	mov    0x8(%ebp),%eax
  8100da:	05 00 00 00 30       	add    $0x30000000,%eax
  8100df:	c1 e8 0c             	shr    $0xc,%eax
}
  8100e2:	5d                   	pop    %ebp
  8100e3:	c3                   	ret    

008100e4 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  8100e4:	55                   	push   %ebp
  8100e5:	89 e5                	mov    %esp,%ebp
  8100e7:	83 ec 04             	sub    $0x4,%esp
	return INDEX2DATA(fd2num(fd));
  8100ea:	8b 45 08             	mov    0x8(%ebp),%eax
  8100ed:	89 04 24             	mov    %eax,(%esp)
  8100f0:	e8 df ff ff ff       	call   8100d4 <fd2num>
  8100f5:	c1 e0 0c             	shl    $0xc,%eax
  8100f8:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  8100fd:	c9                   	leave  
  8100fe:	c3                   	ret    

008100ff <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  8100ff:	55                   	push   %ebp
  810100:	89 e5                	mov    %esp,%ebp
  810102:	53                   	push   %ebx
  810103:	8b 5d 08             	mov    0x8(%ebp),%ebx
  810106:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
  81010b:	89 c1                	mov    %eax,%ecx
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  81010d:	89 c2                	mov    %eax,%edx
  81010f:	c1 ea 16             	shr    $0x16,%edx
  810112:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  810119:	f6 c2 01             	test   $0x1,%dl
  81011c:	74 11                	je     81012f <fd_alloc+0x30>
  81011e:	89 c2                	mov    %eax,%edx
  810120:	c1 ea 0c             	shr    $0xc,%edx
  810123:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  81012a:	f6 c2 01             	test   $0x1,%dl
  81012d:	75 09                	jne    810138 <fd_alloc+0x39>
			*fd_store = fd;
  81012f:	89 0b                	mov    %ecx,(%ebx)
			return 0;
  810131:	b8 00 00 00 00       	mov    $0x0,%eax
  810136:	eb 17                	jmp    81014f <fd_alloc+0x50>
  810138:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  81013d:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  810142:	75 c7                	jne    81010b <fd_alloc+0xc>
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  810144:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	return -E_MAX_OPEN;
  81014a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  81014f:	5b                   	pop    %ebx
  810150:	5d                   	pop    %ebp
  810151:	c3                   	ret    

00810152 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  810152:	55                   	push   %ebp
  810153:	89 e5                	mov    %esp,%ebp
  810155:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  810158:	83 f8 1f             	cmp    $0x1f,%eax
  81015b:	77 36                	ja     810193 <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  81015d:	c1 e0 0c             	shl    $0xc,%eax
  810160:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  810165:	89 c2                	mov    %eax,%edx
  810167:	c1 ea 16             	shr    $0x16,%edx
  81016a:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  810171:	f6 c2 01             	test   $0x1,%dl
  810174:	74 24                	je     81019a <fd_lookup+0x48>
  810176:	89 c2                	mov    %eax,%edx
  810178:	c1 ea 0c             	shr    $0xc,%edx
  81017b:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  810182:	f6 c2 01             	test   $0x1,%dl
  810185:	74 1a                	je     8101a1 <fd_lookup+0x4f>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  810187:	8b 55 0c             	mov    0xc(%ebp),%edx
  81018a:	89 02                	mov    %eax,(%edx)
	return 0;
  81018c:	b8 00 00 00 00       	mov    $0x0,%eax
  810191:	eb 13                	jmp    8101a6 <fd_lookup+0x54>
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  810193:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810198:	eb 0c                	jmp    8101a6 <fd_lookup+0x54>
	}
	fd = INDEX2FD(fdnum);
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  81019a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  81019f:	eb 05                	jmp    8101a6 <fd_lookup+0x54>
  8101a1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	}
	*fd_store = fd;
	return 0;
}
  8101a6:	5d                   	pop    %ebp
  8101a7:	c3                   	ret    

008101a8 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  8101a8:	55                   	push   %ebp
  8101a9:	89 e5                	mov    %esp,%ebp
  8101ab:	53                   	push   %ebx
  8101ac:	83 ec 14             	sub    $0x14,%esp
  8101af:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8101b2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int i;
	for (i = 0; devtab[i]; i++)
  8101b5:	ba 00 00 00 00       	mov    $0x0,%edx
  8101ba:	eb 0e                	jmp    8101ca <dev_lookup+0x22>
		if (devtab[i]->dev_id == dev_id) {
  8101bc:	39 08                	cmp    %ecx,(%eax)
  8101be:	75 09                	jne    8101c9 <dev_lookup+0x21>
			*dev = devtab[i];
  8101c0:	89 03                	mov    %eax,(%ebx)
			return 0;
  8101c2:	b8 00 00 00 00       	mov    $0x0,%eax
  8101c7:	eb 33                	jmp    8101fc <dev_lookup+0x54>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8101c9:	42                   	inc    %edx
  8101ca:	8b 04 95 a8 43 81 00 	mov    0x8143a8(,%edx,4),%eax
  8101d1:	85 c0                	test   %eax,%eax
  8101d3:	75 e7                	jne    8101bc <dev_lookup+0x14>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8101d5:	a1 9c c2 b3 00       	mov    0xb3c29c,%eax
  8101da:	8b 40 48             	mov    0x48(%eax),%eax
  8101dd:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8101e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8101e5:	c7 04 24 2c 43 81 00 	movl   $0x81432c,(%esp)
  8101ec:	e8 87 ed ff ff       	call   80ef78 <cprintf>
	*dev = 0;
  8101f1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	return -E_INVAL;
  8101f7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  8101fc:	83 c4 14             	add    $0x14,%esp
  8101ff:	5b                   	pop    %ebx
  810200:	5d                   	pop    %ebp
  810201:	c3                   	ret    

00810202 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  810202:	55                   	push   %ebp
  810203:	89 e5                	mov    %esp,%ebp
  810205:	56                   	push   %esi
  810206:	53                   	push   %ebx
  810207:	83 ec 30             	sub    $0x30,%esp
  81020a:	8b 75 08             	mov    0x8(%ebp),%esi
  81020d:	8a 45 0c             	mov    0xc(%ebp),%al
  810210:	88 45 e7             	mov    %al,-0x19(%ebp)
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  810213:	89 34 24             	mov    %esi,(%esp)
  810216:	e8 b9 fe ff ff       	call   8100d4 <fd2num>
  81021b:	8d 55 f4             	lea    -0xc(%ebp),%edx
  81021e:	89 54 24 04          	mov    %edx,0x4(%esp)
  810222:	89 04 24             	mov    %eax,(%esp)
  810225:	e8 28 ff ff ff       	call   810152 <fd_lookup>
  81022a:	89 c3                	mov    %eax,%ebx
  81022c:	85 c0                	test   %eax,%eax
  81022e:	78 05                	js     810235 <fd_close+0x33>
	    || fd != fd2)
  810230:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  810233:	74 0d                	je     810242 <fd_close+0x40>
		return (must_exist ? r : 0);
  810235:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  810239:	75 46                	jne    810281 <fd_close+0x7f>
  81023b:	bb 00 00 00 00       	mov    $0x0,%ebx
  810240:	eb 3f                	jmp    810281 <fd_close+0x7f>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  810242:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810245:	89 44 24 04          	mov    %eax,0x4(%esp)
  810249:	8b 06                	mov    (%esi),%eax
  81024b:	89 04 24             	mov    %eax,(%esp)
  81024e:	e8 55 ff ff ff       	call   8101a8 <dev_lookup>
  810253:	89 c3                	mov    %eax,%ebx
  810255:	85 c0                	test   %eax,%eax
  810257:	78 18                	js     810271 <fd_close+0x6f>
		if (dev->dev_close)
  810259:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81025c:	8b 40 10             	mov    0x10(%eax),%eax
  81025f:	85 c0                	test   %eax,%eax
  810261:	74 09                	je     81026c <fd_close+0x6a>
			r = (*dev->dev_close)(fd);
  810263:	89 34 24             	mov    %esi,(%esp)
  810266:	ff d0                	call   *%eax
  810268:	89 c3                	mov    %eax,%ebx
  81026a:	eb 05                	jmp    810271 <fd_close+0x6f>
		else
			r = 0;
  81026c:	bb 00 00 00 00       	mov    $0x0,%ebx
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  810271:	89 74 24 04          	mov    %esi,0x4(%esp)
  810275:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81027c:	e8 3b f7 ff ff       	call   80f9bc <sys_page_unmap>
	return r;
}
  810281:	89 d8                	mov    %ebx,%eax
  810283:	83 c4 30             	add    $0x30,%esp
  810286:	5b                   	pop    %ebx
  810287:	5e                   	pop    %esi
  810288:	5d                   	pop    %ebp
  810289:	c3                   	ret    

0081028a <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  81028a:	55                   	push   %ebp
  81028b:	89 e5                	mov    %esp,%ebp
  81028d:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810290:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810293:	89 44 24 04          	mov    %eax,0x4(%esp)
  810297:	8b 45 08             	mov    0x8(%ebp),%eax
  81029a:	89 04 24             	mov    %eax,(%esp)
  81029d:	e8 b0 fe ff ff       	call   810152 <fd_lookup>
  8102a2:	85 c0                	test   %eax,%eax
  8102a4:	78 13                	js     8102b9 <close+0x2f>
		return r;
	else
		return fd_close(fd, 1);
  8102a6:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8102ad:	00 
  8102ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8102b1:	89 04 24             	mov    %eax,(%esp)
  8102b4:	e8 49 ff ff ff       	call   810202 <fd_close>
}
  8102b9:	c9                   	leave  
  8102ba:	c3                   	ret    

008102bb <close_all>:

void
close_all(void)
{
  8102bb:	55                   	push   %ebp
  8102bc:	89 e5                	mov    %esp,%ebp
  8102be:	53                   	push   %ebx
  8102bf:	83 ec 14             	sub    $0x14,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  8102c2:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  8102c7:	89 1c 24             	mov    %ebx,(%esp)
  8102ca:	e8 bb ff ff ff       	call   81028a <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  8102cf:	43                   	inc    %ebx
  8102d0:	83 fb 20             	cmp    $0x20,%ebx
  8102d3:	75 f2                	jne    8102c7 <close_all+0xc>
		close(i);
}
  8102d5:	83 c4 14             	add    $0x14,%esp
  8102d8:	5b                   	pop    %ebx
  8102d9:	5d                   	pop    %ebp
  8102da:	c3                   	ret    

008102db <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  8102db:	55                   	push   %ebp
  8102dc:	89 e5                	mov    %esp,%ebp
  8102de:	57                   	push   %edi
  8102df:	56                   	push   %esi
  8102e0:	53                   	push   %ebx
  8102e1:	83 ec 4c             	sub    $0x4c,%esp
  8102e4:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  8102e7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8102ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  8102ee:	8b 45 08             	mov    0x8(%ebp),%eax
  8102f1:	89 04 24             	mov    %eax,(%esp)
  8102f4:	e8 59 fe ff ff       	call   810152 <fd_lookup>
  8102f9:	89 c3                	mov    %eax,%ebx
  8102fb:	85 c0                	test   %eax,%eax
  8102fd:	0f 88 e3 00 00 00    	js     8103e6 <dup+0x10b>
		return r;
	close(newfdnum);
  810303:	89 3c 24             	mov    %edi,(%esp)
  810306:	e8 7f ff ff ff       	call   81028a <close>

	newfd = INDEX2FD(newfdnum);
  81030b:	89 fe                	mov    %edi,%esi
  81030d:	c1 e6 0c             	shl    $0xc,%esi
  810310:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  810316:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810319:	89 04 24             	mov    %eax,(%esp)
  81031c:	e8 c3 fd ff ff       	call   8100e4 <fd2data>
  810321:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  810323:	89 34 24             	mov    %esi,(%esp)
  810326:	e8 b9 fd ff ff       	call   8100e4 <fd2data>
  81032b:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  81032e:	89 d8                	mov    %ebx,%eax
  810330:	c1 e8 16             	shr    $0x16,%eax
  810333:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  81033a:	a8 01                	test   $0x1,%al
  81033c:	74 46                	je     810384 <dup+0xa9>
  81033e:	89 d8                	mov    %ebx,%eax
  810340:	c1 e8 0c             	shr    $0xc,%eax
  810343:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  81034a:	f6 c2 01             	test   $0x1,%dl
  81034d:	74 35                	je     810384 <dup+0xa9>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  81034f:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  810356:	25 07 0e 00 00       	and    $0xe07,%eax
  81035b:	89 44 24 10          	mov    %eax,0x10(%esp)
  81035f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  810362:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810366:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81036d:	00 
  81036e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810372:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810379:	e8 eb f5 ff ff       	call   80f969 <sys_page_map>
  81037e:	89 c3                	mov    %eax,%ebx
  810380:	85 c0                	test   %eax,%eax
  810382:	78 3b                	js     8103bf <dup+0xe4>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  810384:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810387:	89 c2                	mov    %eax,%edx
  810389:	c1 ea 0c             	shr    $0xc,%edx
  81038c:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  810393:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  810399:	89 54 24 10          	mov    %edx,0x10(%esp)
  81039d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8103a1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8103a8:	00 
  8103a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8103ad:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8103b4:	e8 b0 f5 ff ff       	call   80f969 <sys_page_map>
  8103b9:	89 c3                	mov    %eax,%ebx
  8103bb:	85 c0                	test   %eax,%eax
  8103bd:	79 25                	jns    8103e4 <dup+0x109>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  8103bf:	89 74 24 04          	mov    %esi,0x4(%esp)
  8103c3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8103ca:	e8 ed f5 ff ff       	call   80f9bc <sys_page_unmap>
	sys_page_unmap(0, nva);
  8103cf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8103d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8103d6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8103dd:	e8 da f5 ff ff       	call   80f9bc <sys_page_unmap>
	return r;
  8103e2:	eb 02                	jmp    8103e6 <dup+0x10b>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
		goto err;

	return newfdnum;
  8103e4:	89 fb                	mov    %edi,%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  8103e6:	89 d8                	mov    %ebx,%eax
  8103e8:	83 c4 4c             	add    $0x4c,%esp
  8103eb:	5b                   	pop    %ebx
  8103ec:	5e                   	pop    %esi
  8103ed:	5f                   	pop    %edi
  8103ee:	5d                   	pop    %ebp
  8103ef:	c3                   	ret    

008103f0 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  8103f0:	55                   	push   %ebp
  8103f1:	89 e5                	mov    %esp,%ebp
  8103f3:	53                   	push   %ebx
  8103f4:	83 ec 24             	sub    $0x24,%esp
  8103f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8103fa:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8103fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  810401:	89 1c 24             	mov    %ebx,(%esp)
  810404:	e8 49 fd ff ff       	call   810152 <fd_lookup>
  810409:	85 c0                	test   %eax,%eax
  81040b:	78 6d                	js     81047a <read+0x8a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  81040d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810410:	89 44 24 04          	mov    %eax,0x4(%esp)
  810414:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810417:	8b 00                	mov    (%eax),%eax
  810419:	89 04 24             	mov    %eax,(%esp)
  81041c:	e8 87 fd ff ff       	call   8101a8 <dev_lookup>
  810421:	85 c0                	test   %eax,%eax
  810423:	78 55                	js     81047a <read+0x8a>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  810425:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810428:	8b 50 08             	mov    0x8(%eax),%edx
  81042b:	83 e2 03             	and    $0x3,%edx
  81042e:	83 fa 01             	cmp    $0x1,%edx
  810431:	75 23                	jne    810456 <read+0x66>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  810433:	a1 9c c2 b3 00       	mov    0xb3c29c,%eax
  810438:	8b 40 48             	mov    0x48(%eax),%eax
  81043b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81043f:	89 44 24 04          	mov    %eax,0x4(%esp)
  810443:	c7 04 24 6d 43 81 00 	movl   $0x81436d,(%esp)
  81044a:	e8 29 eb ff ff       	call   80ef78 <cprintf>
		return -E_INVAL;
  81044f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810454:	eb 24                	jmp    81047a <read+0x8a>
	}
	if (!dev->dev_read)
  810456:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810459:	8b 52 08             	mov    0x8(%edx),%edx
  81045c:	85 d2                	test   %edx,%edx
  81045e:	74 15                	je     810475 <read+0x85>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  810460:	8b 4d 10             	mov    0x10(%ebp),%ecx
  810463:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810467:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  81046a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  81046e:	89 04 24             	mov    %eax,(%esp)
  810471:	ff d2                	call   *%edx
  810473:	eb 05                	jmp    81047a <read+0x8a>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
		return -E_NOT_SUPP;
  810475:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_read)(fd, buf, n);
}
  81047a:	83 c4 24             	add    $0x24,%esp
  81047d:	5b                   	pop    %ebx
  81047e:	5d                   	pop    %ebp
  81047f:	c3                   	ret    

00810480 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  810480:	55                   	push   %ebp
  810481:	89 e5                	mov    %esp,%ebp
  810483:	57                   	push   %edi
  810484:	56                   	push   %esi
  810485:	53                   	push   %ebx
  810486:	83 ec 1c             	sub    $0x1c,%esp
  810489:	8b 7d 08             	mov    0x8(%ebp),%edi
  81048c:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  81048f:	bb 00 00 00 00       	mov    $0x0,%ebx
  810494:	eb 23                	jmp    8104b9 <readn+0x39>
		m = read(fdnum, (char*)buf + tot, n - tot);
  810496:	89 f0                	mov    %esi,%eax
  810498:	29 d8                	sub    %ebx,%eax
  81049a:	89 44 24 08          	mov    %eax,0x8(%esp)
  81049e:	8b 45 0c             	mov    0xc(%ebp),%eax
  8104a1:	01 d8                	add    %ebx,%eax
  8104a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8104a7:	89 3c 24             	mov    %edi,(%esp)
  8104aa:	e8 41 ff ff ff       	call   8103f0 <read>
		if (m < 0)
  8104af:	85 c0                	test   %eax,%eax
  8104b1:	78 10                	js     8104c3 <readn+0x43>
			return m;
		if (m == 0)
  8104b3:	85 c0                	test   %eax,%eax
  8104b5:	74 0a                	je     8104c1 <readn+0x41>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  8104b7:	01 c3                	add    %eax,%ebx
  8104b9:	39 f3                	cmp    %esi,%ebx
  8104bb:	72 d9                	jb     810496 <readn+0x16>
  8104bd:	89 d8                	mov    %ebx,%eax
  8104bf:	eb 02                	jmp    8104c3 <readn+0x43>
		m = read(fdnum, (char*)buf + tot, n - tot);
		if (m < 0)
			return m;
		if (m == 0)
  8104c1:	89 d8                	mov    %ebx,%eax
			break;
	}
	return tot;
}
  8104c3:	83 c4 1c             	add    $0x1c,%esp
  8104c6:	5b                   	pop    %ebx
  8104c7:	5e                   	pop    %esi
  8104c8:	5f                   	pop    %edi
  8104c9:	5d                   	pop    %ebp
  8104ca:	c3                   	ret    

008104cb <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  8104cb:	55                   	push   %ebp
  8104cc:	89 e5                	mov    %esp,%ebp
  8104ce:	53                   	push   %ebx
  8104cf:	83 ec 24             	sub    $0x24,%esp
  8104d2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8104d5:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8104d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8104dc:	89 1c 24             	mov    %ebx,(%esp)
  8104df:	e8 6e fc ff ff       	call   810152 <fd_lookup>
  8104e4:	85 c0                	test   %eax,%eax
  8104e6:	78 68                	js     810550 <write+0x85>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8104e8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8104eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8104ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8104f2:	8b 00                	mov    (%eax),%eax
  8104f4:	89 04 24             	mov    %eax,(%esp)
  8104f7:	e8 ac fc ff ff       	call   8101a8 <dev_lookup>
  8104fc:	85 c0                	test   %eax,%eax
  8104fe:	78 50                	js     810550 <write+0x85>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  810500:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810503:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  810507:	75 23                	jne    81052c <write+0x61>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  810509:	a1 9c c2 b3 00       	mov    0xb3c29c,%eax
  81050e:	8b 40 48             	mov    0x48(%eax),%eax
  810511:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810515:	89 44 24 04          	mov    %eax,0x4(%esp)
  810519:	c7 04 24 89 43 81 00 	movl   $0x814389,(%esp)
  810520:	e8 53 ea ff ff       	call   80ef78 <cprintf>
		return -E_INVAL;
  810525:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  81052a:	eb 24                	jmp    810550 <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  81052c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  81052f:	8b 52 0c             	mov    0xc(%edx),%edx
  810532:	85 d2                	test   %edx,%edx
  810534:	74 15                	je     81054b <write+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  810536:	8b 4d 10             	mov    0x10(%ebp),%ecx
  810539:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  81053d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810540:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  810544:	89 04 24             	mov    %eax,(%esp)
  810547:	ff d2                	call   *%edx
  810549:	eb 05                	jmp    810550 <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
		return -E_NOT_SUPP;
  81054b:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_write)(fd, buf, n);
}
  810550:	83 c4 24             	add    $0x24,%esp
  810553:	5b                   	pop    %ebx
  810554:	5d                   	pop    %ebp
  810555:	c3                   	ret    

00810556 <seek>:

int
seek(int fdnum, off_t offset)
{
  810556:	55                   	push   %ebp
  810557:	89 e5                	mov    %esp,%ebp
  810559:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  81055c:	8d 45 fc             	lea    -0x4(%ebp),%eax
  81055f:	89 44 24 04          	mov    %eax,0x4(%esp)
  810563:	8b 45 08             	mov    0x8(%ebp),%eax
  810566:	89 04 24             	mov    %eax,(%esp)
  810569:	e8 e4 fb ff ff       	call   810152 <fd_lookup>
  81056e:	85 c0                	test   %eax,%eax
  810570:	78 0e                	js     810580 <seek+0x2a>
		return r;
	fd->fd_offset = offset;
  810572:	8b 45 fc             	mov    -0x4(%ebp),%eax
  810575:	8b 55 0c             	mov    0xc(%ebp),%edx
  810578:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  81057b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810580:	c9                   	leave  
  810581:	c3                   	ret    

00810582 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  810582:	55                   	push   %ebp
  810583:	89 e5                	mov    %esp,%ebp
  810585:	53                   	push   %ebx
  810586:	83 ec 24             	sub    $0x24,%esp
  810589:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  81058c:	8d 45 f0             	lea    -0x10(%ebp),%eax
  81058f:	89 44 24 04          	mov    %eax,0x4(%esp)
  810593:	89 1c 24             	mov    %ebx,(%esp)
  810596:	e8 b7 fb ff ff       	call   810152 <fd_lookup>
  81059b:	85 c0                	test   %eax,%eax
  81059d:	78 61                	js     810600 <ftruncate+0x7e>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  81059f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8105a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8105a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8105a9:	8b 00                	mov    (%eax),%eax
  8105ab:	89 04 24             	mov    %eax,(%esp)
  8105ae:	e8 f5 fb ff ff       	call   8101a8 <dev_lookup>
  8105b3:	85 c0                	test   %eax,%eax
  8105b5:	78 49                	js     810600 <ftruncate+0x7e>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8105b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8105ba:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  8105be:	75 23                	jne    8105e3 <ftruncate+0x61>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  8105c0:	a1 9c c2 b3 00       	mov    0xb3c29c,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  8105c5:	8b 40 48             	mov    0x48(%eax),%eax
  8105c8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8105cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8105d0:	c7 04 24 4c 43 81 00 	movl   $0x81434c,(%esp)
  8105d7:	e8 9c e9 ff ff       	call   80ef78 <cprintf>
			thisenv->env_id, fdnum);
		return -E_INVAL;
  8105dc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8105e1:	eb 1d                	jmp    810600 <ftruncate+0x7e>
	}
	if (!dev->dev_trunc)
  8105e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8105e6:	8b 52 18             	mov    0x18(%edx),%edx
  8105e9:	85 d2                	test   %edx,%edx
  8105eb:	74 0e                	je     8105fb <ftruncate+0x79>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  8105ed:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8105f0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8105f4:	89 04 24             	mov    %eax,(%esp)
  8105f7:	ff d2                	call   *%edx
  8105f9:	eb 05                	jmp    810600 <ftruncate+0x7e>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
		return -E_NOT_SUPP;
  8105fb:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_trunc)(fd, newsize);
}
  810600:	83 c4 24             	add    $0x24,%esp
  810603:	5b                   	pop    %ebx
  810604:	5d                   	pop    %ebp
  810605:	c3                   	ret    

00810606 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  810606:	55                   	push   %ebp
  810607:	89 e5                	mov    %esp,%ebp
  810609:	53                   	push   %ebx
  81060a:	83 ec 24             	sub    $0x24,%esp
  81060d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810610:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810613:	89 44 24 04          	mov    %eax,0x4(%esp)
  810617:	8b 45 08             	mov    0x8(%ebp),%eax
  81061a:	89 04 24             	mov    %eax,(%esp)
  81061d:	e8 30 fb ff ff       	call   810152 <fd_lookup>
  810622:	85 c0                	test   %eax,%eax
  810624:	78 52                	js     810678 <fstat+0x72>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810626:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810629:	89 44 24 04          	mov    %eax,0x4(%esp)
  81062d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810630:	8b 00                	mov    (%eax),%eax
  810632:	89 04 24             	mov    %eax,(%esp)
  810635:	e8 6e fb ff ff       	call   8101a8 <dev_lookup>
  81063a:	85 c0                	test   %eax,%eax
  81063c:	78 3a                	js     810678 <fstat+0x72>
		return r;
	if (!dev->dev_stat)
  81063e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810641:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  810645:	74 2c                	je     810673 <fstat+0x6d>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  810647:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  81064a:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  810651:	00 00 00 
	stat->st_isdir = 0;
  810654:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  81065b:	00 00 00 
	stat->st_dev = dev;
  81065e:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  810664:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810668:	8b 55 f0             	mov    -0x10(%ebp),%edx
  81066b:	89 14 24             	mov    %edx,(%esp)
  81066e:	ff 50 14             	call   *0x14(%eax)
  810671:	eb 05                	jmp    810678 <fstat+0x72>

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
		return -E_NOT_SUPP;
  810673:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	stat->st_name[0] = 0;
	stat->st_size = 0;
	stat->st_isdir = 0;
	stat->st_dev = dev;
	return (*dev->dev_stat)(fd, stat);
}
  810678:	83 c4 24             	add    $0x24,%esp
  81067b:	5b                   	pop    %ebx
  81067c:	5d                   	pop    %ebp
  81067d:	c3                   	ret    

0081067e <stat>:

int
stat(const char *path, struct Stat *stat)
{
  81067e:	55                   	push   %ebp
  81067f:	89 e5                	mov    %esp,%ebp
  810681:	56                   	push   %esi
  810682:	53                   	push   %ebx
  810683:	83 ec 10             	sub    $0x10,%esp
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  810686:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81068d:	00 
  81068e:	8b 45 08             	mov    0x8(%ebp),%eax
  810691:	89 04 24             	mov    %eax,(%esp)
  810694:	e8 2a 02 00 00       	call   8108c3 <open>
  810699:	89 c3                	mov    %eax,%ebx
  81069b:	85 c0                	test   %eax,%eax
  81069d:	78 1b                	js     8106ba <stat+0x3c>
		return fd;
	r = fstat(fd, stat);
  81069f:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8106a6:	89 1c 24             	mov    %ebx,(%esp)
  8106a9:	e8 58 ff ff ff       	call   810606 <fstat>
  8106ae:	89 c6                	mov    %eax,%esi
	close(fd);
  8106b0:	89 1c 24             	mov    %ebx,(%esp)
  8106b3:	e8 d2 fb ff ff       	call   81028a <close>
	return r;
  8106b8:	89 f3                	mov    %esi,%ebx
}
  8106ba:	89 d8                	mov    %ebx,%eax
  8106bc:	83 c4 10             	add    $0x10,%esp
  8106bf:	5b                   	pop    %ebx
  8106c0:	5e                   	pop    %esi
  8106c1:	5d                   	pop    %ebp
  8106c2:	c3                   	ret    
	...

008106c4 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  8106c4:	55                   	push   %ebp
  8106c5:	89 e5                	mov    %esp,%ebp
  8106c7:	56                   	push   %esi
  8106c8:	53                   	push   %ebx
  8106c9:	83 ec 10             	sub    $0x10,%esp
  8106cc:	89 c3                	mov    %eax,%ebx
  8106ce:	89 d6                	mov    %edx,%esi
	static envid_t fsenv;
	if (fsenv == 0)
  8106d0:	83 3d 10 c2 b3 00 00 	cmpl   $0x0,0xb3c210
  8106d7:	75 11                	jne    8106ea <fsipc+0x26>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  8106d9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8106e0:	e8 aa f9 ff ff       	call   81008f <ipc_find_env>
  8106e5:	a3 10 c2 b3 00       	mov    %eax,0xb3c210
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  8106ea:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8106f1:	00 
  8106f2:	c7 44 24 08 00 d0 b3 	movl   $0xb3d000,0x8(%esp)
  8106f9:	00 
  8106fa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8106fe:	a1 10 c2 b3 00       	mov    0xb3c210,%eax
  810703:	89 04 24             	mov    %eax,(%esp)
  810706:	e8 01 f9 ff ff       	call   81000c <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  81070b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810712:	00 
  810713:	89 74 24 04          	mov    %esi,0x4(%esp)
  810717:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81071e:	e8 79 f8 ff ff       	call   80ff9c <ipc_recv>
}
  810723:	83 c4 10             	add    $0x10,%esp
  810726:	5b                   	pop    %ebx
  810727:	5e                   	pop    %esi
  810728:	5d                   	pop    %ebp
  810729:	c3                   	ret    

0081072a <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  81072a:	55                   	push   %ebp
  81072b:	89 e5                	mov    %esp,%ebp
  81072d:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  810730:	8b 45 08             	mov    0x8(%ebp),%eax
  810733:	8b 40 0c             	mov    0xc(%eax),%eax
  810736:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.set_size.req_size = newsize;
  81073b:	8b 45 0c             	mov    0xc(%ebp),%eax
  81073e:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return fsipc(FSREQ_SET_SIZE, NULL);
  810743:	ba 00 00 00 00       	mov    $0x0,%edx
  810748:	b8 02 00 00 00       	mov    $0x2,%eax
  81074d:	e8 72 ff ff ff       	call   8106c4 <fsipc>
}
  810752:	c9                   	leave  
  810753:	c3                   	ret    

00810754 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  810754:	55                   	push   %ebp
  810755:	89 e5                	mov    %esp,%ebp
  810757:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  81075a:	8b 45 08             	mov    0x8(%ebp),%eax
  81075d:	8b 40 0c             	mov    0xc(%eax),%eax
  810760:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return fsipc(FSREQ_FLUSH, NULL);
  810765:	ba 00 00 00 00       	mov    $0x0,%edx
  81076a:	b8 06 00 00 00       	mov    $0x6,%eax
  81076f:	e8 50 ff ff ff       	call   8106c4 <fsipc>
}
  810774:	c9                   	leave  
  810775:	c3                   	ret    

00810776 <devfile_stat>:
	// panic("devfile_write not implemented");
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  810776:	55                   	push   %ebp
  810777:	89 e5                	mov    %esp,%ebp
  810779:	53                   	push   %ebx
  81077a:	83 ec 14             	sub    $0x14,%esp
  81077d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  810780:	8b 45 08             	mov    0x8(%ebp),%eax
  810783:	8b 40 0c             	mov    0xc(%eax),%eax
  810786:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  81078b:	ba 00 00 00 00       	mov    $0x0,%edx
  810790:	b8 05 00 00 00       	mov    $0x5,%eax
  810795:	e8 2a ff ff ff       	call   8106c4 <fsipc>
  81079a:	85 c0                	test   %eax,%eax
  81079c:	78 2b                	js     8107c9 <devfile_stat+0x53>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  81079e:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  8107a5:	00 
  8107a6:	89 1c 24             	mov    %ebx,(%esp)
  8107a9:	e8 75 ed ff ff       	call   80f523 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  8107ae:	a1 80 d0 b3 00       	mov    0xb3d080,%eax
  8107b3:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8107b9:	a1 84 d0 b3 00       	mov    0xb3d084,%eax
  8107be:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  8107c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8107c9:	83 c4 14             	add    $0x14,%esp
  8107cc:	5b                   	pop    %ebx
  8107cd:	5d                   	pop    %ebp
  8107ce:	c3                   	ret    

008107cf <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  8107cf:	55                   	push   %ebp
  8107d0:	89 e5                	mov    %esp,%ebp
  8107d2:	83 ec 18             	sub    $0x18,%esp
  8107d5:	8b 45 10             	mov    0x10(%ebp),%eax
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
	int r;

	fsipcbuf.write.req_fileid = fd->fd_file.id;
  8107d8:	8b 55 08             	mov    0x8(%ebp),%edx
  8107db:	8b 52 0c             	mov    0xc(%edx),%edx
  8107de:	89 15 00 d0 b3 00    	mov    %edx,0xb3d000
	fsipcbuf.write.req_n = n;
  8107e4:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	size_t maxw = PGSIZE - (sizeof(int) + sizeof(size_t));
	n = n <= maxw ? n : maxw ;
  8107e9:	89 c2                	mov    %eax,%edx
  8107eb:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  8107f0:	76 05                	jbe    8107f7 <devfile_write+0x28>
  8107f2:	ba f8 0f 00 00       	mov    $0xff8,%edx
	memcpy(fsipcbuf.write.req_buf, buf, n);
  8107f7:	89 54 24 08          	mov    %edx,0x8(%esp)
  8107fb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8107fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  810802:	c7 04 24 08 d0 b3 00 	movl   $0xb3d008,(%esp)
  810809:	e8 f8 ee ff ff       	call   80f706 <memcpy>
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  81080e:	ba 00 00 00 00       	mov    $0x0,%edx
  810813:	b8 04 00 00 00       	mov    $0x4,%eax
  810818:	e8 a7 fe ff ff       	call   8106c4 <fsipc>
	{
		return r;
	}
	return r;
	// panic("devfile_write not implemented");
}
  81081d:	c9                   	leave  
  81081e:	c3                   	ret    

0081081f <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  81081f:	55                   	push   %ebp
  810820:	89 e5                	mov    %esp,%ebp
  810822:	56                   	push   %esi
  810823:	53                   	push   %ebx
  810824:	83 ec 10             	sub    $0x10,%esp
  810827:	8b 75 10             	mov    0x10(%ebp),%esi
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  81082a:	8b 45 08             	mov    0x8(%ebp),%eax
  81082d:	8b 40 0c             	mov    0xc(%eax),%eax
  810830:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.read.req_n = n;
  810835:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  81083b:	ba 00 00 00 00       	mov    $0x0,%edx
  810840:	b8 03 00 00 00       	mov    $0x3,%eax
  810845:	e8 7a fe ff ff       	call   8106c4 <fsipc>
  81084a:	89 c3                	mov    %eax,%ebx
  81084c:	85 c0                	test   %eax,%eax
  81084e:	78 6a                	js     8108ba <devfile_read+0x9b>
		return r;
	assert(r <= n);
  810850:	39 c6                	cmp    %eax,%esi
  810852:	73 24                	jae    810878 <devfile_read+0x59>
  810854:	c7 44 24 0c bc 43 81 	movl   $0x8143bc,0xc(%esp)
  81085b:	00 
  81085c:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  810863:	00 
  810864:	c7 44 24 04 7c 00 00 	movl   $0x7c,0x4(%esp)
  81086b:	00 
  81086c:	c7 04 24 c3 43 81 00 	movl   $0x8143c3,(%esp)
  810873:	e8 08 e6 ff ff       	call   80ee80 <_panic>
	assert(r <= PGSIZE);
  810878:	3d 00 10 00 00       	cmp    $0x1000,%eax
  81087d:	7e 24                	jle    8108a3 <devfile_read+0x84>
  81087f:	c7 44 24 0c ce 43 81 	movl   $0x8143ce,0xc(%esp)
  810886:	00 
  810887:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  81088e:	00 
  81088f:	c7 44 24 04 7d 00 00 	movl   $0x7d,0x4(%esp)
  810896:	00 
  810897:	c7 04 24 c3 43 81 00 	movl   $0x8143c3,(%esp)
  81089e:	e8 dd e5 ff ff       	call   80ee80 <_panic>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  8108a3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8108a7:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  8108ae:	00 
  8108af:	8b 45 0c             	mov    0xc(%ebp),%eax
  8108b2:	89 04 24             	mov    %eax,(%esp)
  8108b5:	e8 e2 ed ff ff       	call   80f69c <memmove>
	return r;
}
  8108ba:	89 d8                	mov    %ebx,%eax
  8108bc:	83 c4 10             	add    $0x10,%esp
  8108bf:	5b                   	pop    %ebx
  8108c0:	5e                   	pop    %esi
  8108c1:	5d                   	pop    %ebp
  8108c2:	c3                   	ret    

008108c3 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  8108c3:	55                   	push   %ebp
  8108c4:	89 e5                	mov    %esp,%ebp
  8108c6:	56                   	push   %esi
  8108c7:	53                   	push   %ebx
  8108c8:	83 ec 20             	sub    $0x20,%esp
  8108cb:	8b 75 08             	mov    0x8(%ebp),%esi
	// file descriptor.

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  8108ce:	89 34 24             	mov    %esi,(%esp)
  8108d1:	e8 1a ec ff ff       	call   80f4f0 <strlen>
  8108d6:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  8108db:	7f 60                	jg     81093d <open+0x7a>
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  8108dd:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8108e0:	89 04 24             	mov    %eax,(%esp)
  8108e3:	e8 17 f8 ff ff       	call   8100ff <fd_alloc>
  8108e8:	89 c3                	mov    %eax,%ebx
  8108ea:	85 c0                	test   %eax,%eax
  8108ec:	78 54                	js     810942 <open+0x7f>
		return r;

	strcpy(fsipcbuf.open.req_path, path);
  8108ee:	89 74 24 04          	mov    %esi,0x4(%esp)
  8108f2:	c7 04 24 00 d0 b3 00 	movl   $0xb3d000,(%esp)
  8108f9:	e8 25 ec ff ff       	call   80f523 <strcpy>
	fsipcbuf.open.req_omode = mode;
  8108fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  810901:	a3 00 d4 b3 00       	mov    %eax,0xb3d400

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  810906:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810909:	b8 01 00 00 00       	mov    $0x1,%eax
  81090e:	e8 b1 fd ff ff       	call   8106c4 <fsipc>
  810913:	89 c3                	mov    %eax,%ebx
  810915:	85 c0                	test   %eax,%eax
  810917:	79 15                	jns    81092e <open+0x6b>
		fd_close(fd, 0);
  810919:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810920:	00 
  810921:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810924:	89 04 24             	mov    %eax,(%esp)
  810927:	e8 d6 f8 ff ff       	call   810202 <fd_close>
		return r;
  81092c:	eb 14                	jmp    810942 <open+0x7f>
	}

	return fd2num(fd);
  81092e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810931:	89 04 24             	mov    %eax,(%esp)
  810934:	e8 9b f7 ff ff       	call   8100d4 <fd2num>
  810939:	89 c3                	mov    %eax,%ebx
  81093b:	eb 05                	jmp    810942 <open+0x7f>

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;
  81093d:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
		fd_close(fd, 0);
		return r;
	}

	return fd2num(fd);
}
  810942:	89 d8                	mov    %ebx,%eax
  810944:	83 c4 20             	add    $0x20,%esp
  810947:	5b                   	pop    %ebx
  810948:	5e                   	pop    %esi
  810949:	5d                   	pop    %ebp
  81094a:	c3                   	ret    

0081094b <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  81094b:	55                   	push   %ebp
  81094c:	89 e5                	mov    %esp,%ebp
  81094e:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  810951:	ba 00 00 00 00       	mov    $0x0,%edx
  810956:	b8 08 00 00 00       	mov    $0x8,%eax
  81095b:	e8 64 fd ff ff       	call   8106c4 <fsipc>
}
  810960:	c9                   	leave  
  810961:	c3                   	ret    
	...

00810964 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  810964:	55                   	push   %ebp
  810965:	89 e5                	mov    %esp,%ebp
  810967:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<sock>");
  81096a:	c7 44 24 04 da 43 81 	movl   $0x8143da,0x4(%esp)
  810971:	00 
  810972:	8b 45 0c             	mov    0xc(%ebp),%eax
  810975:	89 04 24             	mov    %eax,(%esp)
  810978:	e8 a6 eb ff ff       	call   80f523 <strcpy>
	return 0;
}
  81097d:	b8 00 00 00 00       	mov    $0x0,%eax
  810982:	c9                   	leave  
  810983:	c3                   	ret    

00810984 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  810984:	55                   	push   %ebp
  810985:	89 e5                	mov    %esp,%ebp
  810987:	53                   	push   %ebx
  810988:	83 ec 14             	sub    $0x14,%esp
  81098b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  81098e:	89 1c 24             	mov    %ebx,(%esp)
  810991:	e8 d2 0c 00 00       	call   811668 <pageref>
  810996:	83 f8 01             	cmp    $0x1,%eax
  810999:	75 0d                	jne    8109a8 <devsock_close+0x24>
		return nsipc_close(fd->fd_sock.sockid);
  81099b:	8b 43 0c             	mov    0xc(%ebx),%eax
  81099e:	89 04 24             	mov    %eax,(%esp)
  8109a1:	e8 1f 03 00 00       	call   810cc5 <nsipc_close>
  8109a6:	eb 05                	jmp    8109ad <devsock_close+0x29>
	else
		return 0;
  8109a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8109ad:	83 c4 14             	add    $0x14,%esp
  8109b0:	5b                   	pop    %ebx
  8109b1:	5d                   	pop    %ebp
  8109b2:	c3                   	ret    

008109b3 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  8109b3:	55                   	push   %ebp
  8109b4:	89 e5                	mov    %esp,%ebp
  8109b6:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  8109b9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8109c0:	00 
  8109c1:	8b 45 10             	mov    0x10(%ebp),%eax
  8109c4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8109c8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8109cb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8109cf:	8b 45 08             	mov    0x8(%ebp),%eax
  8109d2:	8b 40 0c             	mov    0xc(%eax),%eax
  8109d5:	89 04 24             	mov    %eax,(%esp)
  8109d8:	e8 e3 03 00 00       	call   810dc0 <nsipc_send>
}
  8109dd:	c9                   	leave  
  8109de:	c3                   	ret    

008109df <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  8109df:	55                   	push   %ebp
  8109e0:	89 e5                	mov    %esp,%ebp
  8109e2:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  8109e5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8109ec:	00 
  8109ed:	8b 45 10             	mov    0x10(%ebp),%eax
  8109f0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8109f4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8109f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8109fb:	8b 45 08             	mov    0x8(%ebp),%eax
  8109fe:	8b 40 0c             	mov    0xc(%eax),%eax
  810a01:	89 04 24             	mov    %eax,(%esp)
  810a04:	e8 37 03 00 00       	call   810d40 <nsipc_recv>
}
  810a09:	c9                   	leave  
  810a0a:	c3                   	ret    

00810a0b <alloc_sockfd>:
	return sfd->fd_sock.sockid;
}

static int
alloc_sockfd(int sockid)
{
  810a0b:	55                   	push   %ebp
  810a0c:	89 e5                	mov    %esp,%ebp
  810a0e:	56                   	push   %esi
  810a0f:	53                   	push   %ebx
  810a10:	83 ec 20             	sub    $0x20,%esp
  810a13:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  810a15:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810a18:	89 04 24             	mov    %eax,(%esp)
  810a1b:	e8 df f6 ff ff       	call   8100ff <fd_alloc>
  810a20:	89 c3                	mov    %eax,%ebx
  810a22:	85 c0                	test   %eax,%eax
  810a24:	78 21                	js     810a47 <alloc_sockfd+0x3c>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  810a26:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  810a2d:	00 
  810a2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810a31:	89 44 24 04          	mov    %eax,0x4(%esp)
  810a35:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810a3c:	e8 d4 ee ff ff       	call   80f915 <sys_page_alloc>
  810a41:	89 c3                	mov    %eax,%ebx
  810a43:	85 c0                	test   %eax,%eax
  810a45:	79 0a                	jns    810a51 <alloc_sockfd+0x46>
		nsipc_close(sockid);
  810a47:	89 34 24             	mov    %esi,(%esp)
  810a4a:	e8 76 02 00 00       	call   810cc5 <nsipc_close>
		return r;
  810a4f:	eb 22                	jmp    810a73 <alloc_sockfd+0x68>
	}

	sfd->fd_dev_id = devsock.dev_id;
  810a51:	8b 15 08 53 81 00    	mov    0x815308,%edx
  810a57:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810a5a:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  810a5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810a5f:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  810a66:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  810a69:	89 04 24             	mov    %eax,(%esp)
  810a6c:	e8 63 f6 ff ff       	call   8100d4 <fd2num>
  810a71:	89 c3                	mov    %eax,%ebx
}
  810a73:	89 d8                	mov    %ebx,%eax
  810a75:	83 c4 20             	add    $0x20,%esp
  810a78:	5b                   	pop    %ebx
  810a79:	5e                   	pop    %esi
  810a7a:	5d                   	pop    %ebp
  810a7b:	c3                   	ret    

00810a7c <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  810a7c:	55                   	push   %ebp
  810a7d:	89 e5                	mov    %esp,%ebp
  810a7f:	83 ec 28             	sub    $0x28,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  810a82:	8d 55 f4             	lea    -0xc(%ebp),%edx
  810a85:	89 54 24 04          	mov    %edx,0x4(%esp)
  810a89:	89 04 24             	mov    %eax,(%esp)
  810a8c:	e8 c1 f6 ff ff       	call   810152 <fd_lookup>
  810a91:	85 c0                	test   %eax,%eax
  810a93:	78 17                	js     810aac <fd2sockid+0x30>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  810a95:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810a98:	8b 15 08 53 81 00    	mov    0x815308,%edx
  810a9e:	39 10                	cmp    %edx,(%eax)
  810aa0:	75 05                	jne    810aa7 <fd2sockid+0x2b>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  810aa2:	8b 40 0c             	mov    0xc(%eax),%eax
  810aa5:	eb 05                	jmp    810aac <fd2sockid+0x30>
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
		return -E_NOT_SUPP;
  810aa7:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return sfd->fd_sock.sockid;
}
  810aac:	c9                   	leave  
  810aad:	c3                   	ret    

00810aae <accept>:
	return fd2num(sfd);
}

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  810aae:	55                   	push   %ebp
  810aaf:	89 e5                	mov    %esp,%ebp
  810ab1:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810ab4:	8b 45 08             	mov    0x8(%ebp),%eax
  810ab7:	e8 c0 ff ff ff       	call   810a7c <fd2sockid>
  810abc:	85 c0                	test   %eax,%eax
  810abe:	78 1f                	js     810adf <accept+0x31>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  810ac0:	8b 55 10             	mov    0x10(%ebp),%edx
  810ac3:	89 54 24 08          	mov    %edx,0x8(%esp)
  810ac7:	8b 55 0c             	mov    0xc(%ebp),%edx
  810aca:	89 54 24 04          	mov    %edx,0x4(%esp)
  810ace:	89 04 24             	mov    %eax,(%esp)
  810ad1:	e8 38 01 00 00       	call   810c0e <nsipc_accept>
  810ad6:	85 c0                	test   %eax,%eax
  810ad8:	78 05                	js     810adf <accept+0x31>
		return r;
	return alloc_sockfd(r);
  810ada:	e8 2c ff ff ff       	call   810a0b <alloc_sockfd>
}
  810adf:	c9                   	leave  
  810ae0:	c3                   	ret    

00810ae1 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810ae1:	55                   	push   %ebp
  810ae2:	89 e5                	mov    %esp,%ebp
  810ae4:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810ae7:	8b 45 08             	mov    0x8(%ebp),%eax
  810aea:	e8 8d ff ff ff       	call   810a7c <fd2sockid>
  810aef:	85 c0                	test   %eax,%eax
  810af1:	78 16                	js     810b09 <bind+0x28>
		return r;
	return nsipc_bind(r, name, namelen);
  810af3:	8b 55 10             	mov    0x10(%ebp),%edx
  810af6:	89 54 24 08          	mov    %edx,0x8(%esp)
  810afa:	8b 55 0c             	mov    0xc(%ebp),%edx
  810afd:	89 54 24 04          	mov    %edx,0x4(%esp)
  810b01:	89 04 24             	mov    %eax,(%esp)
  810b04:	e8 5b 01 00 00       	call   810c64 <nsipc_bind>
}
  810b09:	c9                   	leave  
  810b0a:	c3                   	ret    

00810b0b <shutdown>:

int
shutdown(int s, int how)
{
  810b0b:	55                   	push   %ebp
  810b0c:	89 e5                	mov    %esp,%ebp
  810b0e:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810b11:	8b 45 08             	mov    0x8(%ebp),%eax
  810b14:	e8 63 ff ff ff       	call   810a7c <fd2sockid>
  810b19:	85 c0                	test   %eax,%eax
  810b1b:	78 0f                	js     810b2c <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  810b1d:	8b 55 0c             	mov    0xc(%ebp),%edx
  810b20:	89 54 24 04          	mov    %edx,0x4(%esp)
  810b24:	89 04 24             	mov    %eax,(%esp)
  810b27:	e8 77 01 00 00       	call   810ca3 <nsipc_shutdown>
}
  810b2c:	c9                   	leave  
  810b2d:	c3                   	ret    

00810b2e <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810b2e:	55                   	push   %ebp
  810b2f:	89 e5                	mov    %esp,%ebp
  810b31:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810b34:	8b 45 08             	mov    0x8(%ebp),%eax
  810b37:	e8 40 ff ff ff       	call   810a7c <fd2sockid>
  810b3c:	85 c0                	test   %eax,%eax
  810b3e:	78 16                	js     810b56 <connect+0x28>
		return r;
	return nsipc_connect(r, name, namelen);
  810b40:	8b 55 10             	mov    0x10(%ebp),%edx
  810b43:	89 54 24 08          	mov    %edx,0x8(%esp)
  810b47:	8b 55 0c             	mov    0xc(%ebp),%edx
  810b4a:	89 54 24 04          	mov    %edx,0x4(%esp)
  810b4e:	89 04 24             	mov    %eax,(%esp)
  810b51:	e8 89 01 00 00       	call   810cdf <nsipc_connect>
}
  810b56:	c9                   	leave  
  810b57:	c3                   	ret    

00810b58 <listen>:

int
listen(int s, int backlog)
{
  810b58:	55                   	push   %ebp
  810b59:	89 e5                	mov    %esp,%ebp
  810b5b:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810b5e:	8b 45 08             	mov    0x8(%ebp),%eax
  810b61:	e8 16 ff ff ff       	call   810a7c <fd2sockid>
  810b66:	85 c0                	test   %eax,%eax
  810b68:	78 0f                	js     810b79 <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  810b6a:	8b 55 0c             	mov    0xc(%ebp),%edx
  810b6d:	89 54 24 04          	mov    %edx,0x4(%esp)
  810b71:	89 04 24             	mov    %eax,(%esp)
  810b74:	e8 a5 01 00 00       	call   810d1e <nsipc_listen>
}
  810b79:	c9                   	leave  
  810b7a:	c3                   	ret    

00810b7b <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  810b7b:	55                   	push   %ebp
  810b7c:	89 e5                	mov    %esp,%ebp
  810b7e:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  810b81:	8b 45 10             	mov    0x10(%ebp),%eax
  810b84:	89 44 24 08          	mov    %eax,0x8(%esp)
  810b88:	8b 45 0c             	mov    0xc(%ebp),%eax
  810b8b:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b8f:	8b 45 08             	mov    0x8(%ebp),%eax
  810b92:	89 04 24             	mov    %eax,(%esp)
  810b95:	e8 99 02 00 00       	call   810e33 <nsipc_socket>
  810b9a:	85 c0                	test   %eax,%eax
  810b9c:	78 05                	js     810ba3 <socket+0x28>
		return r;
	return alloc_sockfd(r);
  810b9e:	e8 68 fe ff ff       	call   810a0b <alloc_sockfd>
}
  810ba3:	c9                   	leave  
  810ba4:	c3                   	ret    
  810ba5:	00 00                	add    %al,(%eax)
	...

00810ba8 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  810ba8:	55                   	push   %ebp
  810ba9:	89 e5                	mov    %esp,%ebp
  810bab:	53                   	push   %ebx
  810bac:	83 ec 14             	sub    $0x14,%esp
  810baf:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  810bb1:	83 3d 14 c2 b3 00 00 	cmpl   $0x0,0xb3c214
  810bb8:	75 11                	jne    810bcb <nsipc+0x23>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  810bba:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  810bc1:	e8 c9 f4 ff ff       	call   81008f <ipc_find_env>
  810bc6:	a3 14 c2 b3 00       	mov    %eax,0xb3c214
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  810bcb:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  810bd2:	00 
  810bd3:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  810bda:	00 
  810bdb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810bdf:	a1 14 c2 b3 00       	mov    0xb3c214,%eax
  810be4:	89 04 24             	mov    %eax,(%esp)
  810be7:	e8 20 f4 ff ff       	call   81000c <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  810bec:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810bf3:	00 
  810bf4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810bfb:	00 
  810bfc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810c03:	e8 94 f3 ff ff       	call   80ff9c <ipc_recv>
}
  810c08:	83 c4 14             	add    $0x14,%esp
  810c0b:	5b                   	pop    %ebx
  810c0c:	5d                   	pop    %ebp
  810c0d:	c3                   	ret    

00810c0e <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  810c0e:	55                   	push   %ebp
  810c0f:	89 e5                	mov    %esp,%ebp
  810c11:	56                   	push   %esi
  810c12:	53                   	push   %ebx
  810c13:	83 ec 10             	sub    $0x10,%esp
  810c16:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  810c19:	8b 45 08             	mov    0x8(%ebp),%eax
  810c1c:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.accept.req_addrlen = *addrlen;
  810c21:	8b 06                	mov    (%esi),%eax
  810c23:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  810c28:	b8 01 00 00 00       	mov    $0x1,%eax
  810c2d:	e8 76 ff ff ff       	call   810ba8 <nsipc>
  810c32:	89 c3                	mov    %eax,%ebx
  810c34:	85 c0                	test   %eax,%eax
  810c36:	78 23                	js     810c5b <nsipc_accept+0x4d>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  810c38:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  810c3d:	89 44 24 08          	mov    %eax,0x8(%esp)
  810c41:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  810c48:	00 
  810c49:	8b 45 0c             	mov    0xc(%ebp),%eax
  810c4c:	89 04 24             	mov    %eax,(%esp)
  810c4f:	e8 48 ea ff ff       	call   80f69c <memmove>
		*addrlen = ret->ret_addrlen;
  810c54:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  810c59:	89 06                	mov    %eax,(%esi)
	}
	return r;
}
  810c5b:	89 d8                	mov    %ebx,%eax
  810c5d:	83 c4 10             	add    $0x10,%esp
  810c60:	5b                   	pop    %ebx
  810c61:	5e                   	pop    %esi
  810c62:	5d                   	pop    %ebp
  810c63:	c3                   	ret    

00810c64 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810c64:	55                   	push   %ebp
  810c65:	89 e5                	mov    %esp,%ebp
  810c67:	53                   	push   %ebx
  810c68:	83 ec 14             	sub    $0x14,%esp
  810c6b:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  810c6e:	8b 45 08             	mov    0x8(%ebp),%eax
  810c71:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  810c76:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810c7a:	8b 45 0c             	mov    0xc(%ebp),%eax
  810c7d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810c81:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  810c88:	e8 0f ea ff ff       	call   80f69c <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  810c8d:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_BIND);
  810c93:	b8 02 00 00 00       	mov    $0x2,%eax
  810c98:	e8 0b ff ff ff       	call   810ba8 <nsipc>
}
  810c9d:	83 c4 14             	add    $0x14,%esp
  810ca0:	5b                   	pop    %ebx
  810ca1:	5d                   	pop    %ebp
  810ca2:	c3                   	ret    

00810ca3 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  810ca3:	55                   	push   %ebp
  810ca4:	89 e5                	mov    %esp,%ebp
  810ca6:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  810ca9:	8b 45 08             	mov    0x8(%ebp),%eax
  810cac:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.shutdown.req_how = how;
  810cb1:	8b 45 0c             	mov    0xc(%ebp),%eax
  810cb4:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_SHUTDOWN);
  810cb9:	b8 03 00 00 00       	mov    $0x3,%eax
  810cbe:	e8 e5 fe ff ff       	call   810ba8 <nsipc>
}
  810cc3:	c9                   	leave  
  810cc4:	c3                   	ret    

00810cc5 <nsipc_close>:

int
nsipc_close(int s)
{
  810cc5:	55                   	push   %ebp
  810cc6:	89 e5                	mov    %esp,%ebp
  810cc8:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  810ccb:	8b 45 08             	mov    0x8(%ebp),%eax
  810cce:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	return nsipc(NSREQ_CLOSE);
  810cd3:	b8 04 00 00 00       	mov    $0x4,%eax
  810cd8:	e8 cb fe ff ff       	call   810ba8 <nsipc>
}
  810cdd:	c9                   	leave  
  810cde:	c3                   	ret    

00810cdf <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810cdf:	55                   	push   %ebp
  810ce0:	89 e5                	mov    %esp,%ebp
  810ce2:	53                   	push   %ebx
  810ce3:	83 ec 14             	sub    $0x14,%esp
  810ce6:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  810ce9:	8b 45 08             	mov    0x8(%ebp),%eax
  810cec:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  810cf1:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810cf5:	8b 45 0c             	mov    0xc(%ebp),%eax
  810cf8:	89 44 24 04          	mov    %eax,0x4(%esp)
  810cfc:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  810d03:	e8 94 e9 ff ff       	call   80f69c <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810d08:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_CONNECT);
  810d0e:	b8 05 00 00 00       	mov    $0x5,%eax
  810d13:	e8 90 fe ff ff       	call   810ba8 <nsipc>
}
  810d18:	83 c4 14             	add    $0x14,%esp
  810d1b:	5b                   	pop    %ebx
  810d1c:	5d                   	pop    %ebp
  810d1d:	c3                   	ret    

00810d1e <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  810d1e:	55                   	push   %ebp
  810d1f:	89 e5                	mov    %esp,%ebp
  810d21:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  810d24:	8b 45 08             	mov    0x8(%ebp),%eax
  810d27:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.listen.req_backlog = backlog;
  810d2c:	8b 45 0c             	mov    0xc(%ebp),%eax
  810d2f:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_LISTEN);
  810d34:	b8 06 00 00 00       	mov    $0x6,%eax
  810d39:	e8 6a fe ff ff       	call   810ba8 <nsipc>
}
  810d3e:	c9                   	leave  
  810d3f:	c3                   	ret    

00810d40 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  810d40:	55                   	push   %ebp
  810d41:	89 e5                	mov    %esp,%ebp
  810d43:	56                   	push   %esi
  810d44:	53                   	push   %ebx
  810d45:	83 ec 10             	sub    $0x10,%esp
  810d48:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  810d4b:	8b 45 08             	mov    0x8(%ebp),%eax
  810d4e:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.recv.req_len = len;
  810d53:	89 35 04 e0 b3 00    	mov    %esi,0xb3e004
	nsipcbuf.recv.req_flags = flags;
  810d59:	8b 45 14             	mov    0x14(%ebp),%eax
  810d5c:	a3 08 e0 b3 00       	mov    %eax,0xb3e008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  810d61:	b8 07 00 00 00       	mov    $0x7,%eax
  810d66:	e8 3d fe ff ff       	call   810ba8 <nsipc>
  810d6b:	89 c3                	mov    %eax,%ebx
  810d6d:	85 c0                	test   %eax,%eax
  810d6f:	78 46                	js     810db7 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  810d71:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  810d76:	7f 04                	jg     810d7c <nsipc_recv+0x3c>
  810d78:	39 c6                	cmp    %eax,%esi
  810d7a:	7d 24                	jge    810da0 <nsipc_recv+0x60>
  810d7c:	c7 44 24 0c e6 43 81 	movl   $0x8143e6,0xc(%esp)
  810d83:	00 
  810d84:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  810d8b:	00 
  810d8c:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  810d93:	00 
  810d94:	c7 04 24 fb 43 81 00 	movl   $0x8143fb,(%esp)
  810d9b:	e8 e0 e0 ff ff       	call   80ee80 <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810da0:	89 44 24 08          	mov    %eax,0x8(%esp)
  810da4:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  810dab:	00 
  810dac:	8b 45 0c             	mov    0xc(%ebp),%eax
  810daf:	89 04 24             	mov    %eax,(%esp)
  810db2:	e8 e5 e8 ff ff       	call   80f69c <memmove>
	}

	return r;
}
  810db7:	89 d8                	mov    %ebx,%eax
  810db9:	83 c4 10             	add    $0x10,%esp
  810dbc:	5b                   	pop    %ebx
  810dbd:	5e                   	pop    %esi
  810dbe:	5d                   	pop    %ebp
  810dbf:	c3                   	ret    

00810dc0 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  810dc0:	55                   	push   %ebp
  810dc1:	89 e5                	mov    %esp,%ebp
  810dc3:	53                   	push   %ebx
  810dc4:	83 ec 14             	sub    $0x14,%esp
  810dc7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  810dca:	8b 45 08             	mov    0x8(%ebp),%eax
  810dcd:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	assert(size < 1600);
  810dd2:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  810dd8:	7e 24                	jle    810dfe <nsipc_send+0x3e>
  810dda:	c7 44 24 0c 07 44 81 	movl   $0x814407,0xc(%esp)
  810de1:	00 
  810de2:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  810de9:	00 
  810dea:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
  810df1:	00 
  810df2:	c7 04 24 fb 43 81 00 	movl   $0x8143fb,(%esp)
  810df9:	e8 82 e0 ff ff       	call   80ee80 <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  810dfe:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810e02:	8b 45 0c             	mov    0xc(%ebp),%eax
  810e05:	89 44 24 04          	mov    %eax,0x4(%esp)
  810e09:	c7 04 24 0c e0 b3 00 	movl   $0xb3e00c,(%esp)
  810e10:	e8 87 e8 ff ff       	call   80f69c <memmove>
	nsipcbuf.send.req_size = size;
  810e15:	89 1d 04 e0 b3 00    	mov    %ebx,0xb3e004
	nsipcbuf.send.req_flags = flags;
  810e1b:	8b 45 14             	mov    0x14(%ebp),%eax
  810e1e:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SEND);
  810e23:	b8 08 00 00 00       	mov    $0x8,%eax
  810e28:	e8 7b fd ff ff       	call   810ba8 <nsipc>
}
  810e2d:	83 c4 14             	add    $0x14,%esp
  810e30:	5b                   	pop    %ebx
  810e31:	5d                   	pop    %ebp
  810e32:	c3                   	ret    

00810e33 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810e33:	55                   	push   %ebp
  810e34:	89 e5                	mov    %esp,%ebp
  810e36:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  810e39:	8b 45 08             	mov    0x8(%ebp),%eax
  810e3c:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.socket.req_type = type;
  810e41:	8b 45 0c             	mov    0xc(%ebp),%eax
  810e44:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	nsipcbuf.socket.req_protocol = protocol;
  810e49:	8b 45 10             	mov    0x10(%ebp),%eax
  810e4c:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SOCKET);
  810e51:	b8 09 00 00 00       	mov    $0x9,%eax
  810e56:	e8 4d fd ff ff       	call   810ba8 <nsipc>
}
  810e5b:	c9                   	leave  
  810e5c:	c3                   	ret    
  810e5d:	00 00                	add    %al,(%eax)
	...

00810e60 <free>:
	return v;
}

void
free(void *v)
{
  810e60:	55                   	push   %ebp
  810e61:	89 e5                	mov    %esp,%ebp
  810e63:	53                   	push   %ebx
  810e64:	83 ec 14             	sub    $0x14,%esp
  810e67:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  810e6a:	85 db                	test   %ebx,%ebx
  810e6c:	0f 84 b8 00 00 00    	je     810f2a <free+0xca>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  810e72:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  810e78:	76 08                	jbe    810e82 <free+0x22>
  810e7a:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  810e80:	76 24                	jbe    810ea6 <free+0x46>
  810e82:	c7 44 24 0c 14 44 81 	movl   $0x814414,0xc(%esp)
  810e89:	00 
  810e8a:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  810e91:	00 
  810e92:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  810e99:	00 
  810e9a:	c7 04 24 44 44 81 00 	movl   $0x814444,(%esp)
  810ea1:	e8 da df ff ff       	call   80ee80 <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  810ea6:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810eac:	eb 4a                	jmp    810ef8 <free+0x98>
		sys_page_unmap(0, c);
  810eae:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810eb2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810eb9:	e8 fe ea ff ff       	call   80f9bc <sys_page_unmap>
		c += PGSIZE;
  810ebe:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  810ec4:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  810eca:	76 08                	jbe    810ed4 <free+0x74>
  810ecc:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  810ed2:	76 24                	jbe    810ef8 <free+0x98>
  810ed4:	c7 44 24 0c 51 44 81 	movl   $0x814451,0xc(%esp)
  810edb:	00 
  810edc:	c7 44 24 08 17 31 81 	movl   $0x813117,0x8(%esp)
  810ee3:	00 
  810ee4:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  810eeb:	00 
  810eec:	c7 04 24 44 44 81 00 	movl   $0x814444,(%esp)
  810ef3:	e8 88 df ff ff       	call   80ee80 <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810ef8:	89 d8                	mov    %ebx,%eax
  810efa:	c1 e8 0c             	shr    $0xc,%eax
  810efd:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  810f04:	f6 c4 02             	test   $0x2,%ah
  810f07:	75 a5                	jne    810eae <free+0x4e>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  810f09:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  810f0f:	48                   	dec    %eax
  810f10:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  810f16:	85 c0                	test   %eax,%eax
  810f18:	75 10                	jne    810f2a <free+0xca>
		sys_page_unmap(0, c);
  810f1a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810f1e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810f25:	e8 92 ea ff ff       	call   80f9bc <sys_page_unmap>
}
  810f2a:	83 c4 14             	add    $0x14,%esp
  810f2d:	5b                   	pop    %ebx
  810f2e:	5d                   	pop    %ebp
  810f2f:	c3                   	ret    

00810f30 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  810f30:	55                   	push   %ebp
  810f31:	89 e5                	mov    %esp,%ebp
  810f33:	57                   	push   %edi
  810f34:	56                   	push   %esi
  810f35:	53                   	push   %ebx
  810f36:	83 ec 2c             	sub    $0x2c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  810f39:	83 3d 18 c2 b3 00 00 	cmpl   $0x0,0xb3c218
  810f40:	75 0a                	jne    810f4c <malloc+0x1c>
		mptr = mbegin;
  810f42:	c7 05 18 c2 b3 00 00 	movl   $0x8000000,0xb3c218
  810f49:	00 00 08 

	n = ROUNDUP(n, 4);
  810f4c:	8b 45 08             	mov    0x8(%ebp),%eax
  810f4f:	83 c0 03             	add    $0x3,%eax
  810f52:	83 e0 fc             	and    $0xfffffffc,%eax
  810f55:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (n >= MAXMALLOC)
  810f58:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  810f5d:	0f 87 6a 01 00 00    	ja     8110cd <malloc+0x19d>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  810f63:	a1 18 c2 b3 00       	mov    0xb3c218,%eax
  810f68:	89 c2                	mov    %eax,%edx
  810f6a:	a9 ff 0f 00 00       	test   $0xfff,%eax
  810f6f:	74 4d                	je     810fbe <malloc+0x8e>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  810f71:	89 c3                	mov    %eax,%ebx
  810f73:	c1 eb 0c             	shr    $0xc,%ebx
  810f76:	8b 75 e0             	mov    -0x20(%ebp),%esi
  810f79:	8d 4c 30 03          	lea    0x3(%eax,%esi,1),%ecx
  810f7d:	c1 e9 0c             	shr    $0xc,%ecx
  810f80:	39 cb                	cmp    %ecx,%ebx
  810f82:	75 1e                	jne    810fa2 <malloc+0x72>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  810f84:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
  810f8a:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  810f90:	ff 42 fc             	incl   -0x4(%edx)
			v = mptr;
			mptr += n;
  810f93:	89 f2                	mov    %esi,%edx
  810f95:	01 c2                	add    %eax,%edx
  810f97:	89 15 18 c2 b3 00    	mov    %edx,0xb3c218
			return v;
  810f9d:	e9 30 01 00 00       	jmp    8110d2 <malloc+0x1a2>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  810fa2:	89 04 24             	mov    %eax,(%esp)
  810fa5:	e8 b6 fe ff ff       	call   810e60 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810faa:	a1 18 c2 b3 00       	mov    0xb3c218,%eax
  810faf:	05 00 10 00 00       	add    $0x1000,%eax
  810fb4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810fb9:	a3 18 c2 b3 00       	mov    %eax,0xb3c218
  810fbe:	8b 1d 18 c2 b3 00    	mov    0xb3c218,%ebx
	return 1;
}

void*
malloc(size_t n)
{
  810fc4:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  810fcb:	8b 75 e0             	mov    -0x20(%ebp),%esi
  810fce:	83 c6 04             	add    $0x4,%esi
  810fd1:	eb 05                	jmp    810fd8 <malloc+0xa8>
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  810fd3:	bb 00 00 00 08       	mov    $0x8000000,%ebx
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810fd8:	89 df                	mov    %ebx,%edi
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  810fda:	89 75 e4             	mov    %esi,-0x1c(%ebp)
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;
  810fdd:	89 d8                	mov    %ebx,%eax
			return 0;
	return 1;
}

void*
malloc(size_t n)
  810fdf:	8d 0c 1e             	lea    (%esi,%ebx,1),%ecx
  810fe2:	eb 2e                	jmp    811012 <malloc+0xe2>
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  810fe4:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  810fe9:	77 30                	ja     81101b <malloc+0xeb>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810feb:	89 c2                	mov    %eax,%edx
  810fed:	c1 ea 16             	shr    $0x16,%edx
  810ff0:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  810ff7:	f6 c2 01             	test   $0x1,%dl
  810ffa:	74 11                	je     81100d <malloc+0xdd>
  810ffc:	89 c2                	mov    %eax,%edx
  810ffe:	c1 ea 0c             	shr    $0xc,%edx
  811001:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  811008:	f6 c2 01             	test   $0x1,%dl
  81100b:	75 0e                	jne    81101b <malloc+0xeb>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81100d:	05 00 10 00 00       	add    $0x1000,%eax
  811012:	39 c1                	cmp    %eax,%ecx
  811014:	77 ce                	ja     810fe4 <malloc+0xb4>
  811016:	e9 84 00 00 00       	jmp    81109f <malloc+0x16f>
  81101b:	81 c3 00 10 00 00    	add    $0x1000,%ebx
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  811021:	81 fb 00 00 00 10    	cmp    $0x10000000,%ebx
  811027:	75 af                	jne    810fd8 <malloc+0xa8>
			mptr = mbegin;
			if (++nwrap == 2)
  811029:	ff 4d dc             	decl   -0x24(%ebp)
  81102c:	75 a5                	jne    810fd3 <malloc+0xa3>
  81102e:	c7 05 18 c2 b3 00 00 	movl   $0x8000000,0xb3c218
  811035:	00 00 08 
				return 0;	/* out of address space */
  811038:	b8 00 00 00 00       	mov    $0x0,%eax
  81103d:	e9 90 00 00 00       	jmp    8110d2 <malloc+0x1a2>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  811042:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  811048:	39 fe                	cmp    %edi,%esi
  81104a:	19 c0                	sbb    %eax,%eax
  81104c:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  811051:	83 c8 07             	or     $0x7,%eax
  811054:	89 44 24 08          	mov    %eax,0x8(%esp)
  811058:	03 15 18 c2 b3 00    	add    0xb3c218,%edx
  81105e:	89 54 24 04          	mov    %edx,0x4(%esp)
  811062:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811069:	e8 a7 e8 ff ff       	call   80f915 <sys_page_alloc>
  81106e:	85 c0                	test   %eax,%eax
  811070:	78 22                	js     811094 <malloc+0x164>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  811072:	89 f3                	mov    %esi,%ebx
  811074:	eb 37                	jmp    8110ad <malloc+0x17d>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  811076:	89 d8                	mov    %ebx,%eax
  811078:	03 05 18 c2 b3 00    	add    0xb3c218,%eax
  81107e:	89 44 24 04          	mov    %eax,0x4(%esp)
  811082:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811089:	e8 2e e9 ff ff       	call   80f9bc <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  81108e:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  811094:	85 db                	test   %ebx,%ebx
  811096:	79 de                	jns    811076 <malloc+0x146>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  811098:	b8 00 00 00 00       	mov    $0x0,%eax
  81109d:	eb 33                	jmp    8110d2 <malloc+0x1a2>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  81109f:	89 3d 18 c2 b3 00    	mov    %edi,0xb3c218
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8110a5:	bb 00 00 00 00       	mov    $0x0,%ebx
  8110aa:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  8110ad:	89 da                	mov    %ebx,%edx
  8110af:	39 fb                	cmp    %edi,%ebx
  8110b1:	72 8f                	jb     811042 <malloc+0x112>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  8110b3:	a1 18 c2 b3 00       	mov    0xb3c218,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  8110b8:	c7 44 18 fc 02 00 00 	movl   $0x2,-0x4(%eax,%ebx,1)
  8110bf:	00 
	v = mptr;
	mptr += n;
  8110c0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8110c3:	01 c2                	add    %eax,%edx
  8110c5:	89 15 18 c2 b3 00    	mov    %edx,0xb3c218
	return v;
  8110cb:	eb 05                	jmp    8110d2 <malloc+0x1a2>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  8110cd:	b8 00 00 00 00       	mov    $0x0,%eax
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  8110d2:	83 c4 2c             	add    $0x2c,%esp
  8110d5:	5b                   	pop    %ebx
  8110d6:	5e                   	pop    %esi
  8110d7:	5f                   	pop    %edi
  8110d8:	5d                   	pop    %ebp
  8110d9:	c3                   	ret    
	...

008110dc <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8110dc:	55                   	push   %ebp
  8110dd:	89 e5                	mov    %esp,%ebp
  8110df:	56                   	push   %esi
  8110e0:	53                   	push   %ebx
  8110e1:	83 ec 10             	sub    $0x10,%esp
  8110e4:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8110e7:	8b 45 08             	mov    0x8(%ebp),%eax
  8110ea:	89 04 24             	mov    %eax,(%esp)
  8110ed:	e8 f2 ef ff ff       	call   8100e4 <fd2data>
  8110f2:	89 c3                	mov    %eax,%ebx
	strcpy(stat->st_name, "<pipe>");
  8110f4:	c7 44 24 04 69 44 81 	movl   $0x814469,0x4(%esp)
  8110fb:	00 
  8110fc:	89 34 24             	mov    %esi,(%esp)
  8110ff:	e8 1f e4 ff ff       	call   80f523 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  811104:	8b 43 04             	mov    0x4(%ebx),%eax
  811107:	2b 03                	sub    (%ebx),%eax
  811109:	89 86 80 00 00 00    	mov    %eax,0x80(%esi)
	stat->st_isdir = 0;
  81110f:	c7 86 84 00 00 00 00 	movl   $0x0,0x84(%esi)
  811116:	00 00 00 
	stat->st_dev = &devpipe;
  811119:	c7 86 88 00 00 00 24 	movl   $0x815324,0x88(%esi)
  811120:	53 81 00 
	return 0;
}
  811123:	b8 00 00 00 00       	mov    $0x0,%eax
  811128:	83 c4 10             	add    $0x10,%esp
  81112b:	5b                   	pop    %ebx
  81112c:	5e                   	pop    %esi
  81112d:	5d                   	pop    %ebp
  81112e:	c3                   	ret    

0081112f <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  81112f:	55                   	push   %ebp
  811130:	89 e5                	mov    %esp,%ebp
  811132:	53                   	push   %ebx
  811133:	83 ec 14             	sub    $0x14,%esp
  811136:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  811139:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81113d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811144:	e8 73 e8 ff ff       	call   80f9bc <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  811149:	89 1c 24             	mov    %ebx,(%esp)
  81114c:	e8 93 ef ff ff       	call   8100e4 <fd2data>
  811151:	89 44 24 04          	mov    %eax,0x4(%esp)
  811155:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81115c:	e8 5b e8 ff ff       	call   80f9bc <sys_page_unmap>
}
  811161:	83 c4 14             	add    $0x14,%esp
  811164:	5b                   	pop    %ebx
  811165:	5d                   	pop    %ebp
  811166:	c3                   	ret    

00811167 <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  811167:	55                   	push   %ebp
  811168:	89 e5                	mov    %esp,%ebp
  81116a:	57                   	push   %edi
  81116b:	56                   	push   %esi
  81116c:	53                   	push   %ebx
  81116d:	83 ec 2c             	sub    $0x2c,%esp
  811170:	89 c7                	mov    %eax,%edi
  811172:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  811175:	a1 9c c2 b3 00       	mov    0xb3c29c,%eax
  81117a:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  81117d:	89 3c 24             	mov    %edi,(%esp)
  811180:	e8 e3 04 00 00       	call   811668 <pageref>
  811185:	89 c6                	mov    %eax,%esi
  811187:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81118a:	89 04 24             	mov    %eax,(%esp)
  81118d:	e8 d6 04 00 00       	call   811668 <pageref>
  811192:	39 c6                	cmp    %eax,%esi
  811194:	0f 94 c0             	sete   %al
  811197:	0f b6 c0             	movzbl %al,%eax
		nn = thisenv->env_runs;
  81119a:	8b 15 9c c2 b3 00    	mov    0xb3c29c,%edx
  8111a0:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  8111a3:	39 cb                	cmp    %ecx,%ebx
  8111a5:	75 08                	jne    8111af <_pipeisclosed+0x48>
			return ret;
		if (n != nn && ret == 1)
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
	}
}
  8111a7:	83 c4 2c             	add    $0x2c,%esp
  8111aa:	5b                   	pop    %ebx
  8111ab:	5e                   	pop    %esi
  8111ac:	5f                   	pop    %edi
  8111ad:	5d                   	pop    %ebp
  8111ae:	c3                   	ret    
		n = thisenv->env_runs;
		ret = pageref(fd) == pageref(p);
		nn = thisenv->env_runs;
		if (n == nn)
			return ret;
		if (n != nn && ret == 1)
  8111af:	83 f8 01             	cmp    $0x1,%eax
  8111b2:	75 c1                	jne    811175 <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  8111b4:	8b 42 58             	mov    0x58(%edx),%eax
  8111b7:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  8111be:	00 
  8111bf:	89 44 24 08          	mov    %eax,0x8(%esp)
  8111c3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8111c7:	c7 04 24 70 44 81 00 	movl   $0x814470,(%esp)
  8111ce:	e8 a5 dd ff ff       	call   80ef78 <cprintf>
  8111d3:	eb a0                	jmp    811175 <_pipeisclosed+0xe>

008111d5 <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8111d5:	55                   	push   %ebp
  8111d6:	89 e5                	mov    %esp,%ebp
  8111d8:	57                   	push   %edi
  8111d9:	56                   	push   %esi
  8111da:	53                   	push   %ebx
  8111db:	83 ec 1c             	sub    $0x1c,%esp
  8111de:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  8111e1:	89 34 24             	mov    %esi,(%esp)
  8111e4:	e8 fb ee ff ff       	call   8100e4 <fd2data>
  8111e9:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8111eb:	bf 00 00 00 00       	mov    $0x0,%edi
  8111f0:	eb 3c                	jmp    81122e <devpipe_write+0x59>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  8111f2:	89 da                	mov    %ebx,%edx
  8111f4:	89 f0                	mov    %esi,%eax
  8111f6:	e8 6c ff ff ff       	call   811167 <_pipeisclosed>
  8111fb:	85 c0                	test   %eax,%eax
  8111fd:	75 38                	jne    811237 <devpipe_write+0x62>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  8111ff:	e8 f2 e6 ff ff       	call   80f8f6 <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  811204:	8b 43 04             	mov    0x4(%ebx),%eax
  811207:	8b 13                	mov    (%ebx),%edx
  811209:	83 c2 20             	add    $0x20,%edx
  81120c:	39 d0                	cmp    %edx,%eax
  81120e:	73 e2                	jae    8111f2 <devpipe_write+0x1d>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  811210:	8b 55 0c             	mov    0xc(%ebp),%edx
  811213:	8a 0c 3a             	mov    (%edx,%edi,1),%cl
  811216:	89 c2                	mov    %eax,%edx
  811218:	81 e2 1f 00 00 80    	and    $0x8000001f,%edx
  81121e:	79 05                	jns    811225 <devpipe_write+0x50>
  811220:	4a                   	dec    %edx
  811221:	83 ca e0             	or     $0xffffffe0,%edx
  811224:	42                   	inc    %edx
  811225:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  811229:	40                   	inc    %eax
  81122a:	89 43 04             	mov    %eax,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  81122d:	47                   	inc    %edi
  81122e:	3b 7d 10             	cmp    0x10(%ebp),%edi
  811231:	75 d1                	jne    811204 <devpipe_write+0x2f>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  811233:	89 f8                	mov    %edi,%eax
  811235:	eb 05                	jmp    81123c <devpipe_write+0x67>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
				return 0;
  811237:	b8 00 00 00 00       	mov    $0x0,%eax
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
}
  81123c:	83 c4 1c             	add    $0x1c,%esp
  81123f:	5b                   	pop    %ebx
  811240:	5e                   	pop    %esi
  811241:	5f                   	pop    %edi
  811242:	5d                   	pop    %ebp
  811243:	c3                   	ret    

00811244 <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  811244:	55                   	push   %ebp
  811245:	89 e5                	mov    %esp,%ebp
  811247:	57                   	push   %edi
  811248:	56                   	push   %esi
  811249:	53                   	push   %ebx
  81124a:	83 ec 1c             	sub    $0x1c,%esp
  81124d:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  811250:	89 3c 24             	mov    %edi,(%esp)
  811253:	e8 8c ee ff ff       	call   8100e4 <fd2data>
  811258:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  81125a:	be 00 00 00 00       	mov    $0x0,%esi
  81125f:	eb 3a                	jmp    81129b <devpipe_read+0x57>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  811261:	85 f6                	test   %esi,%esi
  811263:	74 04                	je     811269 <devpipe_read+0x25>
				return i;
  811265:	89 f0                	mov    %esi,%eax
  811267:	eb 40                	jmp    8112a9 <devpipe_read+0x65>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  811269:	89 da                	mov    %ebx,%edx
  81126b:	89 f8                	mov    %edi,%eax
  81126d:	e8 f5 fe ff ff       	call   811167 <_pipeisclosed>
  811272:	85 c0                	test   %eax,%eax
  811274:	75 2e                	jne    8112a4 <devpipe_read+0x60>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  811276:	e8 7b e6 ff ff       	call   80f8f6 <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  81127b:	8b 03                	mov    (%ebx),%eax
  81127d:	3b 43 04             	cmp    0x4(%ebx),%eax
  811280:	74 df                	je     811261 <devpipe_read+0x1d>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  811282:	25 1f 00 00 80       	and    $0x8000001f,%eax
  811287:	79 05                	jns    81128e <devpipe_read+0x4a>
  811289:	48                   	dec    %eax
  81128a:	83 c8 e0             	or     $0xffffffe0,%eax
  81128d:	40                   	inc    %eax
  81128e:	8a 44 03 08          	mov    0x8(%ebx,%eax,1),%al
  811292:	8b 55 0c             	mov    0xc(%ebp),%edx
  811295:	88 04 32             	mov    %al,(%edx,%esi,1)
		p->p_rpos++;
  811298:	ff 03                	incl   (%ebx)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  81129a:	46                   	inc    %esi
  81129b:	3b 75 10             	cmp    0x10(%ebp),%esi
  81129e:	75 db                	jne    81127b <devpipe_read+0x37>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  8112a0:	89 f0                	mov    %esi,%eax
  8112a2:	eb 05                	jmp    8112a9 <devpipe_read+0x65>
			// if we got any data, return it
			if (i > 0)
				return i;
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
				return 0;
  8112a4:	b8 00 00 00 00       	mov    $0x0,%eax
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
}
  8112a9:	83 c4 1c             	add    $0x1c,%esp
  8112ac:	5b                   	pop    %ebx
  8112ad:	5e                   	pop    %esi
  8112ae:	5f                   	pop    %edi
  8112af:	5d                   	pop    %ebp
  8112b0:	c3                   	ret    

008112b1 <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  8112b1:	55                   	push   %ebp
  8112b2:	89 e5                	mov    %esp,%ebp
  8112b4:	57                   	push   %edi
  8112b5:	56                   	push   %esi
  8112b6:	53                   	push   %ebx
  8112b7:	83 ec 3c             	sub    $0x3c,%esp
  8112ba:	8b 7d 08             	mov    0x8(%ebp),%edi
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  8112bd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8112c0:	89 04 24             	mov    %eax,(%esp)
  8112c3:	e8 37 ee ff ff       	call   8100ff <fd_alloc>
  8112c8:	89 c3                	mov    %eax,%ebx
  8112ca:	85 c0                	test   %eax,%eax
  8112cc:	0f 88 45 01 00 00    	js     811417 <pipe+0x166>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8112d2:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  8112d9:	00 
  8112da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8112dd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8112e1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8112e8:	e8 28 e6 ff ff       	call   80f915 <sys_page_alloc>
  8112ed:	89 c3                	mov    %eax,%ebx
  8112ef:	85 c0                	test   %eax,%eax
  8112f1:	0f 88 20 01 00 00    	js     811417 <pipe+0x166>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  8112f7:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8112fa:	89 04 24             	mov    %eax,(%esp)
  8112fd:	e8 fd ed ff ff       	call   8100ff <fd_alloc>
  811302:	89 c3                	mov    %eax,%ebx
  811304:	85 c0                	test   %eax,%eax
  811306:	0f 88 f8 00 00 00    	js     811404 <pipe+0x153>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  81130c:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  811313:	00 
  811314:	8b 45 e0             	mov    -0x20(%ebp),%eax
  811317:	89 44 24 04          	mov    %eax,0x4(%esp)
  81131b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811322:	e8 ee e5 ff ff       	call   80f915 <sys_page_alloc>
  811327:	89 c3                	mov    %eax,%ebx
  811329:	85 c0                	test   %eax,%eax
  81132b:	0f 88 d3 00 00 00    	js     811404 <pipe+0x153>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  811331:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811334:	89 04 24             	mov    %eax,(%esp)
  811337:	e8 a8 ed ff ff       	call   8100e4 <fd2data>
  81133c:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  81133e:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  811345:	00 
  811346:	89 44 24 04          	mov    %eax,0x4(%esp)
  81134a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811351:	e8 bf e5 ff ff       	call   80f915 <sys_page_alloc>
  811356:	89 c3                	mov    %eax,%ebx
  811358:	85 c0                	test   %eax,%eax
  81135a:	0f 88 91 00 00 00    	js     8113f1 <pipe+0x140>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  811360:	8b 45 e0             	mov    -0x20(%ebp),%eax
  811363:	89 04 24             	mov    %eax,(%esp)
  811366:	e8 79 ed ff ff       	call   8100e4 <fd2data>
  81136b:	c7 44 24 10 07 04 00 	movl   $0x407,0x10(%esp)
  811372:	00 
  811373:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811377:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81137e:	00 
  81137f:	89 74 24 04          	mov    %esi,0x4(%esp)
  811383:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81138a:	e8 da e5 ff ff       	call   80f969 <sys_page_map>
  81138f:	89 c3                	mov    %eax,%ebx
  811391:	85 c0                	test   %eax,%eax
  811393:	78 4c                	js     8113e1 <pipe+0x130>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  811395:	8b 15 24 53 81 00    	mov    0x815324,%edx
  81139b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81139e:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  8113a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8113a3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  8113aa:	8b 15 24 53 81 00    	mov    0x815324,%edx
  8113b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8113b3:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  8113b5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8113b8:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  8113bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8113c2:	89 04 24             	mov    %eax,(%esp)
  8113c5:	e8 0a ed ff ff       	call   8100d4 <fd2num>
  8113ca:	89 07                	mov    %eax,(%edi)
	pfd[1] = fd2num(fd1);
  8113cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8113cf:	89 04 24             	mov    %eax,(%esp)
  8113d2:	e8 fd ec ff ff       	call   8100d4 <fd2num>
  8113d7:	89 47 04             	mov    %eax,0x4(%edi)
	return 0;
  8113da:	bb 00 00 00 00       	mov    $0x0,%ebx
  8113df:	eb 36                	jmp    811417 <pipe+0x166>

    err3:
	sys_page_unmap(0, va);
  8113e1:	89 74 24 04          	mov    %esi,0x4(%esp)
  8113e5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8113ec:	e8 cb e5 ff ff       	call   80f9bc <sys_page_unmap>
    err2:
	sys_page_unmap(0, fd1);
  8113f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8113f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8113f8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8113ff:	e8 b8 e5 ff ff       	call   80f9bc <sys_page_unmap>
    err1:
	sys_page_unmap(0, fd0);
  811404:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811407:	89 44 24 04          	mov    %eax,0x4(%esp)
  81140b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811412:	e8 a5 e5 ff ff       	call   80f9bc <sys_page_unmap>
    err:
	return r;
}
  811417:	89 d8                	mov    %ebx,%eax
  811419:	83 c4 3c             	add    $0x3c,%esp
  81141c:	5b                   	pop    %ebx
  81141d:	5e                   	pop    %esi
  81141e:	5f                   	pop    %edi
  81141f:	5d                   	pop    %ebp
  811420:	c3                   	ret    

00811421 <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  811421:	55                   	push   %ebp
  811422:	89 e5                	mov    %esp,%ebp
  811424:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  811427:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81142a:	89 44 24 04          	mov    %eax,0x4(%esp)
  81142e:	8b 45 08             	mov    0x8(%ebp),%eax
  811431:	89 04 24             	mov    %eax,(%esp)
  811434:	e8 19 ed ff ff       	call   810152 <fd_lookup>
  811439:	85 c0                	test   %eax,%eax
  81143b:	78 15                	js     811452 <pipeisclosed+0x31>
		return r;
	p = (struct Pipe*) fd2data(fd);
  81143d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811440:	89 04 24             	mov    %eax,(%esp)
  811443:	e8 9c ec ff ff       	call   8100e4 <fd2data>
	return _pipeisclosed(fd, p);
  811448:	89 c2                	mov    %eax,%edx
  81144a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81144d:	e8 15 fd ff ff       	call   811167 <_pipeisclosed>
}
  811452:	c9                   	leave  
  811453:	c3                   	ret    

00811454 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  811454:	55                   	push   %ebp
  811455:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  811457:	b8 00 00 00 00       	mov    $0x0,%eax
  81145c:	5d                   	pop    %ebp
  81145d:	c3                   	ret    

0081145e <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  81145e:	55                   	push   %ebp
  81145f:	89 e5                	mov    %esp,%ebp
  811461:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<cons>");
  811464:	c7 44 24 04 88 44 81 	movl   $0x814488,0x4(%esp)
  81146b:	00 
  81146c:	8b 45 0c             	mov    0xc(%ebp),%eax
  81146f:	89 04 24             	mov    %eax,(%esp)
  811472:	e8 ac e0 ff ff       	call   80f523 <strcpy>
	return 0;
}
  811477:	b8 00 00 00 00       	mov    $0x0,%eax
  81147c:	c9                   	leave  
  81147d:	c3                   	ret    

0081147e <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  81147e:	55                   	push   %ebp
  81147f:	89 e5                	mov    %esp,%ebp
  811481:	57                   	push   %edi
  811482:	56                   	push   %esi
  811483:	53                   	push   %ebx
  811484:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  81148a:	bb 00 00 00 00       	mov    $0x0,%ebx
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  81148f:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  811495:	eb 30                	jmp    8114c7 <devcons_write+0x49>
		m = n - tot;
  811497:	8b 75 10             	mov    0x10(%ebp),%esi
  81149a:	29 de                	sub    %ebx,%esi
		if (m > sizeof(buf) - 1)
  81149c:	83 fe 7f             	cmp    $0x7f,%esi
  81149f:	76 05                	jbe    8114a6 <devcons_write+0x28>
			m = sizeof(buf) - 1;
  8114a1:	be 7f 00 00 00       	mov    $0x7f,%esi
		memmove(buf, (char*)vbuf + tot, m);
  8114a6:	89 74 24 08          	mov    %esi,0x8(%esp)
  8114aa:	03 45 0c             	add    0xc(%ebp),%eax
  8114ad:	89 44 24 04          	mov    %eax,0x4(%esp)
  8114b1:	89 3c 24             	mov    %edi,(%esp)
  8114b4:	e8 e3 e1 ff ff       	call   80f69c <memmove>
		sys_cputs(buf, m);
  8114b9:	89 74 24 04          	mov    %esi,0x4(%esp)
  8114bd:	89 3c 24             	mov    %edi,(%esp)
  8114c0:	e8 83 e3 ff ff       	call   80f848 <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8114c5:	01 f3                	add    %esi,%ebx
  8114c7:	89 d8                	mov    %ebx,%eax
  8114c9:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  8114cc:	72 c9                	jb     811497 <devcons_write+0x19>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  8114ce:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  8114d4:	5b                   	pop    %ebx
  8114d5:	5e                   	pop    %esi
  8114d6:	5f                   	pop    %edi
  8114d7:	5d                   	pop    %ebp
  8114d8:	c3                   	ret    

008114d9 <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  8114d9:	55                   	push   %ebp
  8114da:	89 e5                	mov    %esp,%ebp
  8114dc:	83 ec 08             	sub    $0x8,%esp
	int c;

	if (n == 0)
  8114df:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8114e3:	75 07                	jne    8114ec <devcons_read+0x13>
  8114e5:	eb 25                	jmp    81150c <devcons_read+0x33>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  8114e7:	e8 0a e4 ff ff       	call   80f8f6 <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8114ec:	e8 75 e3 ff ff       	call   80f866 <sys_cgetc>
  8114f1:	85 c0                	test   %eax,%eax
  8114f3:	74 f2                	je     8114e7 <devcons_read+0xe>
  8114f5:	89 c2                	mov    %eax,%edx
		sys_yield();
	if (c < 0)
  8114f7:	85 c0                	test   %eax,%eax
  8114f9:	78 1d                	js     811518 <devcons_read+0x3f>
		return c;
	if (c == 0x04)	// ctl-d is eof
  8114fb:	83 f8 04             	cmp    $0x4,%eax
  8114fe:	74 13                	je     811513 <devcons_read+0x3a>
		return 0;
	*(char*)vbuf = c;
  811500:	8b 45 0c             	mov    0xc(%ebp),%eax
  811503:	88 10                	mov    %dl,(%eax)
	return 1;
  811505:	b8 01 00 00 00       	mov    $0x1,%eax
  81150a:	eb 0c                	jmp    811518 <devcons_read+0x3f>
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
	int c;

	if (n == 0)
		return 0;
  81150c:	b8 00 00 00 00       	mov    $0x0,%eax
  811511:	eb 05                	jmp    811518 <devcons_read+0x3f>
	while ((c = sys_cgetc()) == 0)
		sys_yield();
	if (c < 0)
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  811513:	b8 00 00 00 00       	mov    $0x0,%eax
	*(char*)vbuf = c;
	return 1;
}
  811518:	c9                   	leave  
  811519:	c3                   	ret    

0081151a <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  81151a:	55                   	push   %ebp
  81151b:	89 e5                	mov    %esp,%ebp
  81151d:	83 ec 28             	sub    $0x28,%esp
	char c = ch;
  811520:	8b 45 08             	mov    0x8(%ebp),%eax
  811523:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  811526:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  81152d:	00 
  81152e:	8d 45 f7             	lea    -0x9(%ebp),%eax
  811531:	89 04 24             	mov    %eax,(%esp)
  811534:	e8 0f e3 ff ff       	call   80f848 <sys_cputs>
}
  811539:	c9                   	leave  
  81153a:	c3                   	ret    

0081153b <getchar>:

int
getchar(void)
{
  81153b:	55                   	push   %ebp
  81153c:	89 e5                	mov    %esp,%ebp
  81153e:	83 ec 28             	sub    $0x28,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  811541:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  811548:	00 
  811549:	8d 45 f7             	lea    -0x9(%ebp),%eax
  81154c:	89 44 24 04          	mov    %eax,0x4(%esp)
  811550:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811557:	e8 94 ee ff ff       	call   8103f0 <read>
	if (r < 0)
  81155c:	85 c0                	test   %eax,%eax
  81155e:	78 0f                	js     81156f <getchar+0x34>
		return r;
	if (r < 1)
  811560:	85 c0                	test   %eax,%eax
  811562:	7e 06                	jle    81156a <getchar+0x2f>
		return -E_EOF;
	return c;
  811564:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  811568:	eb 05                	jmp    81156f <getchar+0x34>
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
	if (r < 0)
		return r;
	if (r < 1)
		return -E_EOF;
  81156a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	return c;
}
  81156f:	c9                   	leave  
  811570:	c3                   	ret    

00811571 <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  811571:	55                   	push   %ebp
  811572:	89 e5                	mov    %esp,%ebp
  811574:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  811577:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81157a:	89 44 24 04          	mov    %eax,0x4(%esp)
  81157e:	8b 45 08             	mov    0x8(%ebp),%eax
  811581:	89 04 24             	mov    %eax,(%esp)
  811584:	e8 c9 eb ff ff       	call   810152 <fd_lookup>
  811589:	85 c0                	test   %eax,%eax
  81158b:	78 11                	js     81159e <iscons+0x2d>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  81158d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811590:	8b 15 40 53 81 00    	mov    0x815340,%edx
  811596:	39 10                	cmp    %edx,(%eax)
  811598:	0f 94 c0             	sete   %al
  81159b:	0f b6 c0             	movzbl %al,%eax
}
  81159e:	c9                   	leave  
  81159f:	c3                   	ret    

008115a0 <opencons>:

int
opencons(void)
{
  8115a0:	55                   	push   %ebp
  8115a1:	89 e5                	mov    %esp,%ebp
  8115a3:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  8115a6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8115a9:	89 04 24             	mov    %eax,(%esp)
  8115ac:	e8 4e eb ff ff       	call   8100ff <fd_alloc>
  8115b1:	85 c0                	test   %eax,%eax
  8115b3:	78 3c                	js     8115f1 <opencons+0x51>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8115b5:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  8115bc:	00 
  8115bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8115c0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8115c4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8115cb:	e8 45 e3 ff ff       	call   80f915 <sys_page_alloc>
  8115d0:	85 c0                	test   %eax,%eax
  8115d2:	78 1d                	js     8115f1 <opencons+0x51>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  8115d4:	8b 15 40 53 81 00    	mov    0x815340,%edx
  8115da:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8115dd:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  8115df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8115e2:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  8115e9:	89 04 24             	mov    %eax,(%esp)
  8115ec:	e8 e3 ea ff ff       	call   8100d4 <fd2num>
}
  8115f1:	c9                   	leave  
  8115f2:	c3                   	ret    
	...

008115f4 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  8115f4:	55                   	push   %ebp
  8115f5:	89 e5                	mov    %esp,%ebp
  8115f7:	83 ec 18             	sub    $0x18,%esp
	int r;

	if (_pgfault_handler == 0) {
  8115fa:	83 3d 00 f0 b3 00 00 	cmpl   $0x0,0xb3f000
  811601:	75 30                	jne    811633 <set_pgfault_handler+0x3f>
		// First time through!
		// LAB 4: Your code here.
		sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_W | PTE_U | PTE_P);
  811603:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  81160a:	00 
  81160b:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  811612:	ee 
  811613:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81161a:	e8 f6 e2 ff ff       	call   80f915 <sys_page_alloc>
		sys_env_set_pgfault_upcall(0,_pgfault_upcall);
  81161f:	c7 44 24 04 40 16 81 	movl   $0x811640,0x4(%esp)
  811626:	00 
  811627:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81162e:	e8 82 e4 ff ff       	call   80fab5 <sys_env_set_pgfault_upcall>
		// panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  811633:	8b 45 08             	mov    0x8(%ebp),%eax
  811636:	a3 00 f0 b3 00       	mov    %eax,0xb3f000
}
  81163b:	c9                   	leave  
  81163c:	c3                   	ret    
  81163d:	00 00                	add    %al,(%eax)
	...

00811640 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  811640:	54                   	push   %esp
	movl _pgfault_handler, %eax
  811641:	a1 00 f0 b3 00       	mov    0xb3f000,%eax
	call *%eax
  811646:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  811648:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	movl 0x28(%esp),%eax 
  81164b:	8b 44 24 28          	mov    0x28(%esp),%eax
	movl 0x30(%esp),%ebx
  81164f:	8b 5c 24 30          	mov    0x30(%esp),%ebx
	subl $4,%ebx
  811653:	83 eb 04             	sub    $0x4,%ebx
	movl %eax,(%ebx)
  811656:	89 03                	mov    %eax,(%ebx)
	movl %ebx,0x30(%esp)
  811658:	89 5c 24 30          	mov    %ebx,0x30(%esp)

	addl $8,%esp 
  81165c:	83 c4 08             	add    $0x8,%esp
	popal
  81165f:	61                   	popa   

	addl $4,%esp 
  811660:	83 c4 04             	add    $0x4,%esp
	popfl
  811663:	9d                   	popf   

	popl %esp
  811664:	5c                   	pop    %esp

	ret
  811665:	c3                   	ret    
	...

00811668 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  811668:	55                   	push   %ebp
  811669:	89 e5                	mov    %esp,%ebp
  81166b:	8b 45 08             	mov    0x8(%ebp),%eax
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  81166e:	89 c2                	mov    %eax,%edx
  811670:	c1 ea 16             	shr    $0x16,%edx
  811673:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  81167a:	f6 c2 01             	test   $0x1,%dl
  81167d:	74 1e                	je     81169d <pageref+0x35>
		return 0;
	pte = uvpt[PGNUM(v)];
  81167f:	c1 e8 0c             	shr    $0xc,%eax
  811682:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if (!(pte & PTE_P))
  811689:	a8 01                	test   $0x1,%al
  81168b:	74 17                	je     8116a4 <pageref+0x3c>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  81168d:	c1 e8 0c             	shr    $0xc,%eax
  811690:	66 8b 04 c5 04 00 00 	mov    -0x10fffffc(,%eax,8),%ax
  811697:	ef 
  811698:	0f b7 c0             	movzwl %ax,%eax
  81169b:	eb 0c                	jmp    8116a9 <pageref+0x41>
pageref(void *v)
{
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
		return 0;
  81169d:	b8 00 00 00 00       	mov    $0x0,%eax
  8116a2:	eb 05                	jmp    8116a9 <pageref+0x41>
	pte = uvpt[PGNUM(v)];
	if (!(pte & PTE_P))
		return 0;
  8116a4:	b8 00 00 00 00       	mov    $0x0,%eax
	return pages[PGNUM(pte)].pp_ref;
}
  8116a9:	5d                   	pop    %ebp
  8116aa:	c3                   	ret    
	...

008116ac <__udivdi3>:
#endif

#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  8116ac:	55                   	push   %ebp
  8116ad:	57                   	push   %edi
  8116ae:	56                   	push   %esi
  8116af:	83 ec 10             	sub    $0x10,%esp
  8116b2:	8b 74 24 20          	mov    0x20(%esp),%esi
  8116b6:	8b 4c 24 28          	mov    0x28(%esp),%ecx
static inline __attribute__ ((__always_inline__))
#endif
UDWtype
__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
{
  const DWunion nn = {.ll = n};
  8116ba:	89 74 24 04          	mov    %esi,0x4(%esp)
  8116be:	8b 7c 24 24          	mov    0x24(%esp),%edi
  const DWunion dd = {.ll = d};
  8116c2:	89 cd                	mov    %ecx,%ebp
  8116c4:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  d1 = dd.s.high;
  n0 = nn.s.low;
  n1 = nn.s.high;

#if !UDIV_NEEDS_NORMALIZATION
  if (d1 == 0)
  8116c8:	85 c0                	test   %eax,%eax
  8116ca:	75 2c                	jne    8116f8 <__udivdi3+0x4c>
    {
      if (d0 > n1)
  8116cc:	39 f9                	cmp    %edi,%ecx
  8116ce:	77 68                	ja     811738 <__udivdi3+0x8c>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
  8116d0:	85 c9                	test   %ecx,%ecx
  8116d2:	75 0b                	jne    8116df <__udivdi3+0x33>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
  8116d4:	b8 01 00 00 00       	mov    $0x1,%eax
  8116d9:	31 d2                	xor    %edx,%edx
  8116db:	f7 f1                	div    %ecx
  8116dd:	89 c1                	mov    %eax,%ecx

	  udiv_qrnnd (q1, n1, 0, n1, d0);
  8116df:	31 d2                	xor    %edx,%edx
  8116e1:	89 f8                	mov    %edi,%eax
  8116e3:	f7 f1                	div    %ecx
  8116e5:	89 c7                	mov    %eax,%edi
	  udiv_qrnnd (q0, n0, n1, n0, d0);
  8116e7:	89 f0                	mov    %esi,%eax
  8116e9:	f7 f1                	div    %ecx
  8116eb:	89 c6                	mov    %eax,%esi
		}
	    }
	}
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  8116ed:	89 f0                	mov    %esi,%eax
  8116ef:	89 fa                	mov    %edi,%edx
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
  8116f1:	83 c4 10             	add    $0x10,%esp
  8116f4:	5e                   	pop    %esi
  8116f5:	5f                   	pop    %edi
  8116f6:	5d                   	pop    %ebp
  8116f7:	c3                   	ret    
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
  8116f8:	39 f8                	cmp    %edi,%eax
  8116fa:	77 2c                	ja     811728 <__udivdi3+0x7c>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
  8116fc:	0f bd f0             	bsr    %eax,%esi
	  if (bm == 0)
  8116ff:	83 f6 1f             	xor    $0x1f,%esi
  811702:	75 4c                	jne    811750 <__udivdi3+0xa4>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
  811704:	39 f8                	cmp    %edi,%eax
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
  811706:	bf 00 00 00 00       	mov    $0x0,%edi

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
  81170b:	72 0a                	jb     811717 <__udivdi3+0x6b>
  81170d:	3b 4c 24 04          	cmp    0x4(%esp),%ecx
  811711:	0f 87 ad 00 00 00    	ja     8117c4 <__udivdi3+0x118>
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
  811717:	be 01 00 00 00       	mov    $0x1,%esi
		}
	    }
	}
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  81171c:	89 f0                	mov    %esi,%eax
  81171e:	89 fa                	mov    %edi,%edx
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
  811720:	83 c4 10             	add    $0x10,%esp
  811723:	5e                   	pop    %esi
  811724:	5f                   	pop    %edi
  811725:	5d                   	pop    %ebp
  811726:	c3                   	ret    
  811727:	90                   	nop
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
  811728:	31 ff                	xor    %edi,%edi
  81172a:	31 f6                	xor    %esi,%esi
		}
	    }
	}
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  81172c:	89 f0                	mov    %esi,%eax
  81172e:	89 fa                	mov    %edi,%edx
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
  811730:	83 c4 10             	add    $0x10,%esp
  811733:	5e                   	pop    %esi
  811734:	5f                   	pop    %edi
  811735:	5d                   	pop    %ebp
  811736:	c3                   	ret    
  811737:	90                   	nop
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
  811738:	89 fa                	mov    %edi,%edx
  81173a:	89 f0                	mov    %esi,%eax
  81173c:	f7 f1                	div    %ecx
  81173e:	89 c6                	mov    %eax,%esi
  811740:	31 ff                	xor    %edi,%edi
		}
	    }
	}
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  811742:	89 f0                	mov    %esi,%eax
  811744:	89 fa                	mov    %edi,%edx
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
  811746:	83 c4 10             	add    $0x10,%esp
  811749:	5e                   	pop    %esi
  81174a:	5f                   	pop    %edi
  81174b:	5d                   	pop    %ebp
  81174c:	c3                   	ret    
  81174d:	8d 76 00             	lea    0x0(%esi),%esi
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
  811750:	89 f1                	mov    %esi,%ecx
  811752:	d3 e0                	shl    %cl,%eax
  811754:	89 44 24 0c          	mov    %eax,0xc(%esp)
	  else
	    {
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
  811758:	b8 20 00 00 00       	mov    $0x20,%eax
  81175d:	29 f0                	sub    %esi,%eax

	      d1 = (d1 << bm) | (d0 >> b);
  81175f:	89 ea                	mov    %ebp,%edx
  811761:	88 c1                	mov    %al,%cl
  811763:	d3 ea                	shr    %cl,%edx
  811765:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  811769:	09 ca                	or     %ecx,%edx
  81176b:	89 54 24 08          	mov    %edx,0x8(%esp)
	      d0 = d0 << bm;
  81176f:	89 f1                	mov    %esi,%ecx
  811771:	d3 e5                	shl    %cl,%ebp
  811773:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
	      n2 = n1 >> b;
  811777:	89 fd                	mov    %edi,%ebp
  811779:	88 c1                	mov    %al,%cl
  81177b:	d3 ed                	shr    %cl,%ebp
	      n1 = (n1 << bm) | (n0 >> b);
  81177d:	89 fa                	mov    %edi,%edx
  81177f:	89 f1                	mov    %esi,%ecx
  811781:	d3 e2                	shl    %cl,%edx
  811783:	8b 7c 24 04          	mov    0x4(%esp),%edi
  811787:	88 c1                	mov    %al,%cl
  811789:	d3 ef                	shr    %cl,%edi
  81178b:	09 d7                	or     %edx,%edi
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
  81178d:	89 f8                	mov    %edi,%eax
  81178f:	89 ea                	mov    %ebp,%edx
  811791:	f7 74 24 08          	divl   0x8(%esp)
  811795:	89 d1                	mov    %edx,%ecx
  811797:	89 c7                	mov    %eax,%edi
	      umul_ppmm (m1, m0, q0, d0);
  811799:	f7 64 24 0c          	mull   0xc(%esp)

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  81179d:	39 d1                	cmp    %edx,%ecx
  81179f:	72 17                	jb     8117b8 <__udivdi3+0x10c>
  8117a1:	74 09                	je     8117ac <__udivdi3+0x100>
  8117a3:	89 fe                	mov    %edi,%esi
  8117a5:	31 ff                	xor    %edi,%edi
  8117a7:	e9 41 ff ff ff       	jmp    8116ed <__udivdi3+0x41>

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
  8117ac:	8b 54 24 04          	mov    0x4(%esp),%edx
  8117b0:	89 f1                	mov    %esi,%ecx
  8117b2:	d3 e2                	shl    %cl,%edx

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  8117b4:	39 c2                	cmp    %eax,%edx
  8117b6:	73 eb                	jae    8117a3 <__udivdi3+0xf7>
		{
		  q0--;
  8117b8:	8d 77 ff             	lea    -0x1(%edi),%esi
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
  8117bb:	31 ff                	xor    %edi,%edi
  8117bd:	e9 2b ff ff ff       	jmp    8116ed <__udivdi3+0x41>
  8117c2:	66 90                	xchg   %ax,%ax

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
  8117c4:	31 f6                	xor    %esi,%esi
  8117c6:	e9 22 ff ff ff       	jmp    8116ed <__udivdi3+0x41>
	...

008117cc <__umoddi3>:
#endif

#ifdef L_umoddi3
UDWtype
__umoddi3 (UDWtype u, UDWtype v)
{
  8117cc:	55                   	push   %ebp
  8117cd:	57                   	push   %edi
  8117ce:	56                   	push   %esi
  8117cf:	83 ec 20             	sub    $0x20,%esp
  8117d2:	8b 44 24 30          	mov    0x30(%esp),%eax
  8117d6:	8b 4c 24 38          	mov    0x38(%esp),%ecx
static inline __attribute__ ((__always_inline__))
#endif
UDWtype
__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
{
  const DWunion nn = {.ll = n};
  8117da:	89 44 24 14          	mov    %eax,0x14(%esp)
  8117de:	8b 74 24 34          	mov    0x34(%esp),%esi
  const DWunion dd = {.ll = d};
  8117e2:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  8117e6:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
  d1 = dd.s.high;
  n0 = nn.s.low;
  8117ea:	89 c7                	mov    %eax,%edi
  n1 = nn.s.high;
  8117ec:	89 f2                	mov    %esi,%edx

#if !UDIV_NEEDS_NORMALIZATION
  if (d1 == 0)
  8117ee:	85 ed                	test   %ebp,%ebp
  8117f0:	75 16                	jne    811808 <__umoddi3+0x3c>
    {
      if (d0 > n1)
  8117f2:	39 f1                	cmp    %esi,%ecx
  8117f4:	0f 86 a6 00 00 00    	jbe    8118a0 <__umoddi3+0xd4>

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  udiv_qrnnd (q1, n1, 0, n1, d0);
	  udiv_qrnnd (q0, n0, n1, n0, d0);
  8117fa:	f7 f1                	div    %ecx

      if (rp != 0)
	{
	  rr.s.low = n0;
	  rr.s.high = 0;
	  *rp = rr.ll;
  8117fc:	89 d0                	mov    %edx,%eax
  8117fe:	31 d2                	xor    %edx,%edx
  UDWtype w;

  (void) __udivmoddi4 (u, v, &w);

  return w;
}
  811800:	83 c4 20             	add    $0x20,%esp
  811803:	5e                   	pop    %esi
  811804:	5f                   	pop    %edi
  811805:	5d                   	pop    %ebp
  811806:	c3                   	ret    
  811807:	90                   	nop
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
  811808:	39 f5                	cmp    %esi,%ebp
  81180a:	0f 87 ac 00 00 00    	ja     8118bc <__umoddi3+0xf0>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
  811810:	0f bd c5             	bsr    %ebp,%eax
	  if (bm == 0)
  811813:	83 f0 1f             	xor    $0x1f,%eax
  811816:	89 44 24 10          	mov    %eax,0x10(%esp)
  81181a:	0f 84 a8 00 00 00    	je     8118c8 <__umoddi3+0xfc>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
  811820:	8a 4c 24 10          	mov    0x10(%esp),%cl
  811824:	d3 e5                	shl    %cl,%ebp
	  else
	    {
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
  811826:	bf 20 00 00 00       	mov    $0x20,%edi
  81182b:	2b 7c 24 10          	sub    0x10(%esp),%edi

	      d1 = (d1 << bm) | (d0 >> b);
  81182f:	8b 44 24 0c          	mov    0xc(%esp),%eax
  811833:	89 f9                	mov    %edi,%ecx
  811835:	d3 e8                	shr    %cl,%eax
  811837:	09 e8                	or     %ebp,%eax
  811839:	89 44 24 18          	mov    %eax,0x18(%esp)
	      d0 = d0 << bm;
  81183d:	8b 44 24 0c          	mov    0xc(%esp),%eax
  811841:	8a 4c 24 10          	mov    0x10(%esp),%cl
  811845:	d3 e0                	shl    %cl,%eax
  811847:	89 44 24 0c          	mov    %eax,0xc(%esp)
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
  81184b:	89 f2                	mov    %esi,%edx
  81184d:	d3 e2                	shl    %cl,%edx
	      n0 = n0 << bm;
  81184f:	8b 44 24 14          	mov    0x14(%esp),%eax
  811853:	d3 e0                	shl    %cl,%eax
  811855:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
  811859:	8b 44 24 14          	mov    0x14(%esp),%eax
  81185d:	89 f9                	mov    %edi,%ecx
  81185f:	d3 e8                	shr    %cl,%eax
  811861:	09 d0                	or     %edx,%eax

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
  811863:	d3 ee                	shr    %cl,%esi
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
  811865:	89 f2                	mov    %esi,%edx
  811867:	f7 74 24 18          	divl   0x18(%esp)
  81186b:	89 d6                	mov    %edx,%esi
	      umul_ppmm (m1, m0, q0, d0);
  81186d:	f7 64 24 0c          	mull   0xc(%esp)
  811871:	89 c5                	mov    %eax,%ebp
  811873:	89 d1                	mov    %edx,%ecx

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  811875:	39 d6                	cmp    %edx,%esi
  811877:	72 67                	jb     8118e0 <__umoddi3+0x114>
  811879:	74 75                	je     8118f0 <__umoddi3+0x124>
	      q1 = 0;

	      /* Remainder in (n1n0 - m1m0) >> bm.  */
	      if (rp != 0)
		{
		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
  81187b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  81187f:	29 e8                	sub    %ebp,%eax
  811881:	19 ce                	sbb    %ecx,%esi
		  rr.s.low = (n1 << b) | (n0 >> bm);
  811883:	8a 4c 24 10          	mov    0x10(%esp),%cl
  811887:	d3 e8                	shr    %cl,%eax
  811889:	89 f2                	mov    %esi,%edx
  81188b:	89 f9                	mov    %edi,%ecx
  81188d:	d3 e2                	shl    %cl,%edx
		  rr.s.high = n1 >> bm;
		  *rp = rr.ll;
  81188f:	09 d0                	or     %edx,%eax
  811891:	89 f2                	mov    %esi,%edx
  811893:	8a 4c 24 10          	mov    0x10(%esp),%cl
  811897:	d3 ea                	shr    %cl,%edx
  UDWtype w;

  (void) __udivmoddi4 (u, v, &w);

  return w;
}
  811899:	83 c4 20             	add    $0x20,%esp
  81189c:	5e                   	pop    %esi
  81189d:	5f                   	pop    %edi
  81189e:	5d                   	pop    %ebp
  81189f:	c3                   	ret    
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
  8118a0:	85 c9                	test   %ecx,%ecx
  8118a2:	75 0b                	jne    8118af <__umoddi3+0xe3>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
  8118a4:	b8 01 00 00 00       	mov    $0x1,%eax
  8118a9:	31 d2                	xor    %edx,%edx
  8118ab:	f7 f1                	div    %ecx
  8118ad:	89 c1                	mov    %eax,%ecx

	  udiv_qrnnd (q1, n1, 0, n1, d0);
  8118af:	89 f0                	mov    %esi,%eax
  8118b1:	31 d2                	xor    %edx,%edx
  8118b3:	f7 f1                	div    %ecx
	  udiv_qrnnd (q0, n0, n1, n0, d0);
  8118b5:	89 f8                	mov    %edi,%eax
  8118b7:	e9 3e ff ff ff       	jmp    8117fa <__umoddi3+0x2e>
	  /* Remainder in n1n0.  */
	  if (rp != 0)
	    {
	      rr.s.low = n0;
	      rr.s.high = n1;
	      *rp = rr.ll;
  8118bc:	89 f2                	mov    %esi,%edx
  UDWtype w;

  (void) __udivmoddi4 (u, v, &w);

  return w;
}
  8118be:	83 c4 20             	add    $0x20,%esp
  8118c1:	5e                   	pop    %esi
  8118c2:	5f                   	pop    %edi
  8118c3:	5d                   	pop    %ebp
  8118c4:	c3                   	ret    
  8118c5:	8d 76 00             	lea    0x0(%esi),%esi

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
  8118c8:	39 f5                	cmp    %esi,%ebp
  8118ca:	72 04                	jb     8118d0 <__umoddi3+0x104>
  8118cc:	39 f9                	cmp    %edi,%ecx
  8118ce:	77 06                	ja     8118d6 <__umoddi3+0x10a>
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
  8118d0:	89 f2                	mov    %esi,%edx
  8118d2:	29 cf                	sub    %ecx,%edi
  8118d4:	19 ea                	sbb    %ebp,%edx

	      if (rp != 0)
		{
		  rr.s.low = n0;
		  rr.s.high = n1;
		  *rp = rr.ll;
  8118d6:	89 f8                	mov    %edi,%eax
  UDWtype w;

  (void) __udivmoddi4 (u, v, &w);

  return w;
}
  8118d8:	83 c4 20             	add    $0x20,%esp
  8118db:	5e                   	pop    %esi
  8118dc:	5f                   	pop    %edi
  8118dd:	5d                   	pop    %ebp
  8118de:	c3                   	ret    
  8118df:	90                   	nop
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
		{
		  q0--;
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
  8118e0:	89 d1                	mov    %edx,%ecx
  8118e2:	89 c5                	mov    %eax,%ebp
  8118e4:	2b 6c 24 0c          	sub    0xc(%esp),%ebp
  8118e8:	1b 4c 24 18          	sbb    0x18(%esp),%ecx
  8118ec:	eb 8d                	jmp    81187b <__umoddi3+0xaf>
  8118ee:	66 90                	xchg   %ax,%ax
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  8118f0:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
  8118f4:	72 ea                	jb     8118e0 <__umoddi3+0x114>
  8118f6:	89 f1                	mov    %esi,%ecx
  8118f8:	eb 81                	jmp    81187b <__umoddi3+0xaf>
